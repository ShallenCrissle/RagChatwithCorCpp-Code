[
  {
    "type": "struct_assignment",
    "start_line": 1,
    "end_line": 323,
    "code": "//\n// Test page generator for LPrint, a Label Printer Application\n//\n// Copyright \u00a9\u00a02021-2023 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n#include \"lprint.h\"\n\n\n//\n// 'lprintTestFilterCB()' - Print a test page.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\nlprintTestFilterCB(\n    pappl_job_t    *job,\t\t// I - Job\n    pappl_device_t *device,\t\t// I - Output device\n    void           *cbdata)\t\t// I - Callback data (not used)\n{\n  pappl_pr_driver_data_t data;\t\t// Printer driver data\n  pappl_pr_options_t\t*options = papplJobCreatePrintOptions(job, 1, false);\n\t\t\t\t\t// Print options\n  unsigned char\t*line = NULL,\t\t// Output line\n\t\t*lineptr;\t\t// Pointer into line\n  unsigned\twidth,\t\t\t// Width accounting for margins\n\t\theight,\t\t\t// Height accounting for margins\n\t\ty,\t\t\t// Current position in page\n\t\tytop, yend, ybottom,\t// Top/end-of-image/bottom lines in page\n\t\txc,\t\t\t// X count\n\t\tx1mm, y1mm,\t\t// Number of columns/rows per pixel (nominally 1mm)\n\t\txleft,\t\t\t// Start for line\n\t\tpw, ph;\t\t\t// Image width and height\n  const char\t**pixels,\t\t// Output image pixels\n\t\t*pixel;\t\t\t// Current output pixel\n  bool\t\tret = false;\t\t// Return value\n  static const char *portrait[] =\t// Portrait label image\n  {\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \",\n    \"   ..     ...   \",\n    \"  .SS.   .SSS.  \",\n    \" .SS.   .SSSSS. \",\n    \" .SS.  .SS..SS. \",\n    \".SS.   .SS. .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS. .SS.   .SS.\",\n    \" .SS..SS.  .SS. \",\n    \" .SSSSS.   .SS. \",\n    \"  .SSS.   .SS.  \",\n    \"   ...     ..   \",\n    \"....        ....\",\n    \".EEE.      .EEE.\",\n    \".EE.  ....  .EE.\",\n    \".EE. .EEEE. .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE....EE....EE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \"................\",\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \"\n  };\n  static const char *landscape[] =\t// Landscape label image\n  {\n    \"........................    ....    ............\",\n    \".TTTTTTTTTT..EEEEEEEEEE.  ..SSSS..  .TTTTTTTTTT.\",\n    \".TTTTTTTTTT..EEEEEEEEEE. .SSSSSSSS. .TTTTTTTTTT.\",\n    \".T...TT...T..EE.......E..SSS....SSS..T...TT...T.\",\n    \" .  .TT.  . .EE.      . .SS.    ..S. .  .TT.  . \",\n    \"    .TT.    .EE.    .   .SS..     .     .TT.    \",\n    \"    .TT.    .EE.....E.   .SSS..         .TT.    \",\n    \"    .TT.    .EEEEEEEE.    .SSSS..       .TT.    \",\n    \"    .TT.    .EEEEEEEE.     ..SSSS.      .TT.    \",\n    \"    .TT.    .EE.....E.       ..SSS.     .TT.    \",\n    \"    .TT.    .EE.    .    .     ..SS.    .TT.    \",\n    \"    .TT.    .EE.      . .S.     .SS.    .TT.    \",\n    \"    .TT.    .EE.......E..SSS....SSS.    .TT.    \",\n    \"    .TT.    .EEEEEEEEEE. .SSSSSSSS.     .TT.    \",\n    \"   .TTTT.   .EEEEEEEEEE.  ..SSSS..     .TTTT.   \",\n    \"   ......   ............    ....       ......   \"\n  };\n\n\n  (void)cbdata;\n\n  // Validate options and allocate a line buffer...\n  if (!options)\n    goto done;\n\n  if ((line = malloc(options->header.cupsBytesPerLine)) == NULL)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate %u bytes for test page: %s\", options->header.cupsBytesPerLine, strerror(errno));\n    goto done;\n  }\n\n  width  = options->header.HWResolution[0] * (options->media.size_width - options->media.left_margin - options->media.right_margin) / 2540;\n  height = options->header.HWResolution[1] * (options->media.size_length - options->media.bottom_margin - options->media.top_margin) / 2540;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"Printable area for test page is %ux%u pixels.\", width, height);\n\n  if (width > height)\n  {\n    // Send landscape raster...\n    pixels = landscape;\n    pw     = 48;\n    ph     = 16;\n  }\n  else\n  {\n    // Send portrait raster...\n    pixels = portrait;\n    pw     = 16;\n    ph     = 48;\n  }\n\n  y1mm = 10 * options->header.HWResolution[1] / 254;\n  if ((y1mm * ph) > height)\n  {\n    if ((y1mm = height / ph) == 0)\n      y1mm = 1;\n  }\n\n  if ((x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1]) == 0)\n  {\n    x1mm = 1;\n    y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0];\n  }\n\n  if ((pw * x1mm) > width)\n  {\n    // Too wide, try scaling to fit the width...\n    x1mm = 10 * options->header.HWResolution[0] / 254;\n    if ((x1mm * pw) > width)\n      x1mm = width / pw;\n\n    if ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n  }\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, x1mm=%u, y1mm=%u\", pw, ph, x1mm, y1mm);\n\n  if (((pw + 2) * x1mm) > options->header.cupsWidth || ((ph + 2) * y1mm) > options->header.cupsHeight)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Label too small to print test page.\");\n    goto done;\n  }\n\n  pw *= x1mm;\n  ph *= y1mm;\n\n  xleft   = (width - pw) / 2 - x1mm + options->header.HWResolution[0] * options->media.left_margin / 2540;\n  ytop    = (height - ph) / 2 + options->header.HWResolution[1] * options->media.top_margin / 2540;\n  yend    = ytop + ph;\n  ybottom = options->header.cupsHeight - y1mm;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, ytop=%u, yend=%u, ybottom=%u\", pw, ph, ytop, yend, ybottom);\n\n  // Start the page...\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  papplJobSetImpressions(job, 1);\n\n  if (!(data.rstartjob_cb)(job, options, device))\n    goto done;\n\n  if (!(data.rstartpage_cb)(job, options, device, 1))\n    goto done;\n\n  // Send lines for the test label:\n  //\n  // +---------------+\n  // |...............|\n  // |...         ...|\n  // |... T E S T ...|\n  // |...         ...|\n  // |...............|\n  // +---------------+\n\n  // Top border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (y = 0; y < y1mm; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on upper half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ytop; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders, gray shading, and image pixels in middle\n  for (; y < yend; y ++)\n  {\n    // Draw a 50% gray pattern with black borders...\n    memset(line, 0, x1mm);\n    memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n    memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n    // Render the interior text...\n    for (pixel = pixels[(y - ytop) / y1mm], lineptr = line + xleft; *pixel; pixel ++)\n    {\n      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on lower half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ybottom; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Bottom border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (; y < options->header.cupsHeight; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Finish up...\n  if (!(data.rendpage_cb)(job, options, device, 1))\n    goto done;\n\n  if (!(data.rendjob_cb)(job, options, device))\n    goto done;\n\n  ret = true;\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  done:\n\n  free(line);\n  papplJobDeletePrintOptions(options);\n\n  return (ret);\n}\n\n\n//\n// 'lprintTestPageCB()' - Print a test page.\n//\n\nconst char *\t\t\t\t// O - Test page file\nlprintTestPageCB(\n    pappl_printer_t *printer,\t\t// I - Printer\n    char            *buffer,\t\t// I - Filename buffer\n    size_t          bufsize)\t\t// I - Size of filename buffer\n{\n  int\tfd;\t\t\t\t// File descriptor\n  char\ttestpage[] = LPRINT_TESTPAGE_HEADER;\n\t\t\t\t\t// Test page file header\n\n\n  if ((fd = papplCreateTempFile(buffer, bufsize, \"testpage\", \"tst\")) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Unable to create temporary file for test page: %s\", strerror(errno));\n    return (NULL);\n  }\n\n  if (write(fd, testpage, sizeof(testpage)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Unable to write temporary file for test page: %s\", strerror(errno));\n    close(fd);\n    return (NULL);\n  }\n\n  close(fd);\n\n  return (buffer);\n}\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 1,
    "end_line": 323,
    "code": "//\n// Test page generator for LPrint, a Label Printer Application\n//\n// Copyright \u00a9\u00a02021-2023 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n#include \"lprint.h\"\n\n\n//\n// 'lprintTestFilterCB()' - Print a test page.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\nlprintTestFilterCB(\n    pappl_job_t    *job,\t\t// I - Job\n    pappl_device_t *device,\t\t// I - Output device\n    void           *cbdata)\t\t// I - Callback data (not used)\n{\n  pappl_pr_driver_data_t data;\t\t// Printer driver data\n  pappl_pr_options_t\t*options = papplJobCreatePrintOptions(job, 1, false);\n\t\t\t\t\t// Print options\n  unsigned char\t*line = NULL,\t\t// Output line\n\t\t*lineptr;\t\t// Pointer into line\n  unsigned\twidth,\t\t\t// Width accounting for margins\n\t\theight,\t\t\t// Height accounting for margins\n\t\ty,\t\t\t// Current position in page\n\t\tytop, yend, ybottom,\t// Top/end-of-image/bottom lines in page\n\t\txc,\t\t\t// X count\n\t\tx1mm, y1mm,\t\t// Number of columns/rows per pixel (nominally 1mm)\n\t\txleft,\t\t\t// Start for line\n\t\tpw, ph;\t\t\t// Image width and height\n  const char\t**pixels,\t\t// Output image pixels\n\t\t*pixel;\t\t\t// Current output pixel\n  bool\t\tret = false;\t\t// Return value\n  static const char *portrait[] =\t// Portrait label image\n  {\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \",\n    \"   ..     ...   \",\n    \"  .SS.   .SSS.  \",\n    \" .SS.   .SSSSS. \",\n    \" .SS.  .SS..SS. \",\n    \".SS.   .SS. .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS. .SS.   .SS.\",\n    \" .SS..SS.  .SS. \",\n    \" .SSSSS.   .SS. \",\n    \"  .SSS.   .SS.  \",\n    \"   ...     ..   \",\n    \"....        ....\",\n    \".EEE.      .EEE.\",\n    \".EE.  ....  .EE.\",\n    \".EE. .EEEE. .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE....EE....EE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \"................\",\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \"\n  };\n  static const char *landscape[] =\t// Landscape label image\n  {\n    \"........................    ....    ............\",\n    \".TTTTTTTTTT..EEEEEEEEEE.  ..SSSS..  .TTTTTTTTTT.\",\n    \".TTTTTTTTTT..EEEEEEEEEE. .SSSSSSSS. .TTTTTTTTTT.\",\n    \".T...TT...T..EE.......E..SSS....SSS..T...TT...T.\",\n    \" .  .TT.  . .EE.      . .SS.    ..S. .  .TT.  . \",\n    \"    .TT.    .EE.    .   .SS..     .     .TT.    \",\n    \"    .TT.    .EE.....E.   .SSS..         .TT.    \",\n    \"    .TT.    .EEEEEEEE.    .SSSS..       .TT.    \",\n    \"    .TT.    .EEEEEEEE.     ..SSSS.      .TT.    \",\n    \"    .TT.    .EE.....E.       ..SSS.     .TT.    \",\n    \"    .TT.    .EE.    .    .     ..SS.    .TT.    \",\n    \"    .TT.    .EE.      . .S.     .SS.    .TT.    \",\n    \"    .TT.    .EE.......E..SSS....SSS.    .TT.    \",\n    \"    .TT.    .EEEEEEEEEE. .SSSSSSSS.     .TT.    \",\n    \"   .TTTT.   .EEEEEEEEEE.  ..SSSS..     .TTTT.   \",\n    \"   ......   ............    ....       ......   \"\n  };\n\n\n  (void)cbdata;\n\n  // Validate options and allocate a line buffer...\n  if (!options)\n    goto done;\n\n  if ((line = malloc(options->header.cupsBytesPerLine)) == NULL)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate %u bytes for test page: %s\", options->header.cupsBytesPerLine, strerror(errno));\n    goto done;\n  }\n\n  width  = options->header.HWResolution[0] * (options->media.size_width - options->media.left_margin - options->media.right_margin) / 2540;\n  height = options->header.HWResolution[1] * (options->media.size_length - options->media.bottom_margin - options->media.top_margin) / 2540;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"Printable area for test page is %ux%u pixels.\", width, height);\n\n  if (width > height)\n  {\n    // Send landscape raster...\n    pixels = landscape;\n    pw     = 48;\n    ph     = 16;\n  }\n  else\n  {\n    // Send portrait raster...\n    pixels = portrait;\n    pw     = 16;\n    ph     = 48;\n  }\n\n  y1mm = 10 * options->header.HWResolution[1] / 254;\n  if ((y1mm * ph) > height)\n  {\n    if ((y1mm = height / ph) == 0)\n      y1mm = 1;\n  }\n\n  if ((x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1]) == 0)\n  {\n    x1mm = 1;\n    y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0];\n  }\n\n  if ((pw * x1mm) > width)\n  {\n    // Too wide, try scaling to fit the width...\n    x1mm = 10 * options->header.HWResolution[0] / 254;\n    if ((x1mm * pw) > width)\n      x1mm = width / pw;\n\n    if ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n  }\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, x1mm=%u, y1mm=%u\", pw, ph, x1mm, y1mm);\n\n  if (((pw + 2) * x1mm) > options->header.cupsWidth || ((ph + 2) * y1mm) > options->header.cupsHeight)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Label too small to print test page.\");\n    goto done;\n  }\n\n  pw *= x1mm;\n  ph *= y1mm;\n\n  xleft   = (width - pw) / 2 - x1mm + options->header.HWResolution[0] * options->media.left_margin / 2540;\n  ytop    = (height - ph) / 2 + options->header.HWResolution[1] * options->media.top_margin / 2540;\n  yend    = ytop + ph;\n  ybottom = options->header.cupsHeight - y1mm;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, ytop=%u, yend=%u, ybottom=%u\", pw, ph, ytop, yend, ybottom);\n\n  // Start the page...\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  papplJobSetImpressions(job, 1);\n\n  if (!(data.rstartjob_cb)(job, options, device))\n    goto done;\n\n  if (!(data.rstartpage_cb)(job, options, device, 1))\n    goto done;\n\n  // Send lines for the test label:\n  //\n  // +---------------+\n  // |...............|\n  // |...         ...|\n  // |... T E S T ...|\n  // |...         ...|\n  // |...............|\n  // +---------------+\n\n  // Top border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (y = 0; y < y1mm; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on upper half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ytop; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders, gray shading, and image pixels in middle\n  for (; y < yend; y ++)\n  {\n    // Draw a 50% gray pattern with black borders...\n    memset(line, 0, x1mm);\n    memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n    memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n    // Render the interior text...\n    for (pixel = pixels[(y - ytop) / y1mm], lineptr = line + xleft; *pixel; pixel ++)\n    {\n      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on lower half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ybottom; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Bottom border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (; y < options->header.cupsHeight; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Finish up...\n  if (!(data.rendpage_cb)(job, options, device, 1))\n    goto done;\n\n  if (!(data.rendjob_cb)(job, options, device))\n    goto done;\n\n  ret = true;\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  done:\n\n  free(line);\n  papplJobDeletePrintOptions(options);\n\n  return (ret);\n}\n\n\n//\n// 'lprintTestPageCB()' - Print a test page.\n//\n\nconst char *\t\t\t\t// O - Test page file\nlprintTestPageCB(\n    pappl_printer_t *printer,\t\t// I - Printer\n    char            *buffer,\t\t// I - Filename buffer\n    size_t          bufsize)\t\t// I - Size of filename buffer\n{\n  int\tfd;\t\t\t\t// File descriptor\n  char\ttestpage[] = LPRINT_TESTPAGE_HEADER;\n\t\t\t\t\t// Test page file header\n\n\n  if ((fd = papplCreateTempFile(buffer, bufsize, \"testpage\", \"tst\")) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Unable to create temporary file for test page: %s\", strerror(errno));\n    return (NULL);\n  }\n\n  if (write(fd, testpage, sizeof(testpage)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Unable to write temporary file for test page: %s\", strerror(errno));\n    close(fd);\n    return (NULL);\n  }\n\n  close(fd);\n\n  return (buffer);\n}\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 1,
    "end_line": 323,
    "code": "//\n// Test page generator for LPrint, a Label Printer Application\n//\n// Copyright \u00a9\u00a02021-2023 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n#include \"lprint.h\"\n\n\n//\n// 'lprintTestFilterCB()' - Print a test page.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\nlprintTestFilterCB(\n    pappl_job_t    *job,\t\t// I - Job\n    pappl_device_t *device,\t\t// I - Output device\n    void           *cbdata)\t\t// I - Callback data (not used)\n{\n  pappl_pr_driver_data_t data;\t\t// Printer driver data\n  pappl_pr_options_t\t*options = papplJobCreatePrintOptions(job, 1, false);\n\t\t\t\t\t// Print options\n  unsigned char\t*line = NULL,\t\t// Output line\n\t\t*lineptr;\t\t// Pointer into line\n  unsigned\twidth,\t\t\t// Width accounting for margins\n\t\theight,\t\t\t// Height accounting for margins\n\t\ty,\t\t\t// Current position in page\n\t\tytop, yend, ybottom,\t// Top/end-of-image/bottom lines in page\n\t\txc,\t\t\t// X count\n\t\tx1mm, y1mm,\t\t// Number of columns/rows per pixel (nominally 1mm)\n\t\txleft,\t\t\t// Start for line\n\t\tpw, ph;\t\t\t// Image width and height\n  const char\t**pixels,\t\t// Output image pixels\n\t\t*pixel;\t\t\t// Current output pixel\n  bool\t\tret = false;\t\t// Return value\n  static const char *portrait[] =\t// Portrait label image\n  {\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \",\n    \"   ..     ...   \",\n    \"  .SS.   .SSS.  \",\n    \" .SS.   .SSSSS. \",\n    \" .SS.  .SS..SS. \",\n    \".SS.   .SS. .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS. .SS.   .SS.\",\n    \" .SS..SS.  .SS. \",\n    \" .SSSSS.   .SS. \",\n    \"  .SSS.   .SS.  \",\n    \"   ...     ..   \",\n    \"....        ....\",\n    \".EEE.      .EEE.\",\n    \".EE.  ....  .EE.\",\n    \".EE. .EEEE. .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE....EE....EE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \"................\",\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \"\n  };\n  static const char *landscape[] =\t// Landscape label image\n  {\n    \"........................    ....    ............\",\n    \".TTTTTTTTTT..EEEEEEEEEE.  ..SSSS..  .TTTTTTTTTT.\",\n    \".TTTTTTTTTT..EEEEEEEEEE. .SSSSSSSS. .TTTTTTTTTT.\",\n    \".T...TT...T..EE.......E..SSS....SSS..T...TT...T.\",\n    \" .  .TT.  . .EE.      . .SS.    ..S. .  .TT.  . \",\n    \"    .TT.    .EE.    .   .SS..     .     .TT.    \",\n    \"    .TT.    .EE.....E.   .SSS..         .TT.    \",\n    \"    .TT.    .EEEEEEEE.    .SSSS..       .TT.    \",\n    \"    .TT.    .EEEEEEEE.     ..SSSS.      .TT.    \",\n    \"    .TT.    .EE.....E.       ..SSS.     .TT.    \",\n    \"    .TT.    .EE.    .    .     ..SS.    .TT.    \",\n    \"    .TT.    .EE.      . .S.     .SS.    .TT.    \",\n    \"    .TT.    .EE.......E..SSS....SSS.    .TT.    \",\n    \"    .TT.    .EEEEEEEEEE. .SSSSSSSS.     .TT.    \",\n    \"   .TTTT.   .EEEEEEEEEE.  ..SSSS..     .TTTT.   \",\n    \"   ......   ............    ....       ......   \"\n  };\n\n\n  (void)cbdata;\n\n  // Validate options and allocate a line buffer...\n  if (!options)\n    goto done;\n\n  if ((line = malloc(options->header.cupsBytesPerLine)) == NULL)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate %u bytes for test page: %s\", options->header.cupsBytesPerLine, strerror(errno));\n    goto done;\n  }\n\n  width  = options->header.HWResolution[0] * (options->media.size_width - options->media.left_margin - options->media.right_margin) / 2540;\n  height = options->header.HWResolution[1] * (options->media.size_length - options->media.bottom_margin - options->media.top_margin) / 2540;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"Printable area for test page is %ux%u pixels.\", width, height);\n\n  if (width > height)\n  {\n    // Send landscape raster...\n    pixels = landscape;\n    pw     = 48;\n    ph     = 16;\n  }\n  else\n  {\n    // Send portrait raster...\n    pixels = portrait;\n    pw     = 16;\n    ph     = 48;\n  }\n\n  y1mm = 10 * options->header.HWResolution[1] / 254;\n  if ((y1mm * ph) > height)\n  {\n    if ((y1mm = height / ph) == 0)\n      y1mm = 1;\n  }\n\n  if ((x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1]) == 0)\n  {\n    x1mm = 1;\n    y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0];\n  }\n\n  if ((pw * x1mm) > width)\n  {\n    // Too wide, try scaling to fit the width...\n    x1mm = 10 * options->header.HWResolution[0] / 254;\n    if ((x1mm * pw) > width)\n      x1mm = width / pw;\n\n    if ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n  }\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, x1mm=%u, y1mm=%u\", pw, ph, x1mm, y1mm);\n\n  if (((pw + 2) * x1mm) > options->header.cupsWidth || ((ph + 2) * y1mm) > options->header.cupsHeight)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Label too small to print test page.\");\n    goto done;\n  }\n\n  pw *= x1mm;\n  ph *= y1mm;\n\n  xleft   = (width - pw) / 2 - x1mm + options->header.HWResolution[0] * options->media.left_margin / 2540;\n  ytop    = (height - ph) / 2 + options->header.HWResolution[1] * options->media.top_margin / 2540;\n  yend    = ytop + ph;\n  ybottom = options->header.cupsHeight - y1mm;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, ytop=%u, yend=%u, ybottom=%u\", pw, ph, ytop, yend, ybottom);\n\n  // Start the page...\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  papplJobSetImpressions(job, 1);\n\n  if (!(data.rstartjob_cb)(job, options, device))\n    goto done;\n\n  if (!(data.rstartpage_cb)(job, options, device, 1))\n    goto done;\n\n  // Send lines for the test label:\n  //\n  // +---------------+\n  // |...............|\n  // |...         ...|\n  // |... T E S T ...|\n  // |...         ...|\n  // |...............|\n  // +---------------+\n\n  // Top border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (y = 0; y < y1mm; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on upper half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ytop; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders, gray shading, and image pixels in middle\n  for (; y < yend; y ++)\n  {\n    // Draw a 50% gray pattern with black borders...\n    memset(line, 0, x1mm);\n    memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n    memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n    // Render the interior text...\n    for (pixel = pixels[(y - ytop) / y1mm], lineptr = line + xleft; *pixel; pixel ++)\n    {\n      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on lower half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ybottom; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Bottom border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (; y < options->header.cupsHeight; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Finish up...\n  if (!(data.rendpage_cb)(job, options, device, 1))\n    goto done;\n\n  if (!(data.rendjob_cb)(job, options, device))\n    goto done;\n\n  ret = true;\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  done:\n\n  free(line);\n  papplJobDeletePrintOptions(options);\n\n  return (ret);\n}\n\n\n//\n// 'lprintTestPageCB()' - Print a test page.\n//\n\nconst char *\t\t\t\t// O - Test page file\nlprintTestPageCB(\n    pappl_printer_t *printer,\t\t// I - Printer\n    char            *buffer,\t\t// I - Filename buffer\n    size_t          bufsize)\t\t// I - Size of filename buffer\n{\n  int\tfd;\t\t\t\t// File descriptor\n  char\ttestpage[] = LPRINT_TESTPAGE_HEADER;\n\t\t\t\t\t// Test page file header\n\n\n  if ((fd = papplCreateTempFile(buffer, bufsize, \"testpage\", \"tst\")) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Unable to create temporary file for test page: %s\", strerror(errno));\n    return (NULL);\n  }\n\n  if (write(fd, testpage, sizeof(testpage)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Unable to write temporary file for test page: %s\", strerror(errno));\n    close(fd);\n    return (NULL);\n  }\n\n  close(fd);\n\n  return (buffer);\n}\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "include",
    "start_line": 10,
    "end_line": 11,
    "code": "nclude \"lprint.h\"\n\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function",
    "start_line": 17,
    "end_line": 288,
    "name": "lprintTestFilterCB",
    "parent": null,
    "hierarchy": "lprintTestFilterCB",
    "code": "ol\t\t\t\t\t// O - `true` on success, `false` on failure\nlprintTestFilterCB(\n    pappl_job_t    *job,\t\t// I - Job\n    pappl_device_t *device,\t\t// I - Output device\n    void           *cbdata)\t\t// I - Callback data (not used)\n{\n  pappl_pr_driver_data_t data;\t\t// Printer driver data\n  pappl_pr_options_t\t*options = papplJobCreatePrintOptions(job, 1, false);\n\t\t\t\t\t// Print options\n  unsigned char\t*line = NULL,\t\t// Output line\n\t\t*lineptr;\t\t// Pointer into line\n  unsigned\twidth,\t\t\t// Width accounting for margins\n\t\theight,\t\t\t// Height accounting for margins\n\t\ty,\t\t\t// Current position in page\n\t\tytop, yend, ybottom,\t// Top/end-of-image/bottom lines in page\n\t\txc,\t\t\t// X count\n\t\tx1mm, y1mm,\t\t// Number of columns/rows per pixel (nominally 1mm)\n\t\txleft,\t\t\t// Start for line\n\t\tpw, ph;\t\t\t// Image width and height\n  const char\t**pixels,\t\t// Output image pixels\n\t\t*pixel;\t\t\t// Current output pixel\n  bool\t\tret = false;\t\t// Return value\n  static const char *portrait[] =\t// Portrait label image\n  {\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \",\n    \"   ..     ...   \",\n    \"  .SS.   .SSS.  \",\n    \" .SS.   .SSSSS. \",\n    \" .SS.  .SS..SS. \",\n    \".SS.   .SS. .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS. .SS.   .SS.\",\n    \" .SS..SS.  .SS. \",\n    \" .SSSSS.   .SS. \",\n    \"  .SSS.   .SS.  \",\n    \"   ...     ..   \",\n    \"....        ....\",\n    \".EEE.      .EEE.\",\n    \".EE.  ....  .EE.\",\n    \".EE. .EEEE. .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE....EE....EE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \"................\",\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \"\n  };\n  static const char *landscape[] =\t// Landscape label image\n  {\n    \"........................    ....    ............\",\n    \".TTTTTTTTTT..EEEEEEEEEE.  ..SSSS..  .TTTTTTTTTT.\",\n    \".TTTTTTTTTT..EEEEEEEEEE. .SSSSSSSS. .TTTTTTTTTT.\",\n    \".T...TT...T..EE.......E..SSS....SSS..T...TT...T.\",\n    \" .  .TT.  . .EE.      . .SS.    ..S. .  .TT.  . \",\n    \"    .TT.    .EE.    .   .SS..     .     .TT.    \",\n    \"    .TT.    .EE.....E.   .SSS..         .TT.    \",\n    \"    .TT.    .EEEEEEEE.    .SSSS..       .TT.    \",\n    \"    .TT.    .EEEEEEEE.     ..SSSS.      .TT.    \",\n    \"    .TT.    .EE.....E.       ..SSS.     .TT.    \",\n    \"    .TT.    .EE.    .    .     ..SS.    .TT.    \",\n    \"    .TT.    .EE.      . .S.     .SS.    .TT.    \",\n    \"    .TT.    .EE.......E..SSS....SSS.    .TT.    \",\n    \"    .TT.    .EEEEEEEEEE. .SSSSSSSS.     .TT.    \",\n    \"   .TTTT.   .EEEEEEEEEE.  ..SSSS..     .TTTT.   \",\n    \"   ......   ............    ....       ......   \"\n  };\n\n\n  (void)cbdata;\n\n  // Validate options and allocate a line buffer...\n  if (!options)\n    goto done;\n\n  if ((line = malloc(options->header.cupsBytesPerLine)) == NULL)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate %u bytes for test page: %s\", options->header.cupsBytesPerLine, strerror(errno));\n    goto done;\n  }\n\n  width  = options->header.HWResolution[0] * (options->media.size_width - options->media.left_margin - options->media.right_margin) / 2540;\n  height = options->header.HWResolution[1] * (options->media.size_length - options->media.bottom_margin - options->media.top_margin) / 2540;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"Printable area for test page is %ux%u pixels.\", width, height);\n\n  if (width > height)\n  {\n    // Send landscape raster...\n    pixels = landscape;\n    pw     = 48;\n    ph     = 16;\n  }\n  else\n  {\n    // Send portrait raster...\n    pixels = portrait;\n    pw     = 16;\n    ph     = 48;\n  }\n\n  y1mm = 10 * options->header.HWResolution[1] / 254;\n  if ((y1mm * ph) > height)\n  {\n    if ((y1mm = height / ph) == 0)\n      y1mm = 1;\n  }\n\n  if ((x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1]) == 0)\n  {\n    x1mm = 1;\n    y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0];\n  }\n\n  if ((pw * x1mm) > width)\n  {\n    // Too wide, try scaling to fit the width...\n    x1mm = 10 * options->header.HWResolution[0] / 254;\n    if ((x1mm * pw) > width)\n      x1mm = width / pw;\n\n    if ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n  }\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, x1mm=%u, y1mm=%u\", pw, ph, x1mm, y1mm);\n\n  if (((pw + 2) * x1mm) > options->header.cupsWidth || ((ph + 2) * y1mm) > options->header.cupsHeight)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Label too small to print test page.\");\n    goto done;\n  }\n\n  pw *= x1mm;\n  ph *= y1mm;\n\n  xleft   = (width - pw) / 2 - x1mm + options->header.HWResolution[0] * options->media.left_margin / 2540;\n  ytop    = (height - ph) / 2 + options->header.HWResolution[1] * options->media.top_margin / 2540;\n  yend    = ytop + ph;\n  ybottom = options->header.cupsHeight - y1mm;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, ytop=%u, yend=%u, ybottom=%u\", pw, ph, ytop, yend, ybottom);\n\n  // Start the page...\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  papplJobSetImpressions(job, 1);\n\n  if (!(data.rstartjob_cb)(job, options, device))\n    goto done;\n\n  if (!(data.rstartpage_cb)(job, options, device, 1))\n    goto done;\n\n  // Send lines for the test label:\n  //\n  // +---------------+\n  // |...............|\n  // |...         ...|\n  // |... T E S T ...|\n  // |...         ...|\n  // |...............|\n  // +---------------+\n\n  // Top border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (y = 0; y < y1mm; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on upper half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ytop; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders, gray shading, and image pixels in middle\n  for (; y < yend; y ++)\n  {\n    // Draw a 50% gray pattern with black borders...\n    memset(line, 0, x1mm);\n    memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n    memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n    // Render the interior text...\n    for (pixel = pixels[(y - ytop) / y1mm], lineptr = line + xleft; *pixel; pixel ++)\n    {\n      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on lower half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ybottom; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Bottom border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (; y < options->header.cupsHeight; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Finish up...\n  if (!(data.rendpage_cb)(job, options, device, 1))\n    goto done;\n\n  if (!(data.rendjob_cb)(job, options, device))\n    goto done;\n\n  ret = true;\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  done:\n\n  free(line);\n  papplJobDeletePrintOptions(options);\n\n  return (ret);\n}\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 17,
    "end_line": 288,
    "code": "ol\t\t\t\t\t// O - `true` on success, `false` on failure\nlprintTestFilterCB(\n    pappl_job_t    *job,\t\t// I - Job\n    pappl_device_t *device,\t\t// I - Output device\n    void           *cbdata)\t\t// I - Callback data (not used)\n{\n  pappl_pr_driver_data_t data;\t\t// Printer driver data\n  pappl_pr_options_t\t*options = papplJobCreatePrintOptions(job, 1, false);\n\t\t\t\t\t// Print options\n  unsigned char\t*line = NULL,\t\t// Output line\n\t\t*lineptr;\t\t// Pointer into line\n  unsigned\twidth,\t\t\t// Width accounting for margins\n\t\theight,\t\t\t// Height accounting for margins\n\t\ty,\t\t\t// Current position in page\n\t\tytop, yend, ybottom,\t// Top/end-of-image/bottom lines in page\n\t\txc,\t\t\t// X count\n\t\tx1mm, y1mm,\t\t// Number of columns/rows per pixel (nominally 1mm)\n\t\txleft,\t\t\t// Start for line\n\t\tpw, ph;\t\t\t// Image width and height\n  const char\t**pixels,\t\t// Output image pixels\n\t\t*pixel;\t\t\t// Current output pixel\n  bool\t\tret = false;\t\t// Return value\n  static const char *portrait[] =\t// Portrait label image\n  {\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \",\n    \"   ..     ...   \",\n    \"  .SS.   .SSS.  \",\n    \" .SS.   .SSSSS. \",\n    \" .SS.  .SS..SS. \",\n    \".SS.   .SS. .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS. .SS.   .SS.\",\n    \" .SS..SS.  .SS. \",\n    \" .SSSSS.   .SS. \",\n    \"  .SSS.   .SS.  \",\n    \"   ...     ..   \",\n    \"....        ....\",\n    \".EEE.      .EEE.\",\n    \".EE.  ....  .EE.\",\n    \".EE. .EEEE. .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE....EE....EE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \"................\",\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \"\n  };\n  static const char *landscape[] =\t// Landscape label image\n  {\n    \"........................    ....    ............\",\n    \".TTTTTTTTTT..EEEEEEEEEE.  ..SSSS..  .TTTTTTTTTT.\",\n    \".TTTTTTTTTT..EEEEEEEEEE. .SSSSSSSS. .TTTTTTTTTT.\",\n    \".T...TT...T..EE.......E..SSS....SSS..T...TT...T.\",\n    \" .  .TT.  . .EE.      . .SS.    ..S. .  .TT.  . \",\n    \"    .TT.    .EE.    .   .SS..     .     .TT.    \",\n    \"    .TT.    .EE.....E.   .SSS..         .TT.    \",\n    \"    .TT.    .EEEEEEEE.    .SSSS..       .TT.    \",\n    \"    .TT.    .EEEEEEEE.     ..SSSS.      .TT.    \",\n    \"    .TT.    .EE.....E.       ..SSS.     .TT.    \",\n    \"    .TT.    .EE.    .    .     ..SS.    .TT.    \",\n    \"    .TT.    .EE.      . .S.     .SS.    .TT.    \",\n    \"    .TT.    .EE.......E..SSS....SSS.    .TT.    \",\n    \"    .TT.    .EEEEEEEEEE. .SSSSSSSS.     .TT.    \",\n    \"   .TTTT.   .EEEEEEEEEE.  ..SSSS..     .TTTT.   \",\n    \"   ......   ............    ....       ......   \"\n  };\n\n\n  (void)cbdata;\n\n  // Validate options and allocate a line buffer...\n  if (!options)\n    goto done;\n\n  if ((line = malloc(options->header.cupsBytesPerLine)) == NULL)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate %u bytes for test page: %s\", options->header.cupsBytesPerLine, strerror(errno));\n    goto done;\n  }\n\n  width  = options->header.HWResolution[0] * (options->media.size_width - options->media.left_margin - options->media.right_margin) / 2540;\n  height = options->header.HWResolution[1] * (options->media.size_length - options->media.bottom_margin - options->media.top_margin) / 2540;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"Printable area for test page is %ux%u pixels.\", width, height);\n\n  if (width > height)\n  {\n    // Send landscape raster...\n    pixels = landscape;\n    pw     = 48;\n    ph     = 16;\n  }\n  else\n  {\n    // Send portrait raster...\n    pixels = portrait;\n    pw     = 16;\n    ph     = 48;\n  }\n\n  y1mm = 10 * options->header.HWResolution[1] / 254;\n  if ((y1mm * ph) > height)\n  {\n    if ((y1mm = height / ph) == 0)\n      y1mm = 1;\n  }\n\n  if ((x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1]) == 0)\n  {\n    x1mm = 1;\n    y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0];\n  }\n\n  if ((pw * x1mm) > width)\n  {\n    // Too wide, try scaling to fit the width...\n    x1mm = 10 * options->header.HWResolution[0] / 254;\n    if ((x1mm * pw) > width)\n      x1mm = width / pw;\n\n    if ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n  }\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, x1mm=%u, y1mm=%u\", pw, ph, x1mm, y1mm);\n\n  if (((pw + 2) * x1mm) > options->header.cupsWidth || ((ph + 2) * y1mm) > options->header.cupsHeight)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Label too small to print test page.\");\n    goto done;\n  }\n\n  pw *= x1mm;\n  ph *= y1mm;\n\n  xleft   = (width - pw) / 2 - x1mm + options->header.HWResolution[0] * options->media.left_margin / 2540;\n  ytop    = (height - ph) / 2 + options->header.HWResolution[1] * options->media.top_margin / 2540;\n  yend    = ytop + ph;\n  ybottom = options->header.cupsHeight - y1mm;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, ytop=%u, yend=%u, ybottom=%u\", pw, ph, ytop, yend, ybottom);\n\n  // Start the page...\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  papplJobSetImpressions(job, 1);\n\n  if (!(data.rstartjob_cb)(job, options, device))\n    goto done;\n\n  if (!(data.rstartpage_cb)(job, options, device, 1))\n    goto done;\n\n  // Send lines for the test label:\n  //\n  // +---------------+\n  // |...............|\n  // |...         ...|\n  // |... T E S T ...|\n  // |...         ...|\n  // |...............|\n  // +---------------+\n\n  // Top border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (y = 0; y < y1mm; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on upper half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ytop; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders, gray shading, and image pixels in middle\n  for (; y < yend; y ++)\n  {\n    // Draw a 50% gray pattern with black borders...\n    memset(line, 0, x1mm);\n    memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n    memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n    // Render the interior text...\n    for (pixel = pixels[(y - ytop) / y1mm], lineptr = line + xleft; *pixel; pixel ++)\n    {\n      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on lower half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ybottom; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Bottom border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (; y < options->header.cupsHeight; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Finish up...\n  if (!(data.rendpage_cb)(job, options, device, 1))\n    goto done;\n\n  if (!(data.rendjob_cb)(job, options, device))\n    goto done;\n\n  ret = true;\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  done:\n\n  free(line);\n  papplJobDeletePrintOptions(options);\n\n  return (ret);\n}\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 17,
    "end_line": 288,
    "code": "ol\t\t\t\t\t// O - `true` on success, `false` on failure\nlprintTestFilterCB(\n    pappl_job_t    *job,\t\t// I - Job\n    pappl_device_t *device,\t\t// I - Output device\n    void           *cbdata)\t\t// I - Callback data (not used)\n{\n  pappl_pr_driver_data_t data;\t\t// Printer driver data\n  pappl_pr_options_t\t*options = papplJobCreatePrintOptions(job, 1, false);\n\t\t\t\t\t// Print options\n  unsigned char\t*line = NULL,\t\t// Output line\n\t\t*lineptr;\t\t// Pointer into line\n  unsigned\twidth,\t\t\t// Width accounting for margins\n\t\theight,\t\t\t// Height accounting for margins\n\t\ty,\t\t\t// Current position in page\n\t\tytop, yend, ybottom,\t// Top/end-of-image/bottom lines in page\n\t\txc,\t\t\t// X count\n\t\tx1mm, y1mm,\t\t// Number of columns/rows per pixel (nominally 1mm)\n\t\txleft,\t\t\t// Start for line\n\t\tpw, ph;\t\t\t// Image width and height\n  const char\t**pixels,\t\t// Output image pixels\n\t\t*pixel;\t\t\t// Current output pixel\n  bool\t\tret = false;\t\t// Return value\n  static const char *portrait[] =\t// Portrait label image\n  {\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \",\n    \"   ..     ...   \",\n    \"  .SS.   .SSS.  \",\n    \" .SS.   .SSSSS. \",\n    \" .SS.  .SS..SS. \",\n    \".SS.   .SS. .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS. .SS.   .SS.\",\n    \" .SS..SS.  .SS. \",\n    \" .SSSSS.   .SS. \",\n    \"  .SSS.   .SS.  \",\n    \"   ...     ..   \",\n    \"....        ....\",\n    \".EEE.      .EEE.\",\n    \".EE.  ....  .EE.\",\n    \".EE. .EEEE. .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE....EE....EE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \"................\",\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \"\n  };\n  static const char *landscape[] =\t// Landscape label image\n  {\n    \"........................    ....    ............\",\n    \".TTTTTTTTTT..EEEEEEEEEE.  ..SSSS..  .TTTTTTTTTT.\",\n    \".TTTTTTTTTT..EEEEEEEEEE. .SSSSSSSS. .TTTTTTTTTT.\",\n    \".T...TT...T..EE.......E..SSS....SSS..T...TT...T.\",\n    \" .  .TT.  . .EE.      . .SS.    ..S. .  .TT.  . \",\n    \"    .TT.    .EE.    .   .SS..     .     .TT.    \",\n    \"    .TT.    .EE.....E.   .SSS..         .TT.    \",\n    \"    .TT.    .EEEEEEEE.    .SSSS..       .TT.    \",\n    \"    .TT.    .EEEEEEEE.     ..SSSS.      .TT.    \",\n    \"    .TT.    .EE.....E.       ..SSS.     .TT.    \",\n    \"    .TT.    .EE.    .    .     ..SS.    .TT.    \",\n    \"    .TT.    .EE.      . .S.     .SS.    .TT.    \",\n    \"    .TT.    .EE.......E..SSS....SSS.    .TT.    \",\n    \"    .TT.    .EEEEEEEEEE. .SSSSSSSS.     .TT.    \",\n    \"   .TTTT.   .EEEEEEEEEE.  ..SSSS..     .TTTT.   \",\n    \"   ......   ............    ....       ......   \"\n  };\n\n\n  (void)cbdata;\n\n  // Validate options and allocate a line buffer...\n  if (!options)\n    goto done;\n\n  if ((line = malloc(options->header.cupsBytesPerLine)) == NULL)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate %u bytes for test page: %s\", options->header.cupsBytesPerLine, strerror(errno));\n    goto done;\n  }\n\n  width  = options->header.HWResolution[0] * (options->media.size_width - options->media.left_margin - options->media.right_margin) / 2540;\n  height = options->header.HWResolution[1] * (options->media.size_length - options->media.bottom_margin - options->media.top_margin) / 2540;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"Printable area for test page is %ux%u pixels.\", width, height);\n\n  if (width > height)\n  {\n    // Send landscape raster...\n    pixels = landscape;\n    pw     = 48;\n    ph     = 16;\n  }\n  else\n  {\n    // Send portrait raster...\n    pixels = portrait;\n    pw     = 16;\n    ph     = 48;\n  }\n\n  y1mm = 10 * options->header.HWResolution[1] / 254;\n  if ((y1mm * ph) > height)\n  {\n    if ((y1mm = height / ph) == 0)\n      y1mm = 1;\n  }\n\n  if ((x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1]) == 0)\n  {\n    x1mm = 1;\n    y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0];\n  }\n\n  if ((pw * x1mm) > width)\n  {\n    // Too wide, try scaling to fit the width...\n    x1mm = 10 * options->header.HWResolution[0] / 254;\n    if ((x1mm * pw) > width)\n      x1mm = width / pw;\n\n    if ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n  }\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, x1mm=%u, y1mm=%u\", pw, ph, x1mm, y1mm);\n\n  if (((pw + 2) * x1mm) > options->header.cupsWidth || ((ph + 2) * y1mm) > options->header.cupsHeight)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Label too small to print test page.\");\n    goto done;\n  }\n\n  pw *= x1mm;\n  ph *= y1mm;\n\n  xleft   = (width - pw) / 2 - x1mm + options->header.HWResolution[0] * options->media.left_margin / 2540;\n  ytop    = (height - ph) / 2 + options->header.HWResolution[1] * options->media.top_margin / 2540;\n  yend    = ytop + ph;\n  ybottom = options->header.cupsHeight - y1mm;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, ytop=%u, yend=%u, ybottom=%u\", pw, ph, ytop, yend, ybottom);\n\n  // Start the page...\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  papplJobSetImpressions(job, 1);\n\n  if (!(data.rstartjob_cb)(job, options, device))\n    goto done;\n\n  if (!(data.rstartpage_cb)(job, options, device, 1))\n    goto done;\n\n  // Send lines for the test label:\n  //\n  // +---------------+\n  // |...............|\n  // |...         ...|\n  // |... T E S T ...|\n  // |...         ...|\n  // |...............|\n  // +---------------+\n\n  // Top border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (y = 0; y < y1mm; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on upper half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ytop; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders, gray shading, and image pixels in middle\n  for (; y < yend; y ++)\n  {\n    // Draw a 50% gray pattern with black borders...\n    memset(line, 0, x1mm);\n    memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n    memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n    // Render the interior text...\n    for (pixel = pixels[(y - ytop) / y1mm], lineptr = line + xleft; *pixel; pixel ++)\n    {\n      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on lower half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ybottom; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Bottom border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (; y < options->header.cupsHeight; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Finish up...\n  if (!(data.rendpage_cb)(job, options, device, 1))\n    goto done;\n\n  if (!(data.rendjob_cb)(job, options, device))\n    goto done;\n\n  ret = true;\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  done:\n\n  free(line);\n  papplJobDeletePrintOptions(options);\n\n  return (ret);\n}\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 17,
    "end_line": 288,
    "code": "ol\t\t\t\t\t// O - `true` on success, `false` on failure\nlprintTestFilterCB(\n    pappl_job_t    *job,\t\t// I - Job\n    pappl_device_t *device,\t\t// I - Output device\n    void           *cbdata)\t\t// I - Callback data (not used)\n{\n  pappl_pr_driver_data_t data;\t\t// Printer driver data\n  pappl_pr_options_t\t*options = papplJobCreatePrintOptions(job, 1, false);\n\t\t\t\t\t// Print options\n  unsigned char\t*line = NULL,\t\t// Output line\n\t\t*lineptr;\t\t// Pointer into line\n  unsigned\twidth,\t\t\t// Width accounting for margins\n\t\theight,\t\t\t// Height accounting for margins\n\t\ty,\t\t\t// Current position in page\n\t\tytop, yend, ybottom,\t// Top/end-of-image/bottom lines in page\n\t\txc,\t\t\t// X count\n\t\tx1mm, y1mm,\t\t// Number of columns/rows per pixel (nominally 1mm)\n\t\txleft,\t\t\t// Start for line\n\t\tpw, ph;\t\t\t// Image width and height\n  const char\t**pixels,\t\t// Output image pixels\n\t\t*pixel;\t\t\t// Current output pixel\n  bool\t\tret = false;\t\t// Return value\n  static const char *portrait[] =\t// Portrait label image\n  {\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \",\n    \"   ..     ...   \",\n    \"  .SS.   .SSS.  \",\n    \" .SS.   .SSSSS. \",\n    \" .SS.  .SS..SS. \",\n    \".SS.   .SS. .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS. .SS.   .SS.\",\n    \" .SS..SS.  .SS. \",\n    \" .SSSSS.   .SS. \",\n    \"  .SSS.   .SS.  \",\n    \"   ...     ..   \",\n    \"....        ....\",\n    \".EEE.      .EEE.\",\n    \".EE.  ....  .EE.\",\n    \".EE. .EEEE. .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE....EE....EE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \"................\",\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \"\n  };\n  static const char *landscape[] =\t// Landscape label image\n  {\n    \"........................    ....    ............\",\n    \".TTTTTTTTTT..EEEEEEEEEE.  ..SSSS..  .TTTTTTTTTT.\",\n    \".TTTTTTTTTT..EEEEEEEEEE. .SSSSSSSS. .TTTTTTTTTT.\",\n    \".T...TT...T..EE.......E..SSS....SSS..T...TT...T.\",\n    \" .  .TT.  . .EE.      . .SS.    ..S. .  .TT.  . \",\n    \"    .TT.    .EE.    .   .SS..     .     .TT.    \",\n    \"    .TT.    .EE.....E.   .SSS..         .TT.    \",\n    \"    .TT.    .EEEEEEEE.    .SSSS..       .TT.    \",\n    \"    .TT.    .EEEEEEEE.     ..SSSS.      .TT.    \",\n    \"    .TT.    .EE.....E.       ..SSS.     .TT.    \",\n    \"    .TT.    .EE.    .    .     ..SS.    .TT.    \",\n    \"    .TT.    .EE.      . .S.     .SS.    .TT.    \",\n    \"    .TT.    .EE.......E..SSS....SSS.    .TT.    \",\n    \"    .TT.    .EEEEEEEEEE. .SSSSSSSS.     .TT.    \",\n    \"   .TTTT.   .EEEEEEEEEE.  ..SSSS..     .TTTT.   \",\n    \"   ......   ............    ....       ......   \"\n  };\n\n\n  (void)cbdata;\n\n  // Validate options and allocate a line buffer...\n  if (!options)\n    goto done;\n\n  if ((line = malloc(options->header.cupsBytesPerLine)) == NULL)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate %u bytes for test page: %s\", options->header.cupsBytesPerLine, strerror(errno));\n    goto done;\n  }\n\n  width  = options->header.HWResolution[0] * (options->media.size_width - options->media.left_margin - options->media.right_margin) / 2540;\n  height = options->header.HWResolution[1] * (options->media.size_length - options->media.bottom_margin - options->media.top_margin) / 2540;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"Printable area for test page is %ux%u pixels.\", width, height);\n\n  if (width > height)\n  {\n    // Send landscape raster...\n    pixels = landscape;\n    pw     = 48;\n    ph     = 16;\n  }\n  else\n  {\n    // Send portrait raster...\n    pixels = portrait;\n    pw     = 16;\n    ph     = 48;\n  }\n\n  y1mm = 10 * options->header.HWResolution[1] / 254;\n  if ((y1mm * ph) > height)\n  {\n    if ((y1mm = height / ph) == 0)\n      y1mm = 1;\n  }\n\n  if ((x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1]) == 0)\n  {\n    x1mm = 1;\n    y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0];\n  }\n\n  if ((pw * x1mm) > width)\n  {\n    // Too wide, try scaling to fit the width...\n    x1mm = 10 * options->header.HWResolution[0] / 254;\n    if ((x1mm * pw) > width)\n      x1mm = width / pw;\n\n    if ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n  }\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, x1mm=%u, y1mm=%u\", pw, ph, x1mm, y1mm);\n\n  if (((pw + 2) * x1mm) > options->header.cupsWidth || ((ph + 2) * y1mm) > options->header.cupsHeight)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Label too small to print test page.\");\n    goto done;\n  }\n\n  pw *= x1mm;\n  ph *= y1mm;\n\n  xleft   = (width - pw) / 2 - x1mm + options->header.HWResolution[0] * options->media.left_margin / 2540;\n  ytop    = (height - ph) / 2 + options->header.HWResolution[1] * options->media.top_margin / 2540;\n  yend    = ytop + ph;\n  ybottom = options->header.cupsHeight - y1mm;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, ytop=%u, yend=%u, ybottom=%u\", pw, ph, ytop, yend, ybottom);\n\n  // Start the page...\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  papplJobSetImpressions(job, 1);\n\n  if (!(data.rstartjob_cb)(job, options, device))\n    goto done;\n\n  if (!(data.rstartpage_cb)(job, options, device, 1))\n    goto done;\n\n  // Send lines for the test label:\n  //\n  // +---------------+\n  // |...............|\n  // |...         ...|\n  // |... T E S T ...|\n  // |...         ...|\n  // |...............|\n  // +---------------+\n\n  // Top border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (y = 0; y < y1mm; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on upper half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ytop; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders, gray shading, and image pixels in middle\n  for (; y < yend; y ++)\n  {\n    // Draw a 50% gray pattern with black borders...\n    memset(line, 0, x1mm);\n    memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n    memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n    // Render the interior text...\n    for (pixel = pixels[(y - ytop) / y1mm], lineptr = line + xleft; *pixel; pixel ++)\n    {\n      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on lower half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ybottom; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Bottom border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (; y < options->header.cupsHeight; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Finish up...\n  if (!(data.rendpage_cb)(job, options, device, 1))\n    goto done;\n\n  if (!(data.rendjob_cb)(job, options, device))\n    goto done;\n\n  ret = true;\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  done:\n\n  free(line);\n  papplJobDeletePrintOptions(options);\n\n  return (ret);\n}\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 22,
    "end_line": 288,
    "code": "  pappl_pr_driver_data_t data;\t\t// Printer driver data\n  pappl_pr_options_t\t*options = papplJobCreatePrintOptions(job, 1, false);\n\t\t\t\t\t// Print options\n  unsigned char\t*line = NULL,\t\t// Output line\n\t\t*lineptr;\t\t// Pointer into line\n  unsigned\twidth,\t\t\t// Width accounting for margins\n\t\theight,\t\t\t// Height accounting for margins\n\t\ty,\t\t\t// Current position in page\n\t\tytop, yend, ybottom,\t// Top/end-of-image/bottom lines in page\n\t\txc,\t\t\t// X count\n\t\tx1mm, y1mm,\t\t// Number of columns/rows per pixel (nominally 1mm)\n\t\txleft,\t\t\t// Start for line\n\t\tpw, ph;\t\t\t// Image width and height\n  const char\t**pixels,\t\t// Output image pixels\n\t\t*pixel;\t\t\t// Current output pixel\n  bool\t\tret = false;\t\t// Return value\n  static const char *portrait[] =\t// Portrait label image\n  {\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \",\n    \"   ..     ...   \",\n    \"  .SS.   .SSS.  \",\n    \" .SS.   .SSSSS. \",\n    \" .SS.  .SS..SS. \",\n    \".SS.   .SS. .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS. .SS.   .SS.\",\n    \" .SS..SS.  .SS. \",\n    \" .SSSSS.   .SS. \",\n    \"  .SSS.   .SS.  \",\n    \"   ...     ..   \",\n    \"....        ....\",\n    \".EEE.      .EEE.\",\n    \".EE.  ....  .EE.\",\n    \".EE. .EEEE. .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE....EE....EE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \"................\",\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \"\n  };\n  static const char *landscape[] =\t// Landscape label image\n  {\n    \"........................    ....    ............\",\n    \".TTTTTTTTTT..EEEEEEEEEE.  ..SSSS..  .TTTTTTTTTT.\",\n    \".TTTTTTTTTT..EEEEEEEEEE. .SSSSSSSS. .TTTTTTTTTT.\",\n    \".T...TT...T..EE.......E..SSS....SSS..T...TT...T.\",\n    \" .  .TT.  . .EE.      . .SS.    ..S. .  .TT.  . \",\n    \"    .TT.    .EE.    .   .SS..     .     .TT.    \",\n    \"    .TT.    .EE.....E.   .SSS..         .TT.    \",\n    \"    .TT.    .EEEEEEEE.    .SSSS..       .TT.    \",\n    \"    .TT.    .EEEEEEEE.     ..SSSS.      .TT.    \",\n    \"    .TT.    .EE.....E.       ..SSS.     .TT.    \",\n    \"    .TT.    .EE.    .    .     ..SS.    .TT.    \",\n    \"    .TT.    .EE.      . .S.     .SS.    .TT.    \",\n    \"    .TT.    .EE.......E..SSS....SSS.    .TT.    \",\n    \"    .TT.    .EEEEEEEEEE. .SSSSSSSS.     .TT.    \",\n    \"   .TTTT.   .EEEEEEEEEE.  ..SSSS..     .TTTT.   \",\n    \"   ......   ............    ....       ......   \"\n  };\n\n\n  (void)cbdata;\n\n  // Validate options and allocate a line buffer...\n  if (!options)\n    goto done;\n\n  if ((line = malloc(options->header.cupsBytesPerLine)) == NULL)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate %u bytes for test page: %s\", options->header.cupsBytesPerLine, strerror(errno));\n    goto done;\n  }\n\n  width  = options->header.HWResolution[0] * (options->media.size_width - options->media.left_margin - options->media.right_margin) / 2540;\n  height = options->header.HWResolution[1] * (options->media.size_length - options->media.bottom_margin - options->media.top_margin) / 2540;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"Printable area for test page is %ux%u pixels.\", width, height);\n\n  if (width > height)\n  {\n    // Send landscape raster...\n    pixels = landscape;\n    pw     = 48;\n    ph     = 16;\n  }\n  else\n  {\n    // Send portrait raster...\n    pixels = portrait;\n    pw     = 16;\n    ph     = 48;\n  }\n\n  y1mm = 10 * options->header.HWResolution[1] / 254;\n  if ((y1mm * ph) > height)\n  {\n    if ((y1mm = height / ph) == 0)\n      y1mm = 1;\n  }\n\n  if ((x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1]) == 0)\n  {\n    x1mm = 1;\n    y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0];\n  }\n\n  if ((pw * x1mm) > width)\n  {\n    // Too wide, try scaling to fit the width...\n    x1mm = 10 * options->header.HWResolution[0] / 254;\n    if ((x1mm * pw) > width)\n      x1mm = width / pw;\n\n    if ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n  }\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, x1mm=%u, y1mm=%u\", pw, ph, x1mm, y1mm);\n\n  if (((pw + 2) * x1mm) > options->header.cupsWidth || ((ph + 2) * y1mm) > options->header.cupsHeight)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Label too small to print test page.\");\n    goto done;\n  }\n\n  pw *= x1mm;\n  ph *= y1mm;\n\n  xleft   = (width - pw) / 2 - x1mm + options->header.HWResolution[0] * options->media.left_margin / 2540;\n  ytop    = (height - ph) / 2 + options->header.HWResolution[1] * options->media.top_margin / 2540;\n  yend    = ytop + ph;\n  ybottom = options->header.cupsHeight - y1mm;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, ytop=%u, yend=%u, ybottom=%u\", pw, ph, ytop, yend, ybottom);\n\n  // Start the page...\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  papplJobSetImpressions(job, 1);\n\n  if (!(data.rstartjob_cb)(job, options, device))\n    goto done;\n\n  if (!(data.rstartpage_cb)(job, options, device, 1))\n    goto done;\n\n  // Send lines for the test label:\n  //\n  // +---------------+\n  // |...............|\n  // |...         ...|\n  // |... T E S T ...|\n  // |...         ...|\n  // |...............|\n  // +---------------+\n\n  // Top border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (y = 0; y < y1mm; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on upper half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ytop; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders, gray shading, and image pixels in middle\n  for (; y < yend; y ++)\n  {\n    // Draw a 50% gray pattern with black borders...\n    memset(line, 0, x1mm);\n    memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n    memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n    // Render the interior text...\n    for (pixel = pixels[(y - ytop) / y1mm], lineptr = line + xleft; *pixel; pixel ++)\n    {\n      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on lower half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ybottom; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Bottom border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (; y < options->header.cupsHeight; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Finish up...\n  if (!(data.rendpage_cb)(job, options, device, 1))\n    goto done;\n\n  if (!(data.rendjob_cb)(job, options, device))\n    goto done;\n\n  ret = true;\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  done:\n\n  free(line);\n  papplJobDeletePrintOptions(options);\n\n  return (ret);\n}\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 22,
    "end_line": 288,
    "code": "  pappl_pr_driver_data_t data;\t\t// Printer driver data\n  pappl_pr_options_t\t*options = papplJobCreatePrintOptions(job, 1, false);\n\t\t\t\t\t// Print options\n  unsigned char\t*line = NULL,\t\t// Output line\n\t\t*lineptr;\t\t// Pointer into line\n  unsigned\twidth,\t\t\t// Width accounting for margins\n\t\theight,\t\t\t// Height accounting for margins\n\t\ty,\t\t\t// Current position in page\n\t\tytop, yend, ybottom,\t// Top/end-of-image/bottom lines in page\n\t\txc,\t\t\t// X count\n\t\tx1mm, y1mm,\t\t// Number of columns/rows per pixel (nominally 1mm)\n\t\txleft,\t\t\t// Start for line\n\t\tpw, ph;\t\t\t// Image width and height\n  const char\t**pixels,\t\t// Output image pixels\n\t\t*pixel;\t\t\t// Current output pixel\n  bool\t\tret = false;\t\t// Return value\n  static const char *portrait[] =\t// Portrait label image\n  {\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \",\n    \"   ..     ...   \",\n    \"  .SS.   .SSS.  \",\n    \" .SS.   .SSSSS. \",\n    \" .SS.  .SS..SS. \",\n    \".SS.   .SS. .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS. .SS.   .SS.\",\n    \" .SS..SS.  .SS. \",\n    \" .SSSSS.   .SS. \",\n    \"  .SSS.   .SS.  \",\n    \"   ...     ..   \",\n    \"....        ....\",\n    \".EEE.      .EEE.\",\n    \".EE.  ....  .EE.\",\n    \".EE. .EEEE. .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE....EE....EE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \"................\",\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \"\n  };\n  static const char *landscape[] =\t// Landscape label image\n  {\n    \"........................    ....    ............\",\n    \".TTTTTTTTTT..EEEEEEEEEE.  ..SSSS..  .TTTTTTTTTT.\",\n    \".TTTTTTTTTT..EEEEEEEEEE. .SSSSSSSS. .TTTTTTTTTT.\",\n    \".T...TT...T..EE.......E..SSS....SSS..T...TT...T.\",\n    \" .  .TT.  . .EE.      . .SS.    ..S. .  .TT.  . \",\n    \"    .TT.    .EE.    .   .SS..     .     .TT.    \",\n    \"    .TT.    .EE.....E.   .SSS..         .TT.    \",\n    \"    .TT.    .EEEEEEEE.    .SSSS..       .TT.    \",\n    \"    .TT.    .EEEEEEEE.     ..SSSS.      .TT.    \",\n    \"    .TT.    .EE.....E.       ..SSS.     .TT.    \",\n    \"    .TT.    .EE.    .    .     ..SS.    .TT.    \",\n    \"    .TT.    .EE.      . .S.     .SS.    .TT.    \",\n    \"    .TT.    .EE.......E..SSS....SSS.    .TT.    \",\n    \"    .TT.    .EEEEEEEEEE. .SSSSSSSS.     .TT.    \",\n    \"   .TTTT.   .EEEEEEEEEE.  ..SSSS..     .TTTT.   \",\n    \"   ......   ............    ....       ......   \"\n  };\n\n\n  (void)cbdata;\n\n  // Validate options and allocate a line buffer...\n  if (!options)\n    goto done;\n\n  if ((line = malloc(options->header.cupsBytesPerLine)) == NULL)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate %u bytes for test page: %s\", options->header.cupsBytesPerLine, strerror(errno));\n    goto done;\n  }\n\n  width  = options->header.HWResolution[0] * (options->media.size_width - options->media.left_margin - options->media.right_margin) / 2540;\n  height = options->header.HWResolution[1] * (options->media.size_length - options->media.bottom_margin - options->media.top_margin) / 2540;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"Printable area for test page is %ux%u pixels.\", width, height);\n\n  if (width > height)\n  {\n    // Send landscape raster...\n    pixels = landscape;\n    pw     = 48;\n    ph     = 16;\n  }\n  else\n  {\n    // Send portrait raster...\n    pixels = portrait;\n    pw     = 16;\n    ph     = 48;\n  }\n\n  y1mm = 10 * options->header.HWResolution[1] / 254;\n  if ((y1mm * ph) > height)\n  {\n    if ((y1mm = height / ph) == 0)\n      y1mm = 1;\n  }\n\n  if ((x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1]) == 0)\n  {\n    x1mm = 1;\n    y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0];\n  }\n\n  if ((pw * x1mm) > width)\n  {\n    // Too wide, try scaling to fit the width...\n    x1mm = 10 * options->header.HWResolution[0] / 254;\n    if ((x1mm * pw) > width)\n      x1mm = width / pw;\n\n    if ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n  }\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, x1mm=%u, y1mm=%u\", pw, ph, x1mm, y1mm);\n\n  if (((pw + 2) * x1mm) > options->header.cupsWidth || ((ph + 2) * y1mm) > options->header.cupsHeight)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Label too small to print test page.\");\n    goto done;\n  }\n\n  pw *= x1mm;\n  ph *= y1mm;\n\n  xleft   = (width - pw) / 2 - x1mm + options->header.HWResolution[0] * options->media.left_margin / 2540;\n  ytop    = (height - ph) / 2 + options->header.HWResolution[1] * options->media.top_margin / 2540;\n  yend    = ytop + ph;\n  ybottom = options->header.cupsHeight - y1mm;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, ytop=%u, yend=%u, ybottom=%u\", pw, ph, ytop, yend, ybottom);\n\n  // Start the page...\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  papplJobSetImpressions(job, 1);\n\n  if (!(data.rstartjob_cb)(job, options, device))\n    goto done;\n\n  if (!(data.rstartpage_cb)(job, options, device, 1))\n    goto done;\n\n  // Send lines for the test label:\n  //\n  // +---------------+\n  // |...............|\n  // |...         ...|\n  // |... T E S T ...|\n  // |...         ...|\n  // |...............|\n  // +---------------+\n\n  // Top border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (y = 0; y < y1mm; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on upper half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ytop; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders, gray shading, and image pixels in middle\n  for (; y < yend; y ++)\n  {\n    // Draw a 50% gray pattern with black borders...\n    memset(line, 0, x1mm);\n    memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n    memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n    // Render the interior text...\n    for (pixel = pixels[(y - ytop) / y1mm], lineptr = line + xleft; *pixel; pixel ++)\n    {\n      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on lower half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ybottom; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Bottom border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (; y < options->header.cupsHeight; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Finish up...\n  if (!(data.rendpage_cb)(job, options, device, 1))\n    goto done;\n\n  if (!(data.rendjob_cb)(job, options, device))\n    goto done;\n\n  ret = true;\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  done:\n\n  free(line);\n  papplJobDeletePrintOptions(options);\n\n  return (ret);\n}\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 22,
    "end_line": 288,
    "code": "  pappl_pr_driver_data_t data;\t\t// Printer driver data\n  pappl_pr_options_t\t*options = papplJobCreatePrintOptions(job, 1, false);\n\t\t\t\t\t// Print options\n  unsigned char\t*line = NULL,\t\t// Output line\n\t\t*lineptr;\t\t// Pointer into line\n  unsigned\twidth,\t\t\t// Width accounting for margins\n\t\theight,\t\t\t// Height accounting for margins\n\t\ty,\t\t\t// Current position in page\n\t\tytop, yend, ybottom,\t// Top/end-of-image/bottom lines in page\n\t\txc,\t\t\t// X count\n\t\tx1mm, y1mm,\t\t// Number of columns/rows per pixel (nominally 1mm)\n\t\txleft,\t\t\t// Start for line\n\t\tpw, ph;\t\t\t// Image width and height\n  const char\t**pixels,\t\t// Output image pixels\n\t\t*pixel;\t\t\t// Current output pixel\n  bool\t\tret = false;\t\t// Return value\n  static const char *portrait[] =\t// Portrait label image\n  {\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \",\n    \"   ..     ...   \",\n    \"  .SS.   .SSS.  \",\n    \" .SS.   .SSSSS. \",\n    \" .SS.  .SS..SS. \",\n    \".SS.   .SS. .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS. .SS.   .SS.\",\n    \" .SS..SS.  .SS. \",\n    \" .SSSSS.   .SS. \",\n    \"  .SSS.   .SS.  \",\n    \"   ...     ..   \",\n    \"....        ....\",\n    \".EEE.      .EEE.\",\n    \".EE.  ....  .EE.\",\n    \".EE. .EEEE. .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE....EE....EE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \"................\",\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \"\n  };\n  static const char *landscape[] =\t// Landscape label image\n  {\n    \"........................    ....    ............\",\n    \".TTTTTTTTTT..EEEEEEEEEE.  ..SSSS..  .TTTTTTTTTT.\",\n    \".TTTTTTTTTT..EEEEEEEEEE. .SSSSSSSS. .TTTTTTTTTT.\",\n    \".T...TT...T..EE.......E..SSS....SSS..T...TT...T.\",\n    \" .  .TT.  . .EE.      . .SS.    ..S. .  .TT.  . \",\n    \"    .TT.    .EE.    .   .SS..     .     .TT.    \",\n    \"    .TT.    .EE.....E.   .SSS..         .TT.    \",\n    \"    .TT.    .EEEEEEEE.    .SSSS..       .TT.    \",\n    \"    .TT.    .EEEEEEEE.     ..SSSS.      .TT.    \",\n    \"    .TT.    .EE.....E.       ..SSS.     .TT.    \",\n    \"    .TT.    .EE.    .    .     ..SS.    .TT.    \",\n    \"    .TT.    .EE.      . .S.     .SS.    .TT.    \",\n    \"    .TT.    .EE.......E..SSS....SSS.    .TT.    \",\n    \"    .TT.    .EEEEEEEEEE. .SSSSSSSS.     .TT.    \",\n    \"   .TTTT.   .EEEEEEEEEE.  ..SSSS..     .TTTT.   \",\n    \"   ......   ............    ....       ......   \"\n  };\n\n\n  (void)cbdata;\n\n  // Validate options and allocate a line buffer...\n  if (!options)\n    goto done;\n\n  if ((line = malloc(options->header.cupsBytesPerLine)) == NULL)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate %u bytes for test page: %s\", options->header.cupsBytesPerLine, strerror(errno));\n    goto done;\n  }\n\n  width  = options->header.HWResolution[0] * (options->media.size_width - options->media.left_margin - options->media.right_margin) / 2540;\n  height = options->header.HWResolution[1] * (options->media.size_length - options->media.bottom_margin - options->media.top_margin) / 2540;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"Printable area for test page is %ux%u pixels.\", width, height);\n\n  if (width > height)\n  {\n    // Send landscape raster...\n    pixels = landscape;\n    pw     = 48;\n    ph     = 16;\n  }\n  else\n  {\n    // Send portrait raster...\n    pixels = portrait;\n    pw     = 16;\n    ph     = 48;\n  }\n\n  y1mm = 10 * options->header.HWResolution[1] / 254;\n  if ((y1mm * ph) > height)\n  {\n    if ((y1mm = height / ph) == 0)\n      y1mm = 1;\n  }\n\n  if ((x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1]) == 0)\n  {\n    x1mm = 1;\n    y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0];\n  }\n\n  if ((pw * x1mm) > width)\n  {\n    // Too wide, try scaling to fit the width...\n    x1mm = 10 * options->header.HWResolution[0] / 254;\n    if ((x1mm * pw) > width)\n      x1mm = width / pw;\n\n    if ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n  }\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, x1mm=%u, y1mm=%u\", pw, ph, x1mm, y1mm);\n\n  if (((pw + 2) * x1mm) > options->header.cupsWidth || ((ph + 2) * y1mm) > options->header.cupsHeight)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Label too small to print test page.\");\n    goto done;\n  }\n\n  pw *= x1mm;\n  ph *= y1mm;\n\n  xleft   = (width - pw) / 2 - x1mm + options->header.HWResolution[0] * options->media.left_margin / 2540;\n  ytop    = (height - ph) / 2 + options->header.HWResolution[1] * options->media.top_margin / 2540;\n  yend    = ytop + ph;\n  ybottom = options->header.cupsHeight - y1mm;\n\n  papplLogJob(job, PAPPL_LOGLEVEL_DEBUG, \"pw=%u, ph=%u, ytop=%u, yend=%u, ybottom=%u\", pw, ph, ytop, yend, ybottom);\n\n  // Start the page...\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  papplJobSetImpressions(job, 1);\n\n  if (!(data.rstartjob_cb)(job, options, device))\n    goto done;\n\n  if (!(data.rstartpage_cb)(job, options, device, 1))\n    goto done;\n\n  // Send lines for the test label:\n  //\n  // +---------------+\n  // |...............|\n  // |...         ...|\n  // |... T E S T ...|\n  // |...         ...|\n  // |...............|\n  // +---------------+\n\n  // Top border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (y = 0; y < y1mm; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on upper half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ytop; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders, gray shading, and image pixels in middle\n  for (; y < yend; y ++)\n  {\n    // Draw a 50% gray pattern with black borders...\n    memset(line, 0, x1mm);\n    memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n    memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n    // Render the interior text...\n    for (pixel = pixels[(y - ytop) / y1mm], lineptr = line + xleft; *pixel; pixel ++)\n    {\n      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Side borders and gray shading on lower half\n  memset(line, 0, x1mm);\n  memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n  memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n  for (; y < ybottom; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Bottom border\n  memset(line, 0, options->header.cupsBytesPerLine);\n  for (; y < options->header.cupsHeight; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n  // Finish up...\n  if (!(data.rendpage_cb)(job, options, device, 1))\n    goto done;\n\n  if (!(data.rendjob_cb)(job, options, device))\n    goto done;\n\n  ret = true;\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  done:\n\n  free(line);\n  papplJobDeletePrintOptions(options);\n\n  return (ret);\n}\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "global_variable",
    "start_line": 24,
    "end_line": 24,
    "code": "ppl_pr_options_t\t*options = papplJobCreatePrintOptions(job, 1, false);\n\t",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "global_variable",
    "start_line": 26,
    "end_line": 27,
    "code": "signed char\t*line = NULL,\t\t// Output line\n\t\t*lineptr;\t\t",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "global_variable",
    "start_line": 38,
    "end_line": 38,
    "code": "ol\t\tret = false;\t\t",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "global_variable",
    "start_line": 39,
    "end_line": 89,
    "code": "atic const char *portrait[] =\t// Portrait label image\n  {\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \",\n    \"   ..     ...   \",\n    \"  .SS.   .SSS.  \",\n    \" .SS.   .SSSSS. \",\n    \" .SS.  .SS..SS. \",\n    \".SS.   .SS. .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS. .SS.   .SS.\",\n    \" .SS..SS.  .SS. \",\n    \" .SSSSS.   .SS. \",\n    \"  .SSS.   .SS.  \",\n    \"   ...     ..   \",\n    \"....        ....\",\n    \".EEE.      .EEE.\",\n    \".EE.  ....  .EE.\",\n    \".EE. .EEEE. .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE....EE....EE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \"................\",\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \"\n  };\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 39,
    "end_line": 89,
    "code": "atic const char *portrait[] =\t// Portrait label image\n  {\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \",\n    \"   ..     ...   \",\n    \"  .SS.   .SSS.  \",\n    \" .SS.   .SSSSS. \",\n    \" .SS.  .SS..SS. \",\n    \".SS.   .SS. .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS. .SS.   .SS.\",\n    \" .SS..SS.  .SS. \",\n    \" .SSSSS.   .SS. \",\n    \"  .SSS.   .SS.  \",\n    \"   ...     ..   \",\n    \"....        ....\",\n    \".EEE.      .EEE.\",\n    \".EE.  ....  .EE.\",\n    \".EE. .EEEE. .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE....EE....EE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \"................\",\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \"\n  };\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 39,
    "end_line": 89,
    "code": "ortrait[] =\t// Portrait label image\n  {\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \",\n    \"   ..     ...   \",\n    \"  .SS.   .SSS.  \",\n    \" .SS.   .SSSSS. \",\n    \" .SS.  .SS..SS. \",\n    \".SS.   .SS. .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS.  .SS.  .SS.\",\n    \".SS. .SS.   .SS.\",\n    \" .SS..SS.  .SS. \",\n    \" .SSSSS.   .SS. \",\n    \"  .SSS.   .SS.  \",\n    \"   ...     ..   \",\n    \"....        ....\",\n    \".EEE.      .EEE.\",\n    \".EE.  ....  .EE.\",\n    \".EE. .EEEE. .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE.  .EE.  .EE.\",\n    \".EE....EE....EE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \".EEEEEEEEEEEEEE.\",\n    \"................\",\n    \"....            \",\n    \".TTT.           \",\n    \".TT.            \",\n    \".TT.          ..\",\n    \".TT...........T.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TTTTTTTTTTTTTT.\",\n    \".TT...........T.\",\n    \".TT.          ..\",\n    \".TT.            \",\n    \".TTT.           \",\n    \"....            \"\n  };\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "global_variable",
    "start_line": 90,
    "end_line": 108,
    "code": "atic const char *landscape[] =\t// Landscape label image\n  {\n    \"........................    ....    ............\",\n    \".TTTTTTTTTT..EEEEEEEEEE.  ..SSSS..  .TTTTTTTTTT.\",\n    \".TTTTTTTTTT..EEEEEEEEEE. .SSSSSSSS. .TTTTTTTTTT.\",\n    \".T...TT...T..EE.......E..SSS....SSS..T...TT...T.\",\n    \" .  .TT.  . .EE.      . .SS.    ..S. .  .TT.  . \",\n    \"    .TT.    .EE.    .   .SS..     .     .TT.    \",\n    \"    .TT.    .EE.....E.   .SSS..         .TT.    \",\n    \"    .TT.    .EEEEEEEE.    .SSSS..       .TT.    \",\n    \"    .TT.    .EEEEEEEE.     ..SSSS.      .TT.    \",\n    \"    .TT.    .EE.....E.       ..SSS.     .TT.    \",\n    \"    .TT.    .EE.    .    .     ..SS.    .TT.    \",\n    \"    .TT.    .EE.      . .S.     .SS.    .TT.    \",\n    \"    .TT.    .EE.......E..SSS....SSS.    .TT.    \",\n    \"    .TT.    .EEEEEEEEEE. .SSSSSSSS.     .TT.    \",\n    \"   .TTTT.   .EEEEEEEEEE.  ..SSSS..     .TTTT.   \",\n    \"   ......   ............    ....       ......   \"\n  };\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 90,
    "end_line": 108,
    "code": "atic const char *landscape[] =\t// Landscape label image\n  {\n    \"........................    ....    ............\",\n    \".TTTTTTTTTT..EEEEEEEEEE.  ..SSSS..  .TTTTTTTTTT.\",\n    \".TTTTTTTTTT..EEEEEEEEEE. .SSSSSSSS. .TTTTTTTTTT.\",\n    \".T...TT...T..EE.......E..SSS....SSS..T...TT...T.\",\n    \" .  .TT.  . .EE.      . .SS.    ..S. .  .TT.  . \",\n    \"    .TT.    .EE.    .   .SS..     .     .TT.    \",\n    \"    .TT.    .EE.....E.   .SSS..         .TT.    \",\n    \"    .TT.    .EEEEEEEE.    .SSSS..       .TT.    \",\n    \"    .TT.    .EEEEEEEE.     ..SSSS.      .TT.    \",\n    \"    .TT.    .EE.....E.       ..SSS.     .TT.    \",\n    \"    .TT.    .EE.    .    .     ..SS.    .TT.    \",\n    \"    .TT.    .EE.      . .S.     .SS.    .TT.    \",\n    \"    .TT.    .EE.......E..SSS....SSS.    .TT.    \",\n    \"    .TT.    .EEEEEEEEEE. .SSSSSSSS.     .TT.    \",\n    \"   .TTTT.   .EEEEEEEEEE.  ..SSSS..     .TTTT.   \",\n    \"   ......   ............    ....       ......   \"\n  };\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 90,
    "end_line": 108,
    "code": "andscape[] =\t// Landscape label image\n  {\n    \"........................    ....    ............\",\n    \".TTTTTTTTTT..EEEEEEEEEE.  ..SSSS..  .TTTTTTTTTT.\",\n    \".TTTTTTTTTT..EEEEEEEEEE. .SSSSSSSS. .TTTTTTTTTT.\",\n    \".T...TT...T..EE.......E..SSS....SSS..T...TT...T.\",\n    \" .  .TT.  . .EE.      . .SS.    ..S. .  .TT.  . \",\n    \"    .TT.    .EE.    .   .SS..     .     .TT.    \",\n    \"    .TT.    .EE.....E.   .SSS..         .TT.    \",\n    \"    .TT.    .EEEEEEEE.    .SSSS..       .TT.    \",\n    \"    .TT.    .EEEEEEEE.     ..SSSS.      .TT.    \",\n    \"    .TT.    .EE.....E.       ..SSS.     .TT.    \",\n    \"    .TT.    .EE.    .    .     ..SS.    .TT.    \",\n    \"    .TT.    .EE.      . .S.     .SS.    .TT.    \",\n    \"    .TT.    .EE.......E..SSS....SSS.    .TT.    \",\n    \"    .TT.    .EEEEEEEEEE. .SSSSSSSS.     .TT.    \",\n    \"   .TTTT.   .EEEEEEEEEE.  ..SSSS..     .TTTT.   \",\n    \"   ......   ............    ....       ......   \"\n  };\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 117,
    "end_line": 121,
    "code": " ((line = malloc(options->header.cupsBytesPerLine)) == NULL)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate %u bytes for test page: %s\", options->header.cupsBytesPerLine, strerror(errno));\n    goto done;\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 117,
    "end_line": 121,
    "code": " ((line = malloc(options->header.cupsBytesPerLine)) == NULL)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate %u bytes for test page: %s\", options->header.cupsBytesPerLine, strerror(errno));\n    goto done;\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 117,
    "end_line": 117,
    "code": "line = malloc(options->header.cupsBytesPerLine)) == NULL)\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 117,
    "end_line": 117,
    "code": "ine = malloc(options->header.cupsBytesPerLine)) == NULL)\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 117,
    "end_line": 117,
    "code": "ine = malloc(options->header.cupsBytesPerLine)) =",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 117,
    "end_line": 117,
    "code": "ne = malloc(options->header.cupsBytesPerLine)) ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 123,
    "end_line": 123,
    "code": "dth  = options->header.HWResolution[0] * (options->media.size_width - options->media.left_margin - options->media.right_margin) / 2540;\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 123,
    "end_line": 123,
    "code": "dth  = options->header.HWResolution[0] * (options->media.size_width - options->media.left_margin - options->media.right_margin) / 2540;\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 123,
    "end_line": 123,
    "code": "dth  = options->header.HWResolution[0] * (options->media.size_width - options->media.left_margin - options->media.right_margin) / 2540;\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 123,
    "end_line": 123,
    "code": "dth  = options->header.HWResolution[0] * (options->media.size_width - options->media.left_margin - options->media.right_margin) / 2540;\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 124,
    "end_line": 124,
    "code": "ight = options->header.HWResolution[1] * (options->media.size_length - options->media.bottom_margin - options->media.top_margin) / 2540;\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 124,
    "end_line": 124,
    "code": "ight = options->header.HWResolution[1] * (options->media.size_length - options->media.bottom_margin - options->media.top_margin) / 2540;\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 124,
    "end_line": 124,
    "code": "ight = options->header.HWResolution[1] * (options->media.size_length - options->media.bottom_margin - options->media.top_margin) / 2540;\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 124,
    "end_line": 124,
    "code": "ight = options->header.HWResolution[1] * (options->media.size_length - options->media.bottom_margin - options->media.top_margin) / 2540;\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 128,
    "end_line": 141,
    "code": " (width > height)\n  {\n    // Send landscape raster...\n    pixels = landscape;\n    pw     = 48;\n    ph     = 16;\n  }\n  else\n  {\n    // Send portrait raster...\n    pixels = portrait;\n    pw     = 16;\n    ph     = 48;\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 129,
    "end_line": 134,
    "code": "    // Send landscape raster...\n    pixels = landscape;\n    pw     = 48;\n    ph     = 16;\n  }\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 135,
    "end_line": 141,
    "code": "se\n  {\n    // Send portrait raster...\n    pixels = portrait;\n    pw     = 16;\n    ph     = 48;\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 136,
    "end_line": 141,
    "code": "    // Send portrait raster...\n    pixels = portrait;\n    pw     = 16;\n    ph     = 48;\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 143,
    "end_line": 143,
    "code": "mm = 10 * options->header.HWResolution[1] / 254;\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 143,
    "end_line": 143,
    "code": "mm = 10 * options->header.HWResolution[1] / 254;\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 150,
    "end_line": 154,
    "code": " ((x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1]) == 0)\n  {\n    x1mm = 1;\n    y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0];\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 150,
    "end_line": 154,
    "code": " ((x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1]) == 0)\n  {\n    x1mm = 1;\n    y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0];\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 151,
    "end_line": 154,
    "code": "    x1mm = 1;\n    y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0];\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 153,
    "end_line": 153,
    "code": "mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0];\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 153,
    "end_line": 153,
    "code": "mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0];\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 156,
    "end_line": 168,
    "code": " ((pw * x1mm) > width)\n  {\n    // Too wide, try scaling to fit the width...\n    x1mm = 10 * options->header.HWResolution[0] / 254;\n    if ((x1mm * pw) > width)\n      x1mm = width / pw;\n\n    if ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 156,
    "end_line": 168,
    "code": " ((pw * x1mm) > width)\n  {\n    // Too wide, try scaling to fit the width...\n    x1mm = 10 * options->header.HWResolution[0] / 254;\n    if ((x1mm * pw) > width)\n      x1mm = width / pw;\n\n    if ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 157,
    "end_line": 168,
    "code": "    // Too wide, try scaling to fit the width...\n    x1mm = 10 * options->header.HWResolution[0] / 254;\n    if ((x1mm * pw) > width)\n      x1mm = width / pw;\n\n    if ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 157,
    "end_line": 168,
    "code": "    // Too wide, try scaling to fit the width...\n    x1mm = 10 * options->header.HWResolution[0] / 254;\n    if ((x1mm * pw) > width)\n      x1mm = width / pw;\n\n    if ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 159,
    "end_line": 159,
    "code": "mm = 10 * options->header.HWResolution[0] / 254;\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 159,
    "end_line": 159,
    "code": "mm = 10 * options->header.HWResolution[0] / 254;\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 163,
    "end_line": 167,
    "code": " ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 163,
    "end_line": 167,
    "code": " ((y1mm = x1mm * options->header.HWResolution[1] / options->header.HWResolution[0]) == 0)\n    {\n      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 164,
    "end_line": 167,
    "code": "      y1mm = 1;\n      x1mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n    }\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 166,
    "end_line": 166,
    "code": "mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 166,
    "end_line": 166,
    "code": "mm = y1mm * options->header.HWResolution[0] / options->header.HWResolution[1];\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 172,
    "end_line": 176,
    "code": " (((pw + 2) * x1mm) > options->header.cupsWidth || ((ph + 2) * y1mm) > options->header.cupsHeight)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Label too small to print test page.\");\n    goto done;\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 181,
    "end_line": 181,
    "code": "eft   = (width - pw) / 2 - x1mm + options->header.HWResolution[0] * options->media.left_margin / 2540;\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 181,
    "end_line": 181,
    "code": "eft   = (width - pw) / 2 - x1mm + options->header.HWResolution[0] * options->media.left_margin / 2540;\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 181,
    "end_line": 181,
    "code": "eft   = (width - pw) / 2 - x1mm + options->header.HWResolution[0] * options->media.left_margin / 2540;\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 181,
    "end_line": 181,
    "code": "eft   = (width - pw) / 2 - x1mm + options->header.HWResolution[0] * options->media.left_margin / 2540;\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 182,
    "end_line": 182,
    "code": "op    = (height - ph) / 2 + options->header.HWResolution[1] * options->media.top_margin / 2540;\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 182,
    "end_line": 182,
    "code": "op    = (height - ph) / 2 + options->header.HWResolution[1] * options->media.top_margin / 2540;\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 182,
    "end_line": 182,
    "code": "op    = (height - ph) / 2 + options->header.HWResolution[1] * options->media.top_margin / 2540;\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 182,
    "end_line": 182,
    "code": "op    = (height - ph) / 2 + options->header.HWResolution[1] * options->media.top_margin / 2540;\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 184,
    "end_line": 184,
    "code": "ottom = options->header.cupsHeight - y1mm;\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 184,
    "end_line": 184,
    "code": "ottom = options->header.cupsHeight - y1mm;\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 211,
    "end_line": 215,
    "code": "r (y = 0; y < y1mm; y ++)\n  {\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 229,
    "end_line": 250,
    "code": "r (; y < yend; y ++)\n  {\n    // Draw a 50% gray pattern with black borders...\n    memset(line, 0, x1mm);\n    memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n    memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n    // Render the interior text...\n    for (pixel = pixels[(y - ytop) / y1mm], lineptr = line + xleft; *pixel; pixel ++)\n    {\n      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 229,
    "end_line": 250,
    "code": "r (; y < yend; y ++)\n  {\n    // Draw a 50% gray pattern with black borders...\n    memset(line, 0, x1mm);\n    memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n    memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n    // Render the interior text...\n    for (pixel = pixels[(y - ytop) / y1mm], lineptr = line + xleft; *pixel; pixel ++)\n    {\n      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 230,
    "end_line": 250,
    "code": "    // Draw a 50% gray pattern with black borders...\n    memset(line, 0, x1mm);\n    memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n    memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n    // Render the interior text...\n    for (pixel = pixels[(y - ytop) / y1mm], lineptr = line + xleft; *pixel; pixel ++)\n    {\n      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function_assignment",
    "start_line": 230,
    "end_line": 250,
    "code": "    // Draw a 50% gray pattern with black borders...\n    memset(line, 0, x1mm);\n    memset(line + x1mm, 128, options->header.cupsBytesPerLine - 2 * x1mm);\n    memset(line + options->header.cupsBytesPerLine - x1mm, 0, x1mm);\n\n    // Render the interior text...\n    for (pixel = pixels[(y - ytop) / y1mm], lineptr = line + xleft; *pixel; pixel ++)\n    {\n      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n    if (!(data.rwriteline_cb)(job, options, device, y, line))\n      goto done;\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 237,
    "end_line": 246,
    "code": "r (pixel = pixels[(y - ytop) / y1mm], lineptr = line + xleft; *pixel; pixel ++)\n    {\n      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 238,
    "end_line": 246,
    "code": "      for (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n    }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 239,
    "end_line": 245,
    "code": "r (xc = x1mm; xc > 0; xc --, lineptr ++)\n      {\n        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 240,
    "end_line": 245,
    "code": "        if (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n      }\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 241,
    "end_line": 244,
    "code": " (*pixel == '.')\n\t  *lineptr = 255;\n        else if (!isspace(*pixel))\n\t  *lineptr = 0;\n ",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "function",
    "start_line": 295,
    "end_line": 322,
    "name": null,
    "parent": null,
    "hierarchy": null,
    "code": "nst char *\t\t\t\t// O - Test page file\nlprintTestPageCB(\n    pappl_printer_t *printer,\t\t// I - Printer\n    char            *buffer,\t\t// I - Filename buffer\n    size_t          bufsize)\t\t// I - Size of filename buffer\n{\n  int\tfd;\t\t\t\t// File descriptor\n  char\ttestpage[] = LPRINT_TESTPAGE_HEADER;\n\t\t\t\t\t// Test page file header\n\n\n  if ((fd = papplCreateTempFile(buffer, bufsize, \"testpage\", \"tst\")) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Unable to create temporary file for test page: %s\", strerror(errno));\n    return (NULL);\n  }\n\n  if (write(fd, testpage, sizeof(testpage)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Unable to write temporary file for test page: %s\", strerror(errno));\n    close(fd);\n    return (NULL);\n  }\n\n  close(fd);\n\n  return (buffer);\n}\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "global_variable",
    "start_line": 302,
    "end_line": 302,
    "code": "ar\ttestpage[] = LPRINT_TESTPAGE_HEADER;\n\t",
    "file": "data/codebase/lprint/lprint-testpage.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 312,
    "end_line": 317,
    "code": " (write(fd, testpage, sizeof(testpage)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Unable to write temporary file for test page: %s\", strerror(errno));\n    close(fd);\n    return (NULL);\n  }\n\n",
    "file": "data/codebase/lprint/lprint-testpage.c"
  }
]