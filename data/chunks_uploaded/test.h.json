[
  {
    "type": "struct_assignment",
    "start_line": 1,
    "end_line": 282,
    "code": "//\n// Unit test header for C/C++ programs.\n//\n// Copyright \u00a9 2021-2022 by Michael R Sweet.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n//    this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n//\n\n#ifndef TEST_H\n#  define TEST_H\n#  include <stdio.h>\n#  include <stdlib.h>\n#  include <stdarg.h>\n#  include <stdbool.h>\n#  include <string.h>\n#  if _WIN32\n#    define isatty(f) _isatty(f)\n#  else\n#    include <unistd.h>\n#  endif // !_WIN32\n#  ifdef __cplusplus\nextern \"C\" {\n#  endif // __cplusplus\n\n\n//\n// This header implements a simple unit test framework for C/C++ programs.\n// Inline functions are provided to write a test summary to stdout and the\n// details to stderr.  This allows unit test programs to output a summary to\n// stdout with details sent to stderr, e.g.:\n//\n//     mytestprogram 2>test.log\n//\n// Documentation:\n//\n// void testBegin(const char *title, ...)\n//\n//     Start a test with a printf-style title message.  \"Title:\" (the formatted\n//     title followed by a colon) is output.\n//\n// void testEnd(bool pass)\n//\n//     End a test without an additional message.  \"pass\" should be `true` if the\n//     test passed and `false` otherwise.  \"PASS\" or \"FAIL\" is output.\n//\n// void testEndMessage(bool pass, const char *message, ...)\n//\n//     End a test with an additional printf-style message.  \"pass\" should be\n//     `true` if the test passed and `false` otherwise.  \"PASS (message)\" or\n//     \"FAIL (message)\" is output.\n//\n// testError(const char *error, ...)\n//\n//     Sends a formatted error string to stderr.\n//\n// testHexDump(const unsigned char *buffer, size_t bytes)\n//\n//     Sends a hex dump of the specified buffer to stderr.\n//\n// testMessage(const char *error, ...)\n//\n//     Outputs a formatted message string.\n//\n// testProgress(void)\n//\n//     Shows a progress spinner for long-running tests.\n//\n// bool testsPassed\n//\n//     This global variable specifies whether all tests have passed (`true`)\n//     or one or more have failed (`false`).\n//\n\nstatic bool testsPassed = true;\t\t// All tests passed?\nstatic int test_progress;\t\t// Current progress\nstatic char test_title[1024] = \"\";\t// Current test title\n\n\n// Start a test\nstatic inline void\ntestBegin(const char *title, ...)\t// I - printf-style title string\n{\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, title);\n  vsnprintf(test_title, sizeof(test_title), title, ap);\n  va_end(ap);\n\n  // Send the title to stdout and stderr...\n  test_progress = 0;\n\n  printf(\"%s: \", test_title);\n  fflush(stdout);\n\n  if (!isatty(2))\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEnd(bool pass)\t\t\t// I - `true` if the test passed, `false` otherwise\n{\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  if (!pass)\n    testsPassed = false;\n\n  puts(pass ? \"PASS\" : \"FAIL\");\n  if (!isatty(2))\n    fputs(pass ? \"PASS\\n\" : \"FAIL\\n\", stderr);\n\n  test_title[0] = '\\0';\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEndMessage(bool       pass,\t\t// I - `true` if the test passed, `false` otherwise\n               const char *message, ...)// I - printf-style message\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, message);\n  vsnprintf(buffer, sizeof(buffer), message, ap);\n  va_end(ap);\n\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  printf(pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n  if (!isatty(2))\n    fprintf(stderr, pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n\n  test_title[0] = '\\0';\n}\n\n\n// Show/update a progress spinner\nstatic inline void\ntestProgress(void)\n{\n  if (test_progress)\n    putchar('\\b');\n  putchar(\"-\\\\|/\"[test_progress & 3]);\n  fflush(stdout);\n\n  test_progress ++;\n}\n\n\n// Show an error to stderr...\nstatic inline void\ntestError(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the error to stderr...\n  fprintf(stderr, \"%s\\n\", buffer);\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// Show a message to stdout and stderr...\nstatic inline void\ntestMessage(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the message to stdout and stderr too if needed...\n  printf(\"%s\\n\", buffer);\n  if (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n\n  if (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n}\n\n\n// Show a hex dump of a buffer to stderr...\nstatic inline void\ntestHexDump(const unsigned char *buffer,// I - Buffer\n            size_t              bytes)\t// I - Number of bytes\n{\n  size_t\ti, j;\t\t\t// Looping vars\n  int\t\tch;\t\t\t// Current ASCII char\n\n\n  if (test_title[0])\n    fputs(\"\\n\", stderr);\n\n  // Show lines of 16 bytes at a time...\n  for (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n#  ifdef __cplusplus\n}\n#  endif // __cplusplus\n#endif // !TEST_H\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 1,
    "end_line": 282,
    "code": "//\n// Unit test header for C/C++ programs.\n//\n// Copyright \u00a9 2021-2022 by Michael R Sweet.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n//    this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n//\n\n#ifndef TEST_H\n#  define TEST_H\n#  include <stdio.h>\n#  include <stdlib.h>\n#  include <stdarg.h>\n#  include <stdbool.h>\n#  include <string.h>\n#  if _WIN32\n#    define isatty(f) _isatty(f)\n#  else\n#    include <unistd.h>\n#  endif // !_WIN32\n#  ifdef __cplusplus\nextern \"C\" {\n#  endif // __cplusplus\n\n\n//\n// This header implements a simple unit test framework for C/C++ programs.\n// Inline functions are provided to write a test summary to stdout and the\n// details to stderr.  This allows unit test programs to output a summary to\n// stdout with details sent to stderr, e.g.:\n//\n//     mytestprogram 2>test.log\n//\n// Documentation:\n//\n// void testBegin(const char *title, ...)\n//\n//     Start a test with a printf-style title message.  \"Title:\" (the formatted\n//     title followed by a colon) is output.\n//\n// void testEnd(bool pass)\n//\n//     End a test without an additional message.  \"pass\" should be `true` if the\n//     test passed and `false` otherwise.  \"PASS\" or \"FAIL\" is output.\n//\n// void testEndMessage(bool pass, const char *message, ...)\n//\n//     End a test with an additional printf-style message.  \"pass\" should be\n//     `true` if the test passed and `false` otherwise.  \"PASS (message)\" or\n//     \"FAIL (message)\" is output.\n//\n// testError(const char *error, ...)\n//\n//     Sends a formatted error string to stderr.\n//\n// testHexDump(const unsigned char *buffer, size_t bytes)\n//\n//     Sends a hex dump of the specified buffer to stderr.\n//\n// testMessage(const char *error, ...)\n//\n//     Outputs a formatted message string.\n//\n// testProgress(void)\n//\n//     Shows a progress spinner for long-running tests.\n//\n// bool testsPassed\n//\n//     This global variable specifies whether all tests have passed (`true`)\n//     or one or more have failed (`false`).\n//\n\nstatic bool testsPassed = true;\t\t// All tests passed?\nstatic int test_progress;\t\t// Current progress\nstatic char test_title[1024] = \"\";\t// Current test title\n\n\n// Start a test\nstatic inline void\ntestBegin(const char *title, ...)\t// I - printf-style title string\n{\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, title);\n  vsnprintf(test_title, sizeof(test_title), title, ap);\n  va_end(ap);\n\n  // Send the title to stdout and stderr...\n  test_progress = 0;\n\n  printf(\"%s: \", test_title);\n  fflush(stdout);\n\n  if (!isatty(2))\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEnd(bool pass)\t\t\t// I - `true` if the test passed, `false` otherwise\n{\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  if (!pass)\n    testsPassed = false;\n\n  puts(pass ? \"PASS\" : \"FAIL\");\n  if (!isatty(2))\n    fputs(pass ? \"PASS\\n\" : \"FAIL\\n\", stderr);\n\n  test_title[0] = '\\0';\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEndMessage(bool       pass,\t\t// I - `true` if the test passed, `false` otherwise\n               const char *message, ...)// I - printf-style message\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, message);\n  vsnprintf(buffer, sizeof(buffer), message, ap);\n  va_end(ap);\n\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  printf(pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n  if (!isatty(2))\n    fprintf(stderr, pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n\n  test_title[0] = '\\0';\n}\n\n\n// Show/update a progress spinner\nstatic inline void\ntestProgress(void)\n{\n  if (test_progress)\n    putchar('\\b');\n  putchar(\"-\\\\|/\"[test_progress & 3]);\n  fflush(stdout);\n\n  test_progress ++;\n}\n\n\n// Show an error to stderr...\nstatic inline void\ntestError(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the error to stderr...\n  fprintf(stderr, \"%s\\n\", buffer);\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// Show a message to stdout and stderr...\nstatic inline void\ntestMessage(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the message to stdout and stderr too if needed...\n  printf(\"%s\\n\", buffer);\n  if (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n\n  if (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n}\n\n\n// Show a hex dump of a buffer to stderr...\nstatic inline void\ntestHexDump(const unsigned char *buffer,// I - Buffer\n            size_t              bytes)\t// I - Number of bytes\n{\n  size_t\ti, j;\t\t\t// Looping vars\n  int\t\tch;\t\t\t// Current ASCII char\n\n\n  if (test_title[0])\n    fputs(\"\\n\", stderr);\n\n  // Show lines of 16 bytes at a time...\n  for (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n#  ifdef __cplusplus\n}\n#  endif // __cplusplus\n#endif // !TEST_H\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "preprocessor",
    "start_line": 28,
    "end_line": 281,
    "code": "ifndef TEST_H\n#  define TEST_H\n#  include <stdio.h>\n#  include <stdlib.h>\n#  include <stdarg.h>\n#  include <stdbool.h>\n#  include <string.h>\n#  if _WIN32\n#    define isatty(f) _isatty(f)\n#  else\n#    include <unistd.h>\n#  endif // !_WIN32\n#  ifdef __cplusplus\nextern \"C\" {\n#  endif // __cplusplus\n\n\n//\n// This header implements a simple unit test framework for C/C++ programs.\n// Inline functions are provided to write a test summary to stdout and the\n// details to stderr.  This allows unit test programs to output a summary to\n// stdout with details sent to stderr, e.g.:\n//\n//     mytestprogram 2>test.log\n//\n// Documentation:\n//\n// void testBegin(const char *title, ...)\n//\n//     Start a test with a printf-style title message.  \"Title:\" (the formatted\n//     title followed by a colon) is output.\n//\n// void testEnd(bool pass)\n//\n//     End a test without an additional message.  \"pass\" should be `true` if the\n//     test passed and `false` otherwise.  \"PASS\" or \"FAIL\" is output.\n//\n// void testEndMessage(bool pass, const char *message, ...)\n//\n//     End a test with an additional printf-style message.  \"pass\" should be\n//     `true` if the test passed and `false` otherwise.  \"PASS (message)\" or\n//     \"FAIL (message)\" is output.\n//\n// testError(const char *error, ...)\n//\n//     Sends a formatted error string to stderr.\n//\n// testHexDump(const unsigned char *buffer, size_t bytes)\n//\n//     Sends a hex dump of the specified buffer to stderr.\n//\n// testMessage(const char *error, ...)\n//\n//     Outputs a formatted message string.\n//\n// testProgress(void)\n//\n//     Shows a progress spinner for long-running tests.\n//\n// bool testsPassed\n//\n//     This global variable specifies whether all tests have passed (`true`)\n//     or one or more have failed (`false`).\n//\n\nstatic bool testsPassed = true;\t\t// All tests passed?\nstatic int test_progress;\t\t// Current progress\nstatic char test_title[1024] = \"\";\t// Current test title\n\n\n// Start a test\nstatic inline void\ntestBegin(const char *title, ...)\t// I - printf-style title string\n{\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, title);\n  vsnprintf(test_title, sizeof(test_title), title, ap);\n  va_end(ap);\n\n  // Send the title to stdout and stderr...\n  test_progress = 0;\n\n  printf(\"%s: \", test_title);\n  fflush(stdout);\n\n  if (!isatty(2))\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEnd(bool pass)\t\t\t// I - `true` if the test passed, `false` otherwise\n{\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  if (!pass)\n    testsPassed = false;\n\n  puts(pass ? \"PASS\" : \"FAIL\");\n  if (!isatty(2))\n    fputs(pass ? \"PASS\\n\" : \"FAIL\\n\", stderr);\n\n  test_title[0] = '\\0';\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEndMessage(bool       pass,\t\t// I - `true` if the test passed, `false` otherwise\n               const char *message, ...)// I - printf-style message\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, message);\n  vsnprintf(buffer, sizeof(buffer), message, ap);\n  va_end(ap);\n\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  printf(pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n  if (!isatty(2))\n    fprintf(stderr, pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n\n  test_title[0] = '\\0';\n}\n\n\n// Show/update a progress spinner\nstatic inline void\ntestProgress(void)\n{\n  if (test_progress)\n    putchar('\\b');\n  putchar(\"-\\\\|/\"[test_progress & 3]);\n  fflush(stdout);\n\n  test_progress ++;\n}\n\n\n// Show an error to stderr...\nstatic inline void\ntestError(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the error to stderr...\n  fprintf(stderr, \"%s\\n\", buffer);\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// Show a message to stdout and stderr...\nstatic inline void\ntestMessage(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the message to stdout and stderr too if needed...\n  printf(\"%s\\n\", buffer);\n  if (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n\n  if (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n}\n\n\n// Show a hex dump of a buffer to stderr...\nstatic inline void\ntestHexDump(const unsigned char *buffer,// I - Buffer\n            size_t              bytes)\t// I - Number of bytes\n{\n  size_t\ti, j;\t\t\t// Looping vars\n  int\t\tch;\t\t\t// Current ASCII char\n\n\n  if (test_title[0])\n    fputs(\"\\n\", stderr);\n\n  // Show lines of 16 bytes at a time...\n  for (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n#  ifdef __cplusplus\n}\n#  endif // __cplusplus\n#endif ",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "struct_assignment",
    "start_line": 28,
    "end_line": 281,
    "code": "ifndef TEST_H\n#  define TEST_H\n#  include <stdio.h>\n#  include <stdlib.h>\n#  include <stdarg.h>\n#  include <stdbool.h>\n#  include <string.h>\n#  if _WIN32\n#    define isatty(f) _isatty(f)\n#  else\n#    include <unistd.h>\n#  endif // !_WIN32\n#  ifdef __cplusplus\nextern \"C\" {\n#  endif // __cplusplus\n\n\n//\n// This header implements a simple unit test framework for C/C++ programs.\n// Inline functions are provided to write a test summary to stdout and the\n// details to stderr.  This allows unit test programs to output a summary to\n// stdout with details sent to stderr, e.g.:\n//\n//     mytestprogram 2>test.log\n//\n// Documentation:\n//\n// void testBegin(const char *title, ...)\n//\n//     Start a test with a printf-style title message.  \"Title:\" (the formatted\n//     title followed by a colon) is output.\n//\n// void testEnd(bool pass)\n//\n//     End a test without an additional message.  \"pass\" should be `true` if the\n//     test passed and `false` otherwise.  \"PASS\" or \"FAIL\" is output.\n//\n// void testEndMessage(bool pass, const char *message, ...)\n//\n//     End a test with an additional printf-style message.  \"pass\" should be\n//     `true` if the test passed and `false` otherwise.  \"PASS (message)\" or\n//     \"FAIL (message)\" is output.\n//\n// testError(const char *error, ...)\n//\n//     Sends a formatted error string to stderr.\n//\n// testHexDump(const unsigned char *buffer, size_t bytes)\n//\n//     Sends a hex dump of the specified buffer to stderr.\n//\n// testMessage(const char *error, ...)\n//\n//     Outputs a formatted message string.\n//\n// testProgress(void)\n//\n//     Shows a progress spinner for long-running tests.\n//\n// bool testsPassed\n//\n//     This global variable specifies whether all tests have passed (`true`)\n//     or one or more have failed (`false`).\n//\n\nstatic bool testsPassed = true;\t\t// All tests passed?\nstatic int test_progress;\t\t// Current progress\nstatic char test_title[1024] = \"\";\t// Current test title\n\n\n// Start a test\nstatic inline void\ntestBegin(const char *title, ...)\t// I - printf-style title string\n{\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, title);\n  vsnprintf(test_title, sizeof(test_title), title, ap);\n  va_end(ap);\n\n  // Send the title to stdout and stderr...\n  test_progress = 0;\n\n  printf(\"%s: \", test_title);\n  fflush(stdout);\n\n  if (!isatty(2))\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEnd(bool pass)\t\t\t// I - `true` if the test passed, `false` otherwise\n{\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  if (!pass)\n    testsPassed = false;\n\n  puts(pass ? \"PASS\" : \"FAIL\");\n  if (!isatty(2))\n    fputs(pass ? \"PASS\\n\" : \"FAIL\\n\", stderr);\n\n  test_title[0] = '\\0';\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEndMessage(bool       pass,\t\t// I - `true` if the test passed, `false` otherwise\n               const char *message, ...)// I - printf-style message\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, message);\n  vsnprintf(buffer, sizeof(buffer), message, ap);\n  va_end(ap);\n\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  printf(pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n  if (!isatty(2))\n    fprintf(stderr, pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n\n  test_title[0] = '\\0';\n}\n\n\n// Show/update a progress spinner\nstatic inline void\ntestProgress(void)\n{\n  if (test_progress)\n    putchar('\\b');\n  putchar(\"-\\\\|/\"[test_progress & 3]);\n  fflush(stdout);\n\n  test_progress ++;\n}\n\n\n// Show an error to stderr...\nstatic inline void\ntestError(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the error to stderr...\n  fprintf(stderr, \"%s\\n\", buffer);\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// Show a message to stdout and stderr...\nstatic inline void\ntestMessage(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the message to stdout and stderr too if needed...\n  printf(\"%s\\n\", buffer);\n  if (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n\n  if (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n}\n\n\n// Show a hex dump of a buffer to stderr...\nstatic inline void\ntestHexDump(const unsigned char *buffer,// I - Buffer\n            size_t              bytes)\t// I - Number of bytes\n{\n  size_t\ti, j;\t\t\t// Looping vars\n  int\t\tch;\t\t\t// Current ASCII char\n\n\n  if (test_title[0])\n    fputs(\"\\n\", stderr);\n\n  // Show lines of 16 bytes at a time...\n  for (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n#  ifdef __cplusplus\n}\n#  endif // __cplusplus\n#endif ",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 28,
    "end_line": 281,
    "code": "ifndef TEST_H\n#  define TEST_H\n#  include <stdio.h>\n#  include <stdlib.h>\n#  include <stdarg.h>\n#  include <stdbool.h>\n#  include <string.h>\n#  if _WIN32\n#    define isatty(f) _isatty(f)\n#  else\n#    include <unistd.h>\n#  endif // !_WIN32\n#  ifdef __cplusplus\nextern \"C\" {\n#  endif // __cplusplus\n\n\n//\n// This header implements a simple unit test framework for C/C++ programs.\n// Inline functions are provided to write a test summary to stdout and the\n// details to stderr.  This allows unit test programs to output a summary to\n// stdout with details sent to stderr, e.g.:\n//\n//     mytestprogram 2>test.log\n//\n// Documentation:\n//\n// void testBegin(const char *title, ...)\n//\n//     Start a test with a printf-style title message.  \"Title:\" (the formatted\n//     title followed by a colon) is output.\n//\n// void testEnd(bool pass)\n//\n//     End a test without an additional message.  \"pass\" should be `true` if the\n//     test passed and `false` otherwise.  \"PASS\" or \"FAIL\" is output.\n//\n// void testEndMessage(bool pass, const char *message, ...)\n//\n//     End a test with an additional printf-style message.  \"pass\" should be\n//     `true` if the test passed and `false` otherwise.  \"PASS (message)\" or\n//     \"FAIL (message)\" is output.\n//\n// testError(const char *error, ...)\n//\n//     Sends a formatted error string to stderr.\n//\n// testHexDump(const unsigned char *buffer, size_t bytes)\n//\n//     Sends a hex dump of the specified buffer to stderr.\n//\n// testMessage(const char *error, ...)\n//\n//     Outputs a formatted message string.\n//\n// testProgress(void)\n//\n//     Shows a progress spinner for long-running tests.\n//\n// bool testsPassed\n//\n//     This global variable specifies whether all tests have passed (`true`)\n//     or one or more have failed (`false`).\n//\n\nstatic bool testsPassed = true;\t\t// All tests passed?\nstatic int test_progress;\t\t// Current progress\nstatic char test_title[1024] = \"\";\t// Current test title\n\n\n// Start a test\nstatic inline void\ntestBegin(const char *title, ...)\t// I - printf-style title string\n{\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, title);\n  vsnprintf(test_title, sizeof(test_title), title, ap);\n  va_end(ap);\n\n  // Send the title to stdout and stderr...\n  test_progress = 0;\n\n  printf(\"%s: \", test_title);\n  fflush(stdout);\n\n  if (!isatty(2))\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEnd(bool pass)\t\t\t// I - `true` if the test passed, `false` otherwise\n{\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  if (!pass)\n    testsPassed = false;\n\n  puts(pass ? \"PASS\" : \"FAIL\");\n  if (!isatty(2))\n    fputs(pass ? \"PASS\\n\" : \"FAIL\\n\", stderr);\n\n  test_title[0] = '\\0';\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEndMessage(bool       pass,\t\t// I - `true` if the test passed, `false` otherwise\n               const char *message, ...)// I - printf-style message\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, message);\n  vsnprintf(buffer, sizeof(buffer), message, ap);\n  va_end(ap);\n\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  printf(pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n  if (!isatty(2))\n    fprintf(stderr, pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n\n  test_title[0] = '\\0';\n}\n\n\n// Show/update a progress spinner\nstatic inline void\ntestProgress(void)\n{\n  if (test_progress)\n    putchar('\\b');\n  putchar(\"-\\\\|/\"[test_progress & 3]);\n  fflush(stdout);\n\n  test_progress ++;\n}\n\n\n// Show an error to stderr...\nstatic inline void\ntestError(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the error to stderr...\n  fprintf(stderr, \"%s\\n\", buffer);\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// Show a message to stdout and stderr...\nstatic inline void\ntestMessage(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the message to stdout and stderr too if needed...\n  printf(\"%s\\n\", buffer);\n  if (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n\n  if (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n}\n\n\n// Show a hex dump of a buffer to stderr...\nstatic inline void\ntestHexDump(const unsigned char *buffer,// I - Buffer\n            size_t              bytes)\t// I - Number of bytes\n{\n  size_t\ti, j;\t\t\t// Looping vars\n  int\t\tch;\t\t\t// Current ASCII char\n\n\n  if (test_title[0])\n    fputs(\"\\n\", stderr);\n\n  // Show lines of 16 bytes at a time...\n  for (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n#  ifdef __cplusplus\n}\n#  endif // __cplusplus\n#endif ",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "macro",
    "start_line": 29,
    "end_line": 30,
    "code": "  define TEST_H\n#",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "include",
    "start_line": 30,
    "end_line": 31,
    "code": "  include <stdio.h>\n#",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "include",
    "start_line": 31,
    "end_line": 32,
    "code": "  include <stdlib.h>\n#",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "include",
    "start_line": 32,
    "end_line": 33,
    "code": "  include <stdarg.h>\n#",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "include",
    "start_line": 33,
    "end_line": 34,
    "code": "  include <stdbool.h>\n#",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "include",
    "start_line": 34,
    "end_line": 35,
    "code": "  include <string.h>\n#",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "preprocessor",
    "start_line": 35,
    "end_line": 39,
    "code": "  if _WIN32\n#    define isatty(f) _isatty(f)\n#  else\n#    include <unistd.h>\n#  endif ",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "macro_function",
    "start_line": 36,
    "end_line": 37,
    "code": "    define isatty(f) _isatty(f)\n#",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "include",
    "start_line": 38,
    "end_line": 39,
    "code": "    include <unistd.h>\n#",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "preprocessor",
    "start_line": 40,
    "end_line": 280,
    "code": "  ifdef __cplusplus\nextern \"C\" {\n#  endif // __cplusplus\n\n\n//\n// This header implements a simple unit test framework for C/C++ programs.\n// Inline functions are provided to write a test summary to stdout and the\n// details to stderr.  This allows unit test programs to output a summary to\n// stdout with details sent to stderr, e.g.:\n//\n//     mytestprogram 2>test.log\n//\n// Documentation:\n//\n// void testBegin(const char *title, ...)\n//\n//     Start a test with a printf-style title message.  \"Title:\" (the formatted\n//     title followed by a colon) is output.\n//\n// void testEnd(bool pass)\n//\n//     End a test without an additional message.  \"pass\" should be `true` if the\n//     test passed and `false` otherwise.  \"PASS\" or \"FAIL\" is output.\n//\n// void testEndMessage(bool pass, const char *message, ...)\n//\n//     End a test with an additional printf-style message.  \"pass\" should be\n//     `true` if the test passed and `false` otherwise.  \"PASS (message)\" or\n//     \"FAIL (message)\" is output.\n//\n// testError(const char *error, ...)\n//\n//     Sends a formatted error string to stderr.\n//\n// testHexDump(const unsigned char *buffer, size_t bytes)\n//\n//     Sends a hex dump of the specified buffer to stderr.\n//\n// testMessage(const char *error, ...)\n//\n//     Outputs a formatted message string.\n//\n// testProgress(void)\n//\n//     Shows a progress spinner for long-running tests.\n//\n// bool testsPassed\n//\n//     This global variable specifies whether all tests have passed (`true`)\n//     or one or more have failed (`false`).\n//\n\nstatic bool testsPassed = true;\t\t// All tests passed?\nstatic int test_progress;\t\t// Current progress\nstatic char test_title[1024] = \"\";\t// Current test title\n\n\n// Start a test\nstatic inline void\ntestBegin(const char *title, ...)\t// I - printf-style title string\n{\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, title);\n  vsnprintf(test_title, sizeof(test_title), title, ap);\n  va_end(ap);\n\n  // Send the title to stdout and stderr...\n  test_progress = 0;\n\n  printf(\"%s: \", test_title);\n  fflush(stdout);\n\n  if (!isatty(2))\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEnd(bool pass)\t\t\t// I - `true` if the test passed, `false` otherwise\n{\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  if (!pass)\n    testsPassed = false;\n\n  puts(pass ? \"PASS\" : \"FAIL\");\n  if (!isatty(2))\n    fputs(pass ? \"PASS\\n\" : \"FAIL\\n\", stderr);\n\n  test_title[0] = '\\0';\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEndMessage(bool       pass,\t\t// I - `true` if the test passed, `false` otherwise\n               const char *message, ...)// I - printf-style message\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, message);\n  vsnprintf(buffer, sizeof(buffer), message, ap);\n  va_end(ap);\n\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  printf(pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n  if (!isatty(2))\n    fprintf(stderr, pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n\n  test_title[0] = '\\0';\n}\n\n\n// Show/update a progress spinner\nstatic inline void\ntestProgress(void)\n{\n  if (test_progress)\n    putchar('\\b');\n  putchar(\"-\\\\|/\"[test_progress & 3]);\n  fflush(stdout);\n\n  test_progress ++;\n}\n\n\n// Show an error to stderr...\nstatic inline void\ntestError(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the error to stderr...\n  fprintf(stderr, \"%s\\n\", buffer);\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// Show a message to stdout and stderr...\nstatic inline void\ntestMessage(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the message to stdout and stderr too if needed...\n  printf(\"%s\\n\", buffer);\n  if (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n\n  if (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n}\n\n\n// Show a hex dump of a buffer to stderr...\nstatic inline void\ntestHexDump(const unsigned char *buffer,// I - Buffer\n            size_t              bytes)\t// I - Number of bytes\n{\n  size_t\ti, j;\t\t\t// Looping vars\n  int\t\tch;\t\t\t// Current ASCII char\n\n\n  if (test_title[0])\n    fputs(\"\\n\", stderr);\n\n  // Show lines of 16 bytes at a time...\n  for (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n#  ifdef __cplusplus\n}\n#  endif ",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "struct_assignment",
    "start_line": 40,
    "end_line": 280,
    "code": "  ifdef __cplusplus\nextern \"C\" {\n#  endif // __cplusplus\n\n\n//\n// This header implements a simple unit test framework for C/C++ programs.\n// Inline functions are provided to write a test summary to stdout and the\n// details to stderr.  This allows unit test programs to output a summary to\n// stdout with details sent to stderr, e.g.:\n//\n//     mytestprogram 2>test.log\n//\n// Documentation:\n//\n// void testBegin(const char *title, ...)\n//\n//     Start a test with a printf-style title message.  \"Title:\" (the formatted\n//     title followed by a colon) is output.\n//\n// void testEnd(bool pass)\n//\n//     End a test without an additional message.  \"pass\" should be `true` if the\n//     test passed and `false` otherwise.  \"PASS\" or \"FAIL\" is output.\n//\n// void testEndMessage(bool pass, const char *message, ...)\n//\n//     End a test with an additional printf-style message.  \"pass\" should be\n//     `true` if the test passed and `false` otherwise.  \"PASS (message)\" or\n//     \"FAIL (message)\" is output.\n//\n// testError(const char *error, ...)\n//\n//     Sends a formatted error string to stderr.\n//\n// testHexDump(const unsigned char *buffer, size_t bytes)\n//\n//     Sends a hex dump of the specified buffer to stderr.\n//\n// testMessage(const char *error, ...)\n//\n//     Outputs a formatted message string.\n//\n// testProgress(void)\n//\n//     Shows a progress spinner for long-running tests.\n//\n// bool testsPassed\n//\n//     This global variable specifies whether all tests have passed (`true`)\n//     or one or more have failed (`false`).\n//\n\nstatic bool testsPassed = true;\t\t// All tests passed?\nstatic int test_progress;\t\t// Current progress\nstatic char test_title[1024] = \"\";\t// Current test title\n\n\n// Start a test\nstatic inline void\ntestBegin(const char *title, ...)\t// I - printf-style title string\n{\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, title);\n  vsnprintf(test_title, sizeof(test_title), title, ap);\n  va_end(ap);\n\n  // Send the title to stdout and stderr...\n  test_progress = 0;\n\n  printf(\"%s: \", test_title);\n  fflush(stdout);\n\n  if (!isatty(2))\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEnd(bool pass)\t\t\t// I - `true` if the test passed, `false` otherwise\n{\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  if (!pass)\n    testsPassed = false;\n\n  puts(pass ? \"PASS\" : \"FAIL\");\n  if (!isatty(2))\n    fputs(pass ? \"PASS\\n\" : \"FAIL\\n\", stderr);\n\n  test_title[0] = '\\0';\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEndMessage(bool       pass,\t\t// I - `true` if the test passed, `false` otherwise\n               const char *message, ...)// I - printf-style message\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, message);\n  vsnprintf(buffer, sizeof(buffer), message, ap);\n  va_end(ap);\n\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  printf(pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n  if (!isatty(2))\n    fprintf(stderr, pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n\n  test_title[0] = '\\0';\n}\n\n\n// Show/update a progress spinner\nstatic inline void\ntestProgress(void)\n{\n  if (test_progress)\n    putchar('\\b');\n  putchar(\"-\\\\|/\"[test_progress & 3]);\n  fflush(stdout);\n\n  test_progress ++;\n}\n\n\n// Show an error to stderr...\nstatic inline void\ntestError(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the error to stderr...\n  fprintf(stderr, \"%s\\n\", buffer);\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// Show a message to stdout and stderr...\nstatic inline void\ntestMessage(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the message to stdout and stderr too if needed...\n  printf(\"%s\\n\", buffer);\n  if (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n\n  if (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n}\n\n\n// Show a hex dump of a buffer to stderr...\nstatic inline void\ntestHexDump(const unsigned char *buffer,// I - Buffer\n            size_t              bytes)\t// I - Number of bytes\n{\n  size_t\ti, j;\t\t\t// Looping vars\n  int\t\tch;\t\t\t// Current ASCII char\n\n\n  if (test_title[0])\n    fputs(\"\\n\", stderr);\n\n  // Show lines of 16 bytes at a time...\n  for (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n#  ifdef __cplusplus\n}\n#  endif ",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 40,
    "end_line": 280,
    "code": "  ifdef __cplusplus\nextern \"C\" {\n#  endif // __cplusplus\n\n\n//\n// This header implements a simple unit test framework for C/C++ programs.\n// Inline functions are provided to write a test summary to stdout and the\n// details to stderr.  This allows unit test programs to output a summary to\n// stdout with details sent to stderr, e.g.:\n//\n//     mytestprogram 2>test.log\n//\n// Documentation:\n//\n// void testBegin(const char *title, ...)\n//\n//     Start a test with a printf-style title message.  \"Title:\" (the formatted\n//     title followed by a colon) is output.\n//\n// void testEnd(bool pass)\n//\n//     End a test without an additional message.  \"pass\" should be `true` if the\n//     test passed and `false` otherwise.  \"PASS\" or \"FAIL\" is output.\n//\n// void testEndMessage(bool pass, const char *message, ...)\n//\n//     End a test with an additional printf-style message.  \"pass\" should be\n//     `true` if the test passed and `false` otherwise.  \"PASS (message)\" or\n//     \"FAIL (message)\" is output.\n//\n// testError(const char *error, ...)\n//\n//     Sends a formatted error string to stderr.\n//\n// testHexDump(const unsigned char *buffer, size_t bytes)\n//\n//     Sends a hex dump of the specified buffer to stderr.\n//\n// testMessage(const char *error, ...)\n//\n//     Outputs a formatted message string.\n//\n// testProgress(void)\n//\n//     Shows a progress spinner for long-running tests.\n//\n// bool testsPassed\n//\n//     This global variable specifies whether all tests have passed (`true`)\n//     or one or more have failed (`false`).\n//\n\nstatic bool testsPassed = true;\t\t// All tests passed?\nstatic int test_progress;\t\t// Current progress\nstatic char test_title[1024] = \"\";\t// Current test title\n\n\n// Start a test\nstatic inline void\ntestBegin(const char *title, ...)\t// I - printf-style title string\n{\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, title);\n  vsnprintf(test_title, sizeof(test_title), title, ap);\n  va_end(ap);\n\n  // Send the title to stdout and stderr...\n  test_progress = 0;\n\n  printf(\"%s: \", test_title);\n  fflush(stdout);\n\n  if (!isatty(2))\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEnd(bool pass)\t\t\t// I - `true` if the test passed, `false` otherwise\n{\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  if (!pass)\n    testsPassed = false;\n\n  puts(pass ? \"PASS\" : \"FAIL\");\n  if (!isatty(2))\n    fputs(pass ? \"PASS\\n\" : \"FAIL\\n\", stderr);\n\n  test_title[0] = '\\0';\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEndMessage(bool       pass,\t\t// I - `true` if the test passed, `false` otherwise\n               const char *message, ...)// I - printf-style message\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, message);\n  vsnprintf(buffer, sizeof(buffer), message, ap);\n  va_end(ap);\n\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  printf(pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n  if (!isatty(2))\n    fprintf(stderr, pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n\n  test_title[0] = '\\0';\n}\n\n\n// Show/update a progress spinner\nstatic inline void\ntestProgress(void)\n{\n  if (test_progress)\n    putchar('\\b');\n  putchar(\"-\\\\|/\"[test_progress & 3]);\n  fflush(stdout);\n\n  test_progress ++;\n}\n\n\n// Show an error to stderr...\nstatic inline void\ntestError(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the error to stderr...\n  fprintf(stderr, \"%s\\n\", buffer);\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// Show a message to stdout and stderr...\nstatic inline void\ntestMessage(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the message to stdout and stderr too if needed...\n  printf(\"%s\\n\", buffer);\n  if (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n\n  if (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n}\n\n\n// Show a hex dump of a buffer to stderr...\nstatic inline void\ntestHexDump(const unsigned char *buffer,// I - Buffer\n            size_t              bytes)\t// I - Number of bytes\n{\n  size_t\ti, j;\t\t\t// Looping vars\n  int\t\tch;\t\t\t// Current ASCII char\n\n\n  if (test_title[0])\n    fputs(\"\\n\", stderr);\n\n  // Show lines of 16 bytes at a time...\n  for (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n#  ifdef __cplusplus\n}\n#  endif ",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "struct_assignment",
    "start_line": 41,
    "end_line": 279,
    "code": "xtern \"C\" {\n#  endif // __cplusplus\n\n\n//\n// This header implements a simple unit test framework for C/C++ programs.\n// Inline functions are provided to write a test summary to stdout and the\n// details to stderr.  This allows unit test programs to output a summary to\n// stdout with details sent to stderr, e.g.:\n//\n//     mytestprogram 2>test.log\n//\n// Documentation:\n//\n// void testBegin(const char *title, ...)\n//\n//     Start a test with a printf-style title message.  \"Title:\" (the formatted\n//     title followed by a colon) is output.\n//\n// void testEnd(bool pass)\n//\n//     End a test without an additional message.  \"pass\" should be `true` if the\n//     test passed and `false` otherwise.  \"PASS\" or \"FAIL\" is output.\n//\n// void testEndMessage(bool pass, const char *message, ...)\n//\n//     End a test with an additional printf-style message.  \"pass\" should be\n//     `true` if the test passed and `false` otherwise.  \"PASS (message)\" or\n//     \"FAIL (message)\" is output.\n//\n// testError(const char *error, ...)\n//\n//     Sends a formatted error string to stderr.\n//\n// testHexDump(const unsigned char *buffer, size_t bytes)\n//\n//     Sends a hex dump of the specified buffer to stderr.\n//\n// testMessage(const char *error, ...)\n//\n//     Outputs a formatted message string.\n//\n// testProgress(void)\n//\n//     Shows a progress spinner for long-running tests.\n//\n// bool testsPassed\n//\n//     This global variable specifies whether all tests have passed (`true`)\n//     or one or more have failed (`false`).\n//\n\nstatic bool testsPassed = true;\t\t// All tests passed?\nstatic int test_progress;\t\t// Current progress\nstatic char test_title[1024] = \"\";\t// Current test title\n\n\n// Start a test\nstatic inline void\ntestBegin(const char *title, ...)\t// I - printf-style title string\n{\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, title);\n  vsnprintf(test_title, sizeof(test_title), title, ap);\n  va_end(ap);\n\n  // Send the title to stdout and stderr...\n  test_progress = 0;\n\n  printf(\"%s: \", test_title);\n  fflush(stdout);\n\n  if (!isatty(2))\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEnd(bool pass)\t\t\t// I - `true` if the test passed, `false` otherwise\n{\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  if (!pass)\n    testsPassed = false;\n\n  puts(pass ? \"PASS\" : \"FAIL\");\n  if (!isatty(2))\n    fputs(pass ? \"PASS\\n\" : \"FAIL\\n\", stderr);\n\n  test_title[0] = '\\0';\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEndMessage(bool       pass,\t\t// I - `true` if the test passed, `false` otherwise\n               const char *message, ...)// I - printf-style message\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, message);\n  vsnprintf(buffer, sizeof(buffer), message, ap);\n  va_end(ap);\n\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  printf(pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n  if (!isatty(2))\n    fprintf(stderr, pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n\n  test_title[0] = '\\0';\n}\n\n\n// Show/update a progress spinner\nstatic inline void\ntestProgress(void)\n{\n  if (test_progress)\n    putchar('\\b');\n  putchar(\"-\\\\|/\"[test_progress & 3]);\n  fflush(stdout);\n\n  test_progress ++;\n}\n\n\n// Show an error to stderr...\nstatic inline void\ntestError(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the error to stderr...\n  fprintf(stderr, \"%s\\n\", buffer);\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// Show a message to stdout and stderr...\nstatic inline void\ntestMessage(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the message to stdout and stderr too if needed...\n  printf(\"%s\\n\", buffer);\n  if (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n\n  if (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n}\n\n\n// Show a hex dump of a buffer to stderr...\nstatic inline void\ntestHexDump(const unsigned char *buffer,// I - Buffer\n            size_t              bytes)\t// I - Number of bytes\n{\n  size_t\ti, j;\t\t\t// Looping vars\n  int\t\tch;\t\t\t// Current ASCII char\n\n\n  if (test_title[0])\n    fputs(\"\\n\", stderr);\n\n  // Show lines of 16 bytes at a time...\n  for (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n#  ifdef __cplusplus\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 41,
    "end_line": 279,
    "code": "xtern \"C\" {\n#  endif // __cplusplus\n\n\n//\n// This header implements a simple unit test framework for C/C++ programs.\n// Inline functions are provided to write a test summary to stdout and the\n// details to stderr.  This allows unit test programs to output a summary to\n// stdout with details sent to stderr, e.g.:\n//\n//     mytestprogram 2>test.log\n//\n// Documentation:\n//\n// void testBegin(const char *title, ...)\n//\n//     Start a test with a printf-style title message.  \"Title:\" (the formatted\n//     title followed by a colon) is output.\n//\n// void testEnd(bool pass)\n//\n//     End a test without an additional message.  \"pass\" should be `true` if the\n//     test passed and `false` otherwise.  \"PASS\" or \"FAIL\" is output.\n//\n// void testEndMessage(bool pass, const char *message, ...)\n//\n//     End a test with an additional printf-style message.  \"pass\" should be\n//     `true` if the test passed and `false` otherwise.  \"PASS (message)\" or\n//     \"FAIL (message)\" is output.\n//\n// testError(const char *error, ...)\n//\n//     Sends a formatted error string to stderr.\n//\n// testHexDump(const unsigned char *buffer, size_t bytes)\n//\n//     Sends a hex dump of the specified buffer to stderr.\n//\n// testMessage(const char *error, ...)\n//\n//     Outputs a formatted message string.\n//\n// testProgress(void)\n//\n//     Shows a progress spinner for long-running tests.\n//\n// bool testsPassed\n//\n//     This global variable specifies whether all tests have passed (`true`)\n//     or one or more have failed (`false`).\n//\n\nstatic bool testsPassed = true;\t\t// All tests passed?\nstatic int test_progress;\t\t// Current progress\nstatic char test_title[1024] = \"\";\t// Current test title\n\n\n// Start a test\nstatic inline void\ntestBegin(const char *title, ...)\t// I - printf-style title string\n{\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, title);\n  vsnprintf(test_title, sizeof(test_title), title, ap);\n  va_end(ap);\n\n  // Send the title to stdout and stderr...\n  test_progress = 0;\n\n  printf(\"%s: \", test_title);\n  fflush(stdout);\n\n  if (!isatty(2))\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEnd(bool pass)\t\t\t// I - `true` if the test passed, `false` otherwise\n{\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  if (!pass)\n    testsPassed = false;\n\n  puts(pass ? \"PASS\" : \"FAIL\");\n  if (!isatty(2))\n    fputs(pass ? \"PASS\\n\" : \"FAIL\\n\", stderr);\n\n  test_title[0] = '\\0';\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEndMessage(bool       pass,\t\t// I - `true` if the test passed, `false` otherwise\n               const char *message, ...)// I - printf-style message\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, message);\n  vsnprintf(buffer, sizeof(buffer), message, ap);\n  va_end(ap);\n\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  printf(pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n  if (!isatty(2))\n    fprintf(stderr, pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n\n  test_title[0] = '\\0';\n}\n\n\n// Show/update a progress spinner\nstatic inline void\ntestProgress(void)\n{\n  if (test_progress)\n    putchar('\\b');\n  putchar(\"-\\\\|/\"[test_progress & 3]);\n  fflush(stdout);\n\n  test_progress ++;\n}\n\n\n// Show an error to stderr...\nstatic inline void\ntestError(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the error to stderr...\n  fprintf(stderr, \"%s\\n\", buffer);\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// Show a message to stdout and stderr...\nstatic inline void\ntestMessage(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the message to stdout and stderr too if needed...\n  printf(\"%s\\n\", buffer);\n  if (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n\n  if (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n}\n\n\n// Show a hex dump of a buffer to stderr...\nstatic inline void\ntestHexDump(const unsigned char *buffer,// I - Buffer\n            size_t              bytes)\t// I - Number of bytes\n{\n  size_t\ti, j;\t\t\t// Looping vars\n  int\t\tch;\t\t\t// Current ASCII char\n\n\n  if (test_title[0])\n    fputs(\"\\n\", stderr);\n\n  // Show lines of 16 bytes at a time...\n  for (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n#  ifdef __cplusplus\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "struct_assignment",
    "start_line": 41,
    "end_line": 279,
    "code": "\n#  endif // __cplusplus\n\n\n//\n// This header implements a simple unit test framework for C/C++ programs.\n// Inline functions are provided to write a test summary to stdout and the\n// details to stderr.  This allows unit test programs to output a summary to\n// stdout with details sent to stderr, e.g.:\n//\n//     mytestprogram 2>test.log\n//\n// Documentation:\n//\n// void testBegin(const char *title, ...)\n//\n//     Start a test with a printf-style title message.  \"Title:\" (the formatted\n//     title followed by a colon) is output.\n//\n// void testEnd(bool pass)\n//\n//     End a test without an additional message.  \"pass\" should be `true` if the\n//     test passed and `false` otherwise.  \"PASS\" or \"FAIL\" is output.\n//\n// void testEndMessage(bool pass, const char *message, ...)\n//\n//     End a test with an additional printf-style message.  \"pass\" should be\n//     `true` if the test passed and `false` otherwise.  \"PASS (message)\" or\n//     \"FAIL (message)\" is output.\n//\n// testError(const char *error, ...)\n//\n//     Sends a formatted error string to stderr.\n//\n// testHexDump(const unsigned char *buffer, size_t bytes)\n//\n//     Sends a hex dump of the specified buffer to stderr.\n//\n// testMessage(const char *error, ...)\n//\n//     Outputs a formatted message string.\n//\n// testProgress(void)\n//\n//     Shows a progress spinner for long-running tests.\n//\n// bool testsPassed\n//\n//     This global variable specifies whether all tests have passed (`true`)\n//     or one or more have failed (`false`).\n//\n\nstatic bool testsPassed = true;\t\t// All tests passed?\nstatic int test_progress;\t\t// Current progress\nstatic char test_title[1024] = \"\";\t// Current test title\n\n\n// Start a test\nstatic inline void\ntestBegin(const char *title, ...)\t// I - printf-style title string\n{\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, title);\n  vsnprintf(test_title, sizeof(test_title), title, ap);\n  va_end(ap);\n\n  // Send the title to stdout and stderr...\n  test_progress = 0;\n\n  printf(\"%s: \", test_title);\n  fflush(stdout);\n\n  if (!isatty(2))\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEnd(bool pass)\t\t\t// I - `true` if the test passed, `false` otherwise\n{\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  if (!pass)\n    testsPassed = false;\n\n  puts(pass ? \"PASS\" : \"FAIL\");\n  if (!isatty(2))\n    fputs(pass ? \"PASS\\n\" : \"FAIL\\n\", stderr);\n\n  test_title[0] = '\\0';\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEndMessage(bool       pass,\t\t// I - `true` if the test passed, `false` otherwise\n               const char *message, ...)// I - printf-style message\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, message);\n  vsnprintf(buffer, sizeof(buffer), message, ap);\n  va_end(ap);\n\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  printf(pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n  if (!isatty(2))\n    fprintf(stderr, pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n\n  test_title[0] = '\\0';\n}\n\n\n// Show/update a progress spinner\nstatic inline void\ntestProgress(void)\n{\n  if (test_progress)\n    putchar('\\b');\n  putchar(\"-\\\\|/\"[test_progress & 3]);\n  fflush(stdout);\n\n  test_progress ++;\n}\n\n\n// Show an error to stderr...\nstatic inline void\ntestError(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the error to stderr...\n  fprintf(stderr, \"%s\\n\", buffer);\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// Show a message to stdout and stderr...\nstatic inline void\ntestMessage(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the message to stdout and stderr too if needed...\n  printf(\"%s\\n\", buffer);\n  if (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n\n  if (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n}\n\n\n// Show a hex dump of a buffer to stderr...\nstatic inline void\ntestHexDump(const unsigned char *buffer,// I - Buffer\n            size_t              bytes)\t// I - Number of bytes\n{\n  size_t\ti, j;\t\t\t// Looping vars\n  int\t\tch;\t\t\t// Current ASCII char\n\n\n  if (test_title[0])\n    fputs(\"\\n\", stderr);\n\n  // Show lines of 16 bytes at a time...\n  for (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n#  ifdef __cplusplus\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 41,
    "end_line": 279,
    "code": "\n#  endif // __cplusplus\n\n\n//\n// This header implements a simple unit test framework for C/C++ programs.\n// Inline functions are provided to write a test summary to stdout and the\n// details to stderr.  This allows unit test programs to output a summary to\n// stdout with details sent to stderr, e.g.:\n//\n//     mytestprogram 2>test.log\n//\n// Documentation:\n//\n// void testBegin(const char *title, ...)\n//\n//     Start a test with a printf-style title message.  \"Title:\" (the formatted\n//     title followed by a colon) is output.\n//\n// void testEnd(bool pass)\n//\n//     End a test without an additional message.  \"pass\" should be `true` if the\n//     test passed and `false` otherwise.  \"PASS\" or \"FAIL\" is output.\n//\n// void testEndMessage(bool pass, const char *message, ...)\n//\n//     End a test with an additional printf-style message.  \"pass\" should be\n//     `true` if the test passed and `false` otherwise.  \"PASS (message)\" or\n//     \"FAIL (message)\" is output.\n//\n// testError(const char *error, ...)\n//\n//     Sends a formatted error string to stderr.\n//\n// testHexDump(const unsigned char *buffer, size_t bytes)\n//\n//     Sends a hex dump of the specified buffer to stderr.\n//\n// testMessage(const char *error, ...)\n//\n//     Outputs a formatted message string.\n//\n// testProgress(void)\n//\n//     Shows a progress spinner for long-running tests.\n//\n// bool testsPassed\n//\n//     This global variable specifies whether all tests have passed (`true`)\n//     or one or more have failed (`false`).\n//\n\nstatic bool testsPassed = true;\t\t// All tests passed?\nstatic int test_progress;\t\t// Current progress\nstatic char test_title[1024] = \"\";\t// Current test title\n\n\n// Start a test\nstatic inline void\ntestBegin(const char *title, ...)\t// I - printf-style title string\n{\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, title);\n  vsnprintf(test_title, sizeof(test_title), title, ap);\n  va_end(ap);\n\n  // Send the title to stdout and stderr...\n  test_progress = 0;\n\n  printf(\"%s: \", test_title);\n  fflush(stdout);\n\n  if (!isatty(2))\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEnd(bool pass)\t\t\t// I - `true` if the test passed, `false` otherwise\n{\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  if (!pass)\n    testsPassed = false;\n\n  puts(pass ? \"PASS\" : \"FAIL\");\n  if (!isatty(2))\n    fputs(pass ? \"PASS\\n\" : \"FAIL\\n\", stderr);\n\n  test_title[0] = '\\0';\n}\n\n\n// End a test with no additional information\nstatic inline void\ntestEndMessage(bool       pass,\t\t// I - `true` if the test passed, `false` otherwise\n               const char *message, ...)// I - printf-style message\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, message);\n  vsnprintf(buffer, sizeof(buffer), message, ap);\n  va_end(ap);\n\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  printf(pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n  if (!isatty(2))\n    fprintf(stderr, pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n\n  test_title[0] = '\\0';\n}\n\n\n// Show/update a progress spinner\nstatic inline void\ntestProgress(void)\n{\n  if (test_progress)\n    putchar('\\b');\n  putchar(\"-\\\\|/\"[test_progress & 3]);\n  fflush(stdout);\n\n  test_progress ++;\n}\n\n\n// Show an error to stderr...\nstatic inline void\ntestError(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the error to stderr...\n  fprintf(stderr, \"%s\\n\", buffer);\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n\n// Show a message to stdout and stderr...\nstatic inline void\ntestMessage(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the message to stdout and stderr too if needed...\n  printf(\"%s\\n\", buffer);\n  if (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n\n  if (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n}\n\n\n// Show a hex dump of a buffer to stderr...\nstatic inline void\ntestHexDump(const unsigned char *buffer,// I - Buffer\n            size_t              bytes)\t// I - Number of bytes\n{\n  size_t\ti, j;\t\t\t// Looping vars\n  int\t\tch;\t\t\t// Current ASCII char\n\n\n  if (test_title[0])\n    fputs(\"\\n\", stderr);\n\n  // Show lines of 16 bytes at a time...\n  for (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n\n#  ifdef __cplusplus\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "global_variable",
    "start_line": 93,
    "end_line": 93,
    "code": "tatic bool testsPassed = true;\t",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "global_variable",
    "start_line": 95,
    "end_line": 95,
    "code": "tatic char test_title[1024] = \"\";\t",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "function",
    "start_line": 99,
    "end_line": 118,
    "name": "testBegin",
    "parent": null,
    "hierarchy": "testBegin",
    "code": "tatic inline void\ntestBegin(const char *title, ...)\t// I - printf-style title string\n{\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, title);\n  vsnprintf(test_title, sizeof(test_title), title, ap);\n  va_end(ap);\n\n  // Send the title to stdout and stderr...\n  test_progress = 0;\n\n  printf(\"%s: \", test_title);\n  fflush(stdout);\n\n  if (!isatty(2))\n    fprintf(stderr, \"%s: \", test_title);\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "struct_assignment",
    "start_line": 99,
    "end_line": 118,
    "code": "tatic inline void\ntestBegin(const char *title, ...)\t// I - printf-style title string\n{\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, title);\n  vsnprintf(test_title, sizeof(test_title), title, ap);\n  va_end(ap);\n\n  // Send the title to stdout and stderr...\n  test_progress = 0;\n\n  printf(\"%s: \", test_title);\n  fflush(stdout);\n\n  if (!isatty(2))\n    fprintf(stderr, \"%s: \", test_title);\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "struct_assignment",
    "start_line": 101,
    "end_line": 118,
    "code": "\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, title);\n  vsnprintf(test_title, sizeof(test_title), title, ap);\n  va_end(ap);\n\n  // Send the title to stdout and stderr...\n  test_progress = 0;\n\n  printf(\"%s: \", test_title);\n  fflush(stdout);\n\n  if (!isatty(2))\n    fprintf(stderr, \"%s: \", test_title);\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "function",
    "start_line": 122,
    "end_line": 137,
    "name": "testEnd",
    "parent": null,
    "hierarchy": "testEnd",
    "code": "tatic inline void\ntestEnd(bool pass)\t\t\t// I - `true` if the test passed, `false` otherwise\n{\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  if (!pass)\n    testsPassed = false;\n\n  puts(pass ? \"PASS\" : \"FAIL\");\n  if (!isatty(2))\n    fputs(pass ? \"PASS\\n\" : \"FAIL\\n\", stderr);\n\n  test_title[0] = '\\0';\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "function",
    "start_line": 141,
    "end_line": 163,
    "name": "testEndMessage",
    "parent": null,
    "hierarchy": "testEndMessage",
    "code": "tatic inline void\ntestEndMessage(bool       pass,\t\t// I - `true` if the test passed, `false` otherwise\n               const char *message, ...)// I - printf-style message\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, message);\n  vsnprintf(buffer, sizeof(buffer), message, ap);\n  va_end(ap);\n\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  printf(pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n  if (!isatty(2))\n    fprintf(stderr, pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n\n  test_title[0] = '\\0';\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "struct_assignment",
    "start_line": 141,
    "end_line": 163,
    "code": "tatic inline void\ntestEndMessage(bool       pass,\t\t// I - `true` if the test passed, `false` otherwise\n               const char *message, ...)// I - printf-style message\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the title string\n  va_start(ap, message);\n  vsnprintf(buffer, sizeof(buffer), message, ap);\n  va_end(ap);\n\n  // Send the test result to stdout and stderr\n  if (test_progress)\n    putchar('\\b');\n\n  printf(pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n  if (!isatty(2))\n    fprintf(stderr, pass ? \"PASS (%s)\\n\" : \"FAIL (%s)\\n\", buffer);\n\n  test_title[0] = '\\0';\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "function",
    "start_line": 167,
    "end_line": 176,
    "name": "testProgress",
    "parent": null,
    "hierarchy": "testProgress",
    "code": "tatic inline void\ntestProgress(void)\n{\n  if (test_progress)\n    putchar('\\b');\n  putchar(\"-\\\\|/\"[test_progress & 3]);\n  fflush(stdout);\n\n  test_progress ++;\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "function",
    "start_line": 180,
    "end_line": 197,
    "name": "testError",
    "parent": null,
    "hierarchy": "testError",
    "code": "tatic inline void\ntestError(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the error to stderr...\n  fprintf(stderr, \"%s\\n\", buffer);\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 180,
    "end_line": 197,
    "code": "tatic inline void\ntestError(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the error to stderr...\n  fprintf(stderr, \"%s\\n\", buffer);\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "function",
    "start_line": 201,
    "end_line": 228,
    "name": "testMessage",
    "parent": null,
    "hierarchy": "testMessage",
    "code": "tatic inline void\ntestMessage(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the message to stdout and stderr too if needed...\n  printf(\"%s\\n\", buffer);\n  if (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n\n  if (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 201,
    "end_line": 228,
    "code": "tatic inline void\ntestMessage(const char *error, ...)\t// I - printf-style error string\n{\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the message to stdout and stderr too if needed...\n  printf(\"%s\\n\", buffer);\n  if (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n\n  if (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 203,
    "end_line": 228,
    "code": "\n  char\t\tbuffer[1024];\t\t// Formatted title string\n  va_list\tap;\t\t\t// Pointer to additional arguments\n\n\n  // Format the error string\n  va_start(ap, error);\n  vsnprintf(buffer, sizeof(buffer), error, ap);\n  va_end(ap);\n\n  // Send the message to stdout and stderr too if needed...\n  printf(\"%s\\n\", buffer);\n  if (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n\n  if (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 215,
    "end_line": 219,
    "code": "f (test_title[0])\n  {\n    printf(\"%s: \", test_title);\n    fflush(stdout);\n  }\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 221,
    "end_line": 227,
    "code": "f (!isatty(2))\n  {\n    fprintf(stderr, \"%s\\n\", buffer);\n\n    if (test_title[0])\n      fprintf(stderr, \"%s: \", test_title);\n  }\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "function",
    "start_line": 232,
    "end_line": 276,
    "name": "testHexDump",
    "parent": null,
    "hierarchy": "testHexDump",
    "code": "tatic inline void\ntestHexDump(const unsigned char *buffer,// I - Buffer\n            size_t              bytes)\t// I - Number of bytes\n{\n  size_t\ti, j;\t\t\t// Looping vars\n  int\t\tch;\t\t\t// Current ASCII char\n\n\n  if (test_title[0])\n    fputs(\"\\n\", stderr);\n\n  // Show lines of 16 bytes at a time...\n  for (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "struct_assignment",
    "start_line": 232,
    "end_line": 276,
    "code": "tatic inline void\ntestHexDump(const unsigned char *buffer,// I - Buffer\n            size_t              bytes)\t// I - Number of bytes\n{\n  size_t\ti, j;\t\t\t// Looping vars\n  int\t\tch;\t\t\t// Current ASCII char\n\n\n  if (test_title[0])\n    fputs(\"\\n\", stderr);\n\n  // Show lines of 16 bytes at a time...\n  for (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "struct_assignment",
    "start_line": 235,
    "end_line": 276,
    "code": "\n  size_t\ti, j;\t\t\t// Looping vars\n  int\t\tch;\t\t\t// Current ASCII char\n\n\n  if (test_title[0])\n    fputs(\"\\n\", stderr);\n\n  // Show lines of 16 bytes at a time...\n  for (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n\n  if (test_title[0])\n    fprintf(stderr, \"%s: \", test_title);\n}\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "struct_assignment",
    "start_line": 244,
    "end_line": 272,
    "code": "or (i = 0; i < bytes; i += 16)\n  {\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "struct_assignment",
    "start_line": 245,
    "end_line": 272,
    "code": "\n    // Show the offset...\n    fprintf(stderr, \"%04x \", (unsigned)i);\n\n    // Then up to 16 bytes in hex...\n    for (j = 0; j < 16; j ++)\n    {\n      if ((i + j) < bytes)\n        fprintf(stderr, \" %02x\", buffer[i + j]);\n      else\n        fputs(\"   \", stderr);\n    }\n\n    // Then the ASCII representation of the bytes...\n    fputs(\"  \", stderr);\n\n    for (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n\n    fputc('\\n', stderr);\n  }\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "struct_assignment",
    "start_line": 261,
    "end_line": 269,
    "code": "or (j = 0; j < 16 && (i + j) < bytes; j ++)\n    {\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "struct_assignment",
    "start_line": 262,
    "end_line": 269,
    "code": "\n      ch = buffer[i + j] & 127;\n\n      if (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n    }\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "struct_assignment",
    "start_line": 265,
    "end_line": 268,
    "code": "f (ch < ' ' || ch == 127)\n        fputc('.', stderr);\n      else\n        fputc(ch, stderr);\n",
    "file": "data/codebase/lprint/test.h"
  },
  {
    "type": "preprocessor",
    "start_line": 278,
    "end_line": 278,
    "code": "  ifdef __cplusplus\n",
    "file": "data/codebase/lprint/test.h"
  }
]