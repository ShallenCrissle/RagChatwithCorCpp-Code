[
  {
    "type": "struct_assignment",
    "start_line": 1,
    "end_line": 742,
    "code": "//\n// Main entry for LPrint, a Label Printer Application\n//\n// Copyright \u00a9\u00a02019-2025 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n#include \"lprint.h\"\n#include \"static-resources/lprint-de-strings.h\"\n#include \"static-resources/lprint-en-strings.h\"\n#include \"static-resources/lprint-es-strings.h\"\n#include \"static-resources/lprint-fr-strings.h\"\n#include \"static-resources/lprint-it-strings.h\"\n#include \"static-resources/lprint-css.h\"\n#include \"static-resources/lprint-png.h\"\n#include \"static-resources/lprint-large-png.h\"\n#include \"static-resources/lprint-small-png.h\"\n\n\n//\n// Local types...\n//\n\ntypedef struct lprint_device_s\n{\n  char\t*device_info;\t\t\t// Device description\n  char\t*device_uri;\t\t\t// Device URI\n  char\t*device_id;\t\t\t// Device ID\n} lprint_device_t;\n\n\n//\n// Local functions...\n//\n\nstatic const char\t*autoadd_cb(const char *device_info, const char *device_uri, const char *device_id, void *cbdata);\nstatic lprint_device_t\t*copy_cb(lprint_device_t *src);\nstatic void\t\tcreate_cb(pappl_printer_t *printer, void *cbdata);\nstatic bool\t\tdriver_cb(pappl_system_t *system, const char *driver_name, const char *device_uri, const char *device_id, pappl_pr_driver_data_t *data, ipp_t **attrs, void *cbdata);\nstatic void\t\tfree_cb(lprint_device_t *src);\nstatic int\t\tmatch_id(int num_did, cups_option_t *did, const char *match_id);\nstatic const char\t*mime_cb(const unsigned char *header, size_t headersize, void *data);\nstatic bool\t\tprinter_cb(const char *device_info, const char *device_uri, const char *device_id, cups_array_t *devices);\nstatic pappl_system_t\t*system_cb(int num_options, cups_option_t *options, void *data);\n\n\n//\n// Local globals...\n//\n\nstatic pappl_pr_driver_t\tlprint_drivers[] =\n{\t\t\t\t\t// Driver list\n#ifdef LPRINT_EXPERIMENTAL\n#  include \"lprint-brother.h\"\n#  include \"lprint-cpcl.h\"\n#endif // LPRINT_EXPERIMENTAL\n#include \"lprint-dymo.h\"\n#include \"lprint-epl2.h\"\n#include \"lprint-sii.h\"\n#include \"lprint-tspl.h\"\n#include \"lprint-zpl.h\"\n};\nstatic char\t\t\tlprint_spooldir[1024],\n\t\t\t\t\t// Spool directory\n\t\t\t\tlprint_statefile[1024];\n\t\t\t\t\t// State file\n\n\n//\n// 'main()' - Main entry for LPrint.\n//\n\nint\t\t\t\t\t// O - Exit status\nmain(int  argc,\t\t\t\t// I - Number of command-line arguments\n     char *argv[])\t\t\t// I - Command-line arguments\n{\n  return (papplMainloop(argc, argv,\n                        LPRINT_VERSION,\n                        \"Copyright &copy; 2019-2025 by Michael R Sweet. All Rights Reserved.\",\n                        (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])),\n                        lprint_drivers, autoadd_cb, driver_cb,\n                        /*subcmd_name*/NULL, /*subcmd_cb*/NULL,\n                        system_cb,\n                        /*usage_cb*/NULL,\n                        /*data*/NULL));\n}\n\n\n//\n// 'autoadd_cb()' - Determine the proper driver for a given printer.\n//\n\nstatic const char *\t\t\t// O - Driver name or `NULL` for none\nautoadd_cb(const char *device_info,\t// I - Device information/name (not used)\n           const char *device_uri,\t// I - Device URI\n           const char *device_id,\t// I - IEEE-1284 device ID\n           void       *cbdata)\t\t// I - Callback data (System)\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tscore,\t\t\t// Current driver match score\n\t    \tbest_score = 0,\t\t// Best score\n\t\tnum_did;\t\t// Number of device ID key/value pairs\n  cups_option_t\t*did;\t\t\t// Device ID key/value pairs\n  const char\t*make,\t\t\t// Manufacturer name\n\t\t*best_name = NULL;\t// Best driver\n  char\t\tname[1024] = \"\";\t// Driver name to match\n\n\n  (void)device_info;\n\n  // First parse the device ID and get any potential driver name to match...\n  num_did = papplDeviceParseID(device_id, &did);\n\n  if ((make = cupsGetOption(\"MANUFACTURER\", num_did, did)) == NULL)\n    if ((make = cupsGetOption(\"MANU\", num_did, did)) == NULL)\n      make = cupsGetOption(\"MFG\", num_did, did);\n\n  if (make && !strncasecmp(make, \"Zebra\", 5))\n    lprintZPLQueryDriver((pappl_system_t *)cbdata, device_uri, name, sizeof(name));\n\n  // Then loop through the driver list to find the best match...\n  for (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(name, lprint_drivers[i].name))\n    {\n      // Matching driver name always the best match...\n      best_name = lprint_drivers[i].name;\n      break;\n    }\n\n    if (lprint_drivers[i].device_id)\n    {\n      // See if we have a matching device ID...\n      score = match_id(num_did, did, lprint_drivers[i].device_id);\n      if (score > best_score)\n      {\n        best_score = score;\n        best_name  = lprint_drivers[i].name;\n      }\n    }\n  }\n\n  // Clean up and return...\n  cupsFreeOptions(num_did, did);\n\n  return (best_name);\n}\n\n\n//\n// 'copy_cb()' - Copy a device entry.\n//\n\nstatic lprint_device_t *\t\t// O - New device entry\ncopy_cb(lprint_device_t *src)\t\t// I - Original device entry\n{\n  lprint_device_t\t*dst;\t\t// New device entry\n\n\n  if ((dst = (lprint_device_t *)calloc(1, sizeof(lprint_device_t))) != NULL)\n  {\n    dst->device_info = strdup(src->device_info);\n    dst->device_uri  = strdup(src->device_uri);\n    dst->device_id   = strdup(src->device_id);\n\n    if (!dst->device_info || !dst->device_uri || !dst->device_id)\n    {\n      free_cb(dst);\n      dst = NULL;\n    }\n  }\n\n  return (dst);\n}\n\n\n//\n// 'create_cb()' - Printer creation callback.\n//\n\nstatic void\ncreate_cb(pappl_printer_t *printer,\t// I - Printer\n          void            *cbdata)\t// I - Callback data (not used)\n{\n  char\t\t\tresource[1024];\t// Resource path\n  pappl_pr_driver_data_t data;\t\t// Driver data\n\n\n  (void)cbdata;\n\n  LPRINT_DEBUG(\"create_cb(printer=%p(%s), cbdata=%p)\\n\", printer, printer ? papplPrinterGetName(printer) : \"null\", cbdata);\n\n  // Add custom label media page to replace the standard ready media page...\n  papplSystemRemoveResource(papplPrinterGetSystem(printer), papplPrinterGetPath(printer, \"media\", resource, sizeof(resource)));\n  papplSystemAddResourceCallback(papplPrinterGetSystem(printer), resource, \"text/html\", (pappl_resource_cb_t)lprintMediaUI, printer);\n  LPRINT_DEBUG(\"create_cb: Added new media page for '%s'.\\n\", resource);\n\n  // Load custom media sizes and report them...\n  papplPrinterGetDriverData(printer, &data);\n  lprintMediaLoad(printer, &data);\n  lprintMediaUpdate(printer, &data);\n  papplPrinterSetDriverData(printer, &data, NULL);\n\n  LPRINT_DEBUG(\"create_cb: data.extension=%p\\n\", data.extension);\n}\n\n\n//\n// 'driver_cb()' - Main driver callback.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on error\ndriver_cb(\n    pappl_system_t         *system,\t// I - System\n    const char             *driver_name,// I - Driver name\n    const char             *device_uri,\t// I - Device URI\n    const char             *device_id,\t// I - 1284 device ID\n    pappl_pr_driver_data_t *data,\t// I - Pointer to driver data\n    ipp_t                  **attrs,\t// O - Pointer to driver attributes\n    void                   *cbdata)\t// I - Callback data (not used)\n{\n  bool\tret = false;\t\t\t// Return value\n  int\ti;\t\t\t\t// Looping var\n\n\n  // Copy make/model info...\n  for (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(driver_name, lprint_drivers[i].name))\n    {\n      papplCopyString(data->make_and_model, lprint_drivers[i].description, sizeof(data->make_and_model));\n      break;\n    }\n  }\n\n  // AirPrint version...\n  data->num_features = 1;\n  data->features[0]  = \"airprint-2.1\";\n\n  // Pages per minute (interpret as \"labels per minute\")\n  data->ppm = 60;\n\n  // \"printer-kind\" values...\n  data->kind = PAPPL_KIND_LABEL;\n\n  // Color values...\n  data->color_supported = PAPPL_COLOR_MODE_AUTO | PAPPL_COLOR_MODE_MONOCHROME | PAPPL_COLOR_MODE_BI_LEVEL;\n  data->color_default   = PAPPL_COLOR_MODE_MONOCHROME;\n  data->raster_types    = PAPPL_PWG_RASTER_TYPE_BLACK_1 | PAPPL_PWG_RASTER_TYPE_BLACK_8 | PAPPL_PWG_RASTER_TYPE_SGRAY_8;\n\n  // \"print-quality-default\" value...\n  data->quality_default = IPP_QUALITY_NORMAL;\n\n  // \"sides\" values...\n  data->sides_supported = PAPPL_SIDES_ONE_SIDED;\n  data->sides_default   = PAPPL_SIDES_ONE_SIDED;\n\n  // \"orientation-requested-default\" value...\n  data->orient_default = IPP_ORIENT_NONE;\n\n  // Media capabilities...\n  data->input_face_up  = true;\n  data->output_face_up = true;\n\n  // Standard icons...\n  data->icons[0].data    = lprint_small_png;\n  data->icons[0].datalen = sizeof(lprint_small_png);\n  data->icons[1].data    = lprint_png;\n  data->icons[1].datalen = sizeof(lprint_png);\n  data->icons[2].data    = lprint_large_png;\n  data->icons[2].datalen = sizeof(lprint_large_png);\n\n  // Test page callback...\n  data->testpage_cb = lprintTestPageCB;\n\n  // Use the corresponding sub-driver callback to set things up...\n#ifdef LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"brother_\", 8))\n    ret = lprintBrother(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"cpcl_\", 5))\n    ret = lprintCPCL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else\n#endif // LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"dymo_\", 5))\n    ret = lprintDYMO(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"epl2_\", 5))\n    ret = lprintEPL2(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"sii_\", 4))\n    ret = lprintSII(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"tspl_\", 5))\n    ret = lprintTSPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"zpl_\", 4))\n    ret = lprintZPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n\n  // Update the ready media...\n  for (i = 0; i < data->num_source; i ++)\n  {\n    pwg_media_t *pwg = pwgMediaForPWG(data->media_ready[i].size_name);\n\n    data->media_ready[i].bottom_margin = data->bottom_top;\n    data->media_ready[i].left_margin   = data->left_right;\n    data->media_ready[i].right_margin  = data->left_right;\n    data->media_ready[i].size_width    = pwg->width;\n    data->media_ready[i].size_length   = pwg->length;\n    data->media_ready[i].top_margin    = data->bottom_top;\n    papplCopyString(data->media_ready[i].source, data->source[i], sizeof(data->media_ready[i].source));\n    if (!data->media_ready[i].type[0])\n      papplCopyString(data->media_ready[i].type, data->type[0], sizeof(data->media_ready[i].type));\n  }\n\n  // By default use media from the main source...\n  data->media_default = data->media_ready[0];\n\n  // Return...\n  return (ret);\n}\n\n\n//\n// 'free_cb()' - Free a device entry.\n//\n\nstatic void\nfree_cb(lprint_device_t *dev)\t\t// I - Device entry\n{\n  free(dev->device_info);\n  free(dev->device_uri);\n  free(dev->device_id);\n  free(dev);\n}\n\n\n//\n// 'match_id()' - Compare two IEEE-1284 device IDs and return a score.\n//\n// The score is 2 for each exact match and 1 for a partial match in a comma-\n// delimited field.  Any non-match results in a score of 0.\n//\n\nstatic int\t\t\t\t// O - Score\nmatch_id(int           num_did,\t\t// I - Number of device ID key/value pairs\n         cups_option_t *did,\t\t// I - Device ID key/value pairs\n         const char    *match_id)\t// I - Driver's device ID match string\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tscore = 0,\t\t// Score\n\t\tnum_mid;\t\t// Number of match ID key/value pairs\n  cups_option_t\t*mid,\t\t\t// Match ID key/value pairs\n\t\t*current;\t\t// Current key/value pair\n  const char\t*value,\t\t\t// Device ID value\n\t\t*valptr;\t\t// Pointer into value\n\n\n  // Parse the matching device ID into key/value pairs...\n  if ((num_mid = papplDeviceParseID(match_id, &mid)) == 0)\n    return (0);\n\n  // Loop through the match pairs to find matches (or not)\n  for (i = num_mid, current = mid; i > 0; i --, current ++)\n  {\n    if ((value = cupsGetOption(current->name, num_did, did)) == NULL)\n    {\n      // No match\n      score = 0;\n      break;\n    }\n\n    if (!strcasecmp(current->value, value))\n    {\n      // Full match!\n      score += 2;\n    }\n    else if ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n  }\n\n  cupsFreeOptions(num_mid, mid);\n\n  return (score);\n}\n\n\n//\n// 'mime_cb()' - MIME typing callback...\n//\n\nstatic const char *\t\t\t// O - MIME media type or `NULL` if none\nmime_cb(const unsigned char *header,\t// I - Header data\n        size_t              headersize,\t// I - Size of header data\n        void                *cbdata)\t// I - Callback data (not used)\n{\n  char\ttestpage[] = LPRINT_TESTPAGE_HEADER;\n\t\t\t\t\t// Test page file header\n\n\n  if (headersize >= sizeof(testpage) && !memcmp(header, testpage, sizeof(testpage)))\n    return (LPRINT_TESTPAGE_MIMETYPE);\n  else if (headersize >= 2 && header[0] == '^' && isupper(header[1] & 255))\n    return (LPRINT_ZPL_MIMETYPE);\n  else if (headersize >= 3 && !memcmp(header, \"\\nN\\n\", 3))\n    return (LPRINT_EPL2_MIMETYPE);\n  else\n    return (NULL);\n}\n\n\n//\n// 'printer_cb()' - Try auto-adding printers.\n//\n\nstatic bool\t\t\t\t// O - `false` to continue\nprinter_cb(const char   *device_info,\t// I - Device information\n\t   const char   *device_uri,\t// I - Device URI\n\t   const char   *device_id,\t// I - IEEE-1284 device ID\n\t   cups_array_t *devices)\t// I - Device array\n{\n  lprint_device_t\tdev;\t\t// New device\n\n\n  dev.device_info = (char *)device_info;\n  dev.device_uri  = (char *)device_uri;\n  dev.device_id   = (char *)device_id;\n\n  cupsArrayAdd(devices, &dev);\n\n  return (false);\n}\n\n\n//\n// 'system_cb()' - Setup the system object.\n//\n\nstatic pappl_system_t *\t\t\t// O - System object\nsystem_cb(\n    int           num_options,\t\t// I - Number options\n    cups_option_t *options,\t\t// I - Options\n    void          *data)\t\t// I - Callback data (unused)\n{\n  pappl_system_t\t*system;\t// System object\n  const char\t\t*val,\t\t// Current option value\n\t\t\t*hostname,\t// Hostname, if any\n\t\t\t*listenhost,\t// Listen hostname, if any\n\t\t\t*logfile,\t// Log file, if any\n\t\t\t*spooldir,\t// Spool directory, if any\n\t\t\t*system_name;\t// System name, if any\n  char\t\t\toldfile[1024];\t// Old configuration filename\n  pappl_loglevel_t\tloglevel;\t// Log level\n  int\t\t\tport = 0;\t// Port number, if any\n  pappl_soptions_t\tsoptions = PAPPL_SOPTIONS_MULTI_QUEUE | PAPPL_SOPTIONS_WEB_INTERFACE | PAPPL_SOPTIONS_WEB_LOG | PAPPL_SOPTIONS_WEB_SECURITY | PAPPL_SOPTIONS_WEB_TLS;\n\t\t\t\t\t// System options\n  static pappl_version_t versions[1] =\t// Software versions\n  {\n    { \"LPrint\", \"\", LPRINT_VERSION, { LPRINT_MAJOR_VERSION, LPRINT_MINOR_VERSION, LPRINT_PATCH_VERSION, 0 } }\n  };\n\n\n  (void)data;\n\n  // Parse standard log and server options...\n  if ((val = cupsGetOption(\"log-level\", num_options, options)) != NULL)\n  {\n    if (!strcmp(val, \"fatal\"))\n      loglevel = PAPPL_LOGLEVEL_FATAL;\n    else if (!strcmp(val, \"error\"))\n      loglevel = PAPPL_LOGLEVEL_ERROR;\n    else if (!strcmp(val, \"warn\"))\n      loglevel = PAPPL_LOGLEVEL_WARN;\n    else if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n  }\n  else\n    loglevel = PAPPL_LOGLEVEL_UNSPEC;\n\n  if ((val = cupsGetOption(\"server-options\", num_options, options)) != NULL)\n  {\n    const char\t*valptr;\t\t// Pointer into value\n\n    for (valptr = val; valptr && *valptr;)\n    {\n      if (!strcmp(valptr, \"none\") || !strncmp(valptr, \"none,\", 5))\n        soptions = PAPPL_SOPTIONS_NONE;\n      else if (!strcmp(valptr, \"dnssd-host\") || !strncmp(valptr, \"dnssd-host,\", 11))\n        soptions |= PAPPL_SOPTIONS_DNSSD_HOST;\n      else if (!strcmp(valptr, \"no-multi-queue\") || !strncmp(valptr, \"no-multi-queue,\", 15))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_MULTI_QUEUE;\n      else if (!strcmp(valptr, \"raw-socket\") || !strncmp(valptr, \"raw-socket,\", 11))\n        soptions |= PAPPL_SOPTIONS_RAW_SOCKET;\n      else if (!strcmp(valptr, \"usb-printer\") || !strncmp(valptr, \"usb-printer,\", 12))\n        soptions |= PAPPL_SOPTIONS_USB_PRINTER;\n      else if (!strcmp(valptr, \"no-web-interface\") || !strncmp(valptr, \"no-web-interface,\", 17))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_WEB_INTERFACE;\n      else if (!strcmp(valptr, \"web-log\") || !strncmp(valptr, \"web-log,\", 8))\n        soptions |= PAPPL_SOPTIONS_WEB_LOG;\n      else if (!strcmp(valptr, \"web-network\") || !strncmp(valptr, \"web-network,\", 12))\n        soptions |= PAPPL_SOPTIONS_WEB_NETWORK;\n      else if (!strcmp(valptr, \"web-remote\") || !strncmp(valptr, \"web-remote,\", 11))\n        soptions |= PAPPL_SOPTIONS_WEB_REMOTE;\n      else if (!strcmp(valptr, \"web-security\") || !strncmp(valptr, \"web-security,\", 13))\n        soptions |= PAPPL_SOPTIONS_WEB_SECURITY;\n      else if (!strcmp(valptr, \"no-tls\") || !strncmp(valptr, \"no-tls,\", 7))\n        soptions = (pappl_soptions_t)((soptions | PAPPL_SOPTIONS_NO_TLS) & ~PAPPL_SOPTIONS_WEB_TLS);\n\n      if ((valptr = strchr(valptr, ',')) != NULL)\n        valptr ++;\n    }\n  }\n\n  hostname    = cupsGetOption(\"server-hostname\", num_options, options);\n  listenhost  = cupsGetOption(\"listen-hostname\", num_options, options);\n  logfile     = cupsGetOption(\"log-file\", num_options, options);\n  spooldir    = cupsGetOption(\"spool-directory\", num_options, options);\n  system_name = cupsGetOption(\"system-name\", num_options, options);\n\n  if ((val = cupsGetOption(\"server-port\", num_options, options)) != NULL)\n  {\n    if (!isdigit(*val & 255))\n    {\n      fprintf(stderr, \"lprint: Bad server-port value '%s'.\\n\", val);\n      return (NULL);\n    }\n    else\n      port = atoi(val);\n  }\n\n  // Spool directory and state file...\n  if ((val = getenv(\"SNAP_DATA\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else if ((val = getenv(\"XDG_DATA_HOME\")) != NULL)\n  {\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n  }\n#ifdef _WIN32\n  else if ((val = getenv(\"USERPROFILE\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/AppData/Local/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/AppData/Local/lprint.ini\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/AppData/Local/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else\n  {\n    papplCopyString(oldfile, \"/lprint.ini\", sizeof(oldfile));\n    papplCopyString(lprint_statefile, \"/lprint.state\", sizeof(lprint_statefile));\n  }\n#else\n  else if ((val = getenv(\"HOME\")) != NULL)\n  {\n#  ifdef __APPLE__\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/Library/Application Support/lprint.d\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/Library/Application Support/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n#  else\n    snprintf(oldfile, sizeof(oldfile), \"%s/.config\", val);\n    if (access(oldfile, 0))\n    {\n      if (mkdir(oldfile, 0777))\n      {\n\tperror(oldfile);\n\treturn (NULL);\n      }\n    }\n\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/.config/lprint.state\", val);\n#  endif // __APPLE__\n  }\n  else\n  {\n    papplCopyString(oldfile, \"/etc/lprint.conf\", sizeof(oldfile));\n#  ifdef __APPLE__\n    papplCopyString(lprint_statefile, \"/private/var/lib/lprint.state\", sizeof(lprint_statefile));\n#  else\n    papplCopyString(lprint_statefile, \"/var/lib/lprint.state\", sizeof(lprint_statefile));\n#  endif // __APPLE__\n  }\n#endif // _WIN32\n\n  if (!access(oldfile, 0) && access(lprint_statefile, 0))\n  {\n    // Move old state file to new name...\n    rename(oldfile, lprint_statefile);\n  }\n\n  if (spooldir && access(spooldir, 0))\n  {\n    if (mkdir(spooldir, 0777))\n    {\n      perror(spooldir);\n      return (NULL);\n    }\n  }\n\n  // Create the system object...\n  if ((system = papplSystemCreate(soptions, system_name ? system_name : \"LPrint\", port, \"_print,_universal\", spooldir, logfile ? logfile : \"-\", loglevel, cupsGetOption(\"auth-service\", num_options, options), /* tls_only */false)) == NULL)\n    return (NULL);\n\n  if (!cupsGetOption(\"private-server\", num_options, options))\n  {\n    // Listen for TCP/IP connections...\n    papplSystemAddListeners(system, listenhost);\n  }\n\n  papplSystemSetHostName(system, hostname);\n\n  if ((val = cupsGetOption(\"admin-group\", num_options, options)) != NULL)\n    papplSystemSetAdminGroup(system, val);\n\n  papplSystemSetMIMECallback(system, mime_cb, NULL);\n  papplSystemAddMIMEFilter(system, LPRINT_TESTPAGE_MIMETYPE, \"image/pwg-raster\", lprintTestFilterCB, NULL);\n\n  papplSystemSetPrinterDrivers(system, (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])), lprint_drivers, autoadd_cb, create_cb, driver_cb, system);\n\n  papplSystemAddResourceData(system, \"/favicon.png\", \"image/png\", lprint_small_png, sizeof(lprint_small_png));\n  papplSystemAddResourceData(system, \"/navicon.png\", \"image/png\", lprint_png, sizeof(lprint_png));\n  papplSystemAddResourceString(system, \"/style.css\", \"text/css\", lprint_css);\n  papplSystemAddStringsData(system, \"/de.strings\", \"de\", lprint_de_strings);\n  papplSystemAddStringsData(system, \"/en.strings\", \"en\", lprint_en_strings);\n  papplSystemAddStringsData(system, \"/es.strings\", \"es\", lprint_es_strings);\n  papplSystemAddStringsData(system, \"/fr.strings\", \"fr\", lprint_fr_strings);\n  papplSystemAddStringsData(system, \"/it.strings\", \"it\", lprint_it_strings);\n\n  papplSystemSetFooterHTML(system, \"Copyright &copy; 2019-2024 by Michael R Sweet. All rights reserved.\");\n  papplSystemSetSaveCallback(system, (pappl_save_cb_t)papplSystemSaveState, (void *)lprint_statefile);\n  papplSystemSetVersions(system, (int)(sizeof(versions) / sizeof(versions[0])), versions);\n\n  if (!papplSystemLoadState(system, lprint_statefile))\n  {\n    // No old state, use defaults and auto-add printers...\n    cups_array_t\t*devices;\t// Device array\n    lprint_device_t\t*dev;\t\t// Current device\n\n    papplSystemSetDNSSDName(system, system_name ? system_name : \"LPrint\");\n\n    papplLog(system, PAPPL_LOGLEVEL_INFO, \"Auto-adding printers...\");\n    devices = cupsArrayNew(NULL, NULL, NULL, 0, (cups_acopy_cb_t)copy_cb, (cups_afree_cb_t)free_cb);\n    papplDeviceList(PAPPL_DEVTYPE_USB, (pappl_device_cb_t)printer_cb, devices, papplLogDevice, system);\n\n    for (dev = (lprint_device_t *)cupsArrayGetFirst(devices); dev; dev = (lprint_device_t *)cupsArrayGetNext(devices))\n    {\n      const char *driver_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n\t\t\t\t\t// Driver name, if any\n\n      printf(\"%s (%s;%s) -> %s\\n\", dev->device_info, dev->device_uri, dev->device_id, driver_name);\n\n      if (driver_name)\n      {\n\tchar\tname[128],\t\t// Printer name\n\t\t*nameptr;\t\t// Pointer in name\n\n\t// Zebra puts \"Zebra Technologies ZTC\" on the front of their printer names,\n\t// which is a bit, um, wordy.  Clean up the device info string to use as a\n\t// printer name and drop any trailing \"(ID)\" nonsense if we don't need it.\n\tif (!strncasecmp(dev->device_info, \"Zebra Technologies ZTC \", 23))\n\t  snprintf(name, sizeof(name), \"Zebra %s\", dev->device_info + 23);\n\telse\n\t  papplCopyString(name, dev->device_info, sizeof(name));\n\n\tif ((nameptr = strstr(name, \" (\")) != NULL)\n\t  *nameptr = '\\0';\n\n\tif (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n      }\n    }\n\n    cupsArrayDelete(devices);\n  }\n\n  return (system);\n}\n\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 1,
    "end_line": 742,
    "code": "//\n// Main entry for LPrint, a Label Printer Application\n//\n// Copyright \u00a9\u00a02019-2025 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n#include \"lprint.h\"\n#include \"static-resources/lprint-de-strings.h\"\n#include \"static-resources/lprint-en-strings.h\"\n#include \"static-resources/lprint-es-strings.h\"\n#include \"static-resources/lprint-fr-strings.h\"\n#include \"static-resources/lprint-it-strings.h\"\n#include \"static-resources/lprint-css.h\"\n#include \"static-resources/lprint-png.h\"\n#include \"static-resources/lprint-large-png.h\"\n#include \"static-resources/lprint-small-png.h\"\n\n\n//\n// Local types...\n//\n\ntypedef struct lprint_device_s\n{\n  char\t*device_info;\t\t\t// Device description\n  char\t*device_uri;\t\t\t// Device URI\n  char\t*device_id;\t\t\t// Device ID\n} lprint_device_t;\n\n\n//\n// Local functions...\n//\n\nstatic const char\t*autoadd_cb(const char *device_info, const char *device_uri, const char *device_id, void *cbdata);\nstatic lprint_device_t\t*copy_cb(lprint_device_t *src);\nstatic void\t\tcreate_cb(pappl_printer_t *printer, void *cbdata);\nstatic bool\t\tdriver_cb(pappl_system_t *system, const char *driver_name, const char *device_uri, const char *device_id, pappl_pr_driver_data_t *data, ipp_t **attrs, void *cbdata);\nstatic void\t\tfree_cb(lprint_device_t *src);\nstatic int\t\tmatch_id(int num_did, cups_option_t *did, const char *match_id);\nstatic const char\t*mime_cb(const unsigned char *header, size_t headersize, void *data);\nstatic bool\t\tprinter_cb(const char *device_info, const char *device_uri, const char *device_id, cups_array_t *devices);\nstatic pappl_system_t\t*system_cb(int num_options, cups_option_t *options, void *data);\n\n\n//\n// Local globals...\n//\n\nstatic pappl_pr_driver_t\tlprint_drivers[] =\n{\t\t\t\t\t// Driver list\n#ifdef LPRINT_EXPERIMENTAL\n#  include \"lprint-brother.h\"\n#  include \"lprint-cpcl.h\"\n#endif // LPRINT_EXPERIMENTAL\n#include \"lprint-dymo.h\"\n#include \"lprint-epl2.h\"\n#include \"lprint-sii.h\"\n#include \"lprint-tspl.h\"\n#include \"lprint-zpl.h\"\n};\nstatic char\t\t\tlprint_spooldir[1024],\n\t\t\t\t\t// Spool directory\n\t\t\t\tlprint_statefile[1024];\n\t\t\t\t\t// State file\n\n\n//\n// 'main()' - Main entry for LPrint.\n//\n\nint\t\t\t\t\t// O - Exit status\nmain(int  argc,\t\t\t\t// I - Number of command-line arguments\n     char *argv[])\t\t\t// I - Command-line arguments\n{\n  return (papplMainloop(argc, argv,\n                        LPRINT_VERSION,\n                        \"Copyright &copy; 2019-2025 by Michael R Sweet. All Rights Reserved.\",\n                        (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])),\n                        lprint_drivers, autoadd_cb, driver_cb,\n                        /*subcmd_name*/NULL, /*subcmd_cb*/NULL,\n                        system_cb,\n                        /*usage_cb*/NULL,\n                        /*data*/NULL));\n}\n\n\n//\n// 'autoadd_cb()' - Determine the proper driver for a given printer.\n//\n\nstatic const char *\t\t\t// O - Driver name or `NULL` for none\nautoadd_cb(const char *device_info,\t// I - Device information/name (not used)\n           const char *device_uri,\t// I - Device URI\n           const char *device_id,\t// I - IEEE-1284 device ID\n           void       *cbdata)\t\t// I - Callback data (System)\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tscore,\t\t\t// Current driver match score\n\t    \tbest_score = 0,\t\t// Best score\n\t\tnum_did;\t\t// Number of device ID key/value pairs\n  cups_option_t\t*did;\t\t\t// Device ID key/value pairs\n  const char\t*make,\t\t\t// Manufacturer name\n\t\t*best_name = NULL;\t// Best driver\n  char\t\tname[1024] = \"\";\t// Driver name to match\n\n\n  (void)device_info;\n\n  // First parse the device ID and get any potential driver name to match...\n  num_did = papplDeviceParseID(device_id, &did);\n\n  if ((make = cupsGetOption(\"MANUFACTURER\", num_did, did)) == NULL)\n    if ((make = cupsGetOption(\"MANU\", num_did, did)) == NULL)\n      make = cupsGetOption(\"MFG\", num_did, did);\n\n  if (make && !strncasecmp(make, \"Zebra\", 5))\n    lprintZPLQueryDriver((pappl_system_t *)cbdata, device_uri, name, sizeof(name));\n\n  // Then loop through the driver list to find the best match...\n  for (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(name, lprint_drivers[i].name))\n    {\n      // Matching driver name always the best match...\n      best_name = lprint_drivers[i].name;\n      break;\n    }\n\n    if (lprint_drivers[i].device_id)\n    {\n      // See if we have a matching device ID...\n      score = match_id(num_did, did, lprint_drivers[i].device_id);\n      if (score > best_score)\n      {\n        best_score = score;\n        best_name  = lprint_drivers[i].name;\n      }\n    }\n  }\n\n  // Clean up and return...\n  cupsFreeOptions(num_did, did);\n\n  return (best_name);\n}\n\n\n//\n// 'copy_cb()' - Copy a device entry.\n//\n\nstatic lprint_device_t *\t\t// O - New device entry\ncopy_cb(lprint_device_t *src)\t\t// I - Original device entry\n{\n  lprint_device_t\t*dst;\t\t// New device entry\n\n\n  if ((dst = (lprint_device_t *)calloc(1, sizeof(lprint_device_t))) != NULL)\n  {\n    dst->device_info = strdup(src->device_info);\n    dst->device_uri  = strdup(src->device_uri);\n    dst->device_id   = strdup(src->device_id);\n\n    if (!dst->device_info || !dst->device_uri || !dst->device_id)\n    {\n      free_cb(dst);\n      dst = NULL;\n    }\n  }\n\n  return (dst);\n}\n\n\n//\n// 'create_cb()' - Printer creation callback.\n//\n\nstatic void\ncreate_cb(pappl_printer_t *printer,\t// I - Printer\n          void            *cbdata)\t// I - Callback data (not used)\n{\n  char\t\t\tresource[1024];\t// Resource path\n  pappl_pr_driver_data_t data;\t\t// Driver data\n\n\n  (void)cbdata;\n\n  LPRINT_DEBUG(\"create_cb(printer=%p(%s), cbdata=%p)\\n\", printer, printer ? papplPrinterGetName(printer) : \"null\", cbdata);\n\n  // Add custom label media page to replace the standard ready media page...\n  papplSystemRemoveResource(papplPrinterGetSystem(printer), papplPrinterGetPath(printer, \"media\", resource, sizeof(resource)));\n  papplSystemAddResourceCallback(papplPrinterGetSystem(printer), resource, \"text/html\", (pappl_resource_cb_t)lprintMediaUI, printer);\n  LPRINT_DEBUG(\"create_cb: Added new media page for '%s'.\\n\", resource);\n\n  // Load custom media sizes and report them...\n  papplPrinterGetDriverData(printer, &data);\n  lprintMediaLoad(printer, &data);\n  lprintMediaUpdate(printer, &data);\n  papplPrinterSetDriverData(printer, &data, NULL);\n\n  LPRINT_DEBUG(\"create_cb: data.extension=%p\\n\", data.extension);\n}\n\n\n//\n// 'driver_cb()' - Main driver callback.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on error\ndriver_cb(\n    pappl_system_t         *system,\t// I - System\n    const char             *driver_name,// I - Driver name\n    const char             *device_uri,\t// I - Device URI\n    const char             *device_id,\t// I - 1284 device ID\n    pappl_pr_driver_data_t *data,\t// I - Pointer to driver data\n    ipp_t                  **attrs,\t// O - Pointer to driver attributes\n    void                   *cbdata)\t// I - Callback data (not used)\n{\n  bool\tret = false;\t\t\t// Return value\n  int\ti;\t\t\t\t// Looping var\n\n\n  // Copy make/model info...\n  for (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(driver_name, lprint_drivers[i].name))\n    {\n      papplCopyString(data->make_and_model, lprint_drivers[i].description, sizeof(data->make_and_model));\n      break;\n    }\n  }\n\n  // AirPrint version...\n  data->num_features = 1;\n  data->features[0]  = \"airprint-2.1\";\n\n  // Pages per minute (interpret as \"labels per minute\")\n  data->ppm = 60;\n\n  // \"printer-kind\" values...\n  data->kind = PAPPL_KIND_LABEL;\n\n  // Color values...\n  data->color_supported = PAPPL_COLOR_MODE_AUTO | PAPPL_COLOR_MODE_MONOCHROME | PAPPL_COLOR_MODE_BI_LEVEL;\n  data->color_default   = PAPPL_COLOR_MODE_MONOCHROME;\n  data->raster_types    = PAPPL_PWG_RASTER_TYPE_BLACK_1 | PAPPL_PWG_RASTER_TYPE_BLACK_8 | PAPPL_PWG_RASTER_TYPE_SGRAY_8;\n\n  // \"print-quality-default\" value...\n  data->quality_default = IPP_QUALITY_NORMAL;\n\n  // \"sides\" values...\n  data->sides_supported = PAPPL_SIDES_ONE_SIDED;\n  data->sides_default   = PAPPL_SIDES_ONE_SIDED;\n\n  // \"orientation-requested-default\" value...\n  data->orient_default = IPP_ORIENT_NONE;\n\n  // Media capabilities...\n  data->input_face_up  = true;\n  data->output_face_up = true;\n\n  // Standard icons...\n  data->icons[0].data    = lprint_small_png;\n  data->icons[0].datalen = sizeof(lprint_small_png);\n  data->icons[1].data    = lprint_png;\n  data->icons[1].datalen = sizeof(lprint_png);\n  data->icons[2].data    = lprint_large_png;\n  data->icons[2].datalen = sizeof(lprint_large_png);\n\n  // Test page callback...\n  data->testpage_cb = lprintTestPageCB;\n\n  // Use the corresponding sub-driver callback to set things up...\n#ifdef LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"brother_\", 8))\n    ret = lprintBrother(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"cpcl_\", 5))\n    ret = lprintCPCL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else\n#endif // LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"dymo_\", 5))\n    ret = lprintDYMO(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"epl2_\", 5))\n    ret = lprintEPL2(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"sii_\", 4))\n    ret = lprintSII(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"tspl_\", 5))\n    ret = lprintTSPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"zpl_\", 4))\n    ret = lprintZPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n\n  // Update the ready media...\n  for (i = 0; i < data->num_source; i ++)\n  {\n    pwg_media_t *pwg = pwgMediaForPWG(data->media_ready[i].size_name);\n\n    data->media_ready[i].bottom_margin = data->bottom_top;\n    data->media_ready[i].left_margin   = data->left_right;\n    data->media_ready[i].right_margin  = data->left_right;\n    data->media_ready[i].size_width    = pwg->width;\n    data->media_ready[i].size_length   = pwg->length;\n    data->media_ready[i].top_margin    = data->bottom_top;\n    papplCopyString(data->media_ready[i].source, data->source[i], sizeof(data->media_ready[i].source));\n    if (!data->media_ready[i].type[0])\n      papplCopyString(data->media_ready[i].type, data->type[0], sizeof(data->media_ready[i].type));\n  }\n\n  // By default use media from the main source...\n  data->media_default = data->media_ready[0];\n\n  // Return...\n  return (ret);\n}\n\n\n//\n// 'free_cb()' - Free a device entry.\n//\n\nstatic void\nfree_cb(lprint_device_t *dev)\t\t// I - Device entry\n{\n  free(dev->device_info);\n  free(dev->device_uri);\n  free(dev->device_id);\n  free(dev);\n}\n\n\n//\n// 'match_id()' - Compare two IEEE-1284 device IDs and return a score.\n//\n// The score is 2 for each exact match and 1 for a partial match in a comma-\n// delimited field.  Any non-match results in a score of 0.\n//\n\nstatic int\t\t\t\t// O - Score\nmatch_id(int           num_did,\t\t// I - Number of device ID key/value pairs\n         cups_option_t *did,\t\t// I - Device ID key/value pairs\n         const char    *match_id)\t// I - Driver's device ID match string\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tscore = 0,\t\t// Score\n\t\tnum_mid;\t\t// Number of match ID key/value pairs\n  cups_option_t\t*mid,\t\t\t// Match ID key/value pairs\n\t\t*current;\t\t// Current key/value pair\n  const char\t*value,\t\t\t// Device ID value\n\t\t*valptr;\t\t// Pointer into value\n\n\n  // Parse the matching device ID into key/value pairs...\n  if ((num_mid = papplDeviceParseID(match_id, &mid)) == 0)\n    return (0);\n\n  // Loop through the match pairs to find matches (or not)\n  for (i = num_mid, current = mid; i > 0; i --, current ++)\n  {\n    if ((value = cupsGetOption(current->name, num_did, did)) == NULL)\n    {\n      // No match\n      score = 0;\n      break;\n    }\n\n    if (!strcasecmp(current->value, value))\n    {\n      // Full match!\n      score += 2;\n    }\n    else if ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n  }\n\n  cupsFreeOptions(num_mid, mid);\n\n  return (score);\n}\n\n\n//\n// 'mime_cb()' - MIME typing callback...\n//\n\nstatic const char *\t\t\t// O - MIME media type or `NULL` if none\nmime_cb(const unsigned char *header,\t// I - Header data\n        size_t              headersize,\t// I - Size of header data\n        void                *cbdata)\t// I - Callback data (not used)\n{\n  char\ttestpage[] = LPRINT_TESTPAGE_HEADER;\n\t\t\t\t\t// Test page file header\n\n\n  if (headersize >= sizeof(testpage) && !memcmp(header, testpage, sizeof(testpage)))\n    return (LPRINT_TESTPAGE_MIMETYPE);\n  else if (headersize >= 2 && header[0] == '^' && isupper(header[1] & 255))\n    return (LPRINT_ZPL_MIMETYPE);\n  else if (headersize >= 3 && !memcmp(header, \"\\nN\\n\", 3))\n    return (LPRINT_EPL2_MIMETYPE);\n  else\n    return (NULL);\n}\n\n\n//\n// 'printer_cb()' - Try auto-adding printers.\n//\n\nstatic bool\t\t\t\t// O - `false` to continue\nprinter_cb(const char   *device_info,\t// I - Device information\n\t   const char   *device_uri,\t// I - Device URI\n\t   const char   *device_id,\t// I - IEEE-1284 device ID\n\t   cups_array_t *devices)\t// I - Device array\n{\n  lprint_device_t\tdev;\t\t// New device\n\n\n  dev.device_info = (char *)device_info;\n  dev.device_uri  = (char *)device_uri;\n  dev.device_id   = (char *)device_id;\n\n  cupsArrayAdd(devices, &dev);\n\n  return (false);\n}\n\n\n//\n// 'system_cb()' - Setup the system object.\n//\n\nstatic pappl_system_t *\t\t\t// O - System object\nsystem_cb(\n    int           num_options,\t\t// I - Number options\n    cups_option_t *options,\t\t// I - Options\n    void          *data)\t\t// I - Callback data (unused)\n{\n  pappl_system_t\t*system;\t// System object\n  const char\t\t*val,\t\t// Current option value\n\t\t\t*hostname,\t// Hostname, if any\n\t\t\t*listenhost,\t// Listen hostname, if any\n\t\t\t*logfile,\t// Log file, if any\n\t\t\t*spooldir,\t// Spool directory, if any\n\t\t\t*system_name;\t// System name, if any\n  char\t\t\toldfile[1024];\t// Old configuration filename\n  pappl_loglevel_t\tloglevel;\t// Log level\n  int\t\t\tport = 0;\t// Port number, if any\n  pappl_soptions_t\tsoptions = PAPPL_SOPTIONS_MULTI_QUEUE | PAPPL_SOPTIONS_WEB_INTERFACE | PAPPL_SOPTIONS_WEB_LOG | PAPPL_SOPTIONS_WEB_SECURITY | PAPPL_SOPTIONS_WEB_TLS;\n\t\t\t\t\t// System options\n  static pappl_version_t versions[1] =\t// Software versions\n  {\n    { \"LPrint\", \"\", LPRINT_VERSION, { LPRINT_MAJOR_VERSION, LPRINT_MINOR_VERSION, LPRINT_PATCH_VERSION, 0 } }\n  };\n\n\n  (void)data;\n\n  // Parse standard log and server options...\n  if ((val = cupsGetOption(\"log-level\", num_options, options)) != NULL)\n  {\n    if (!strcmp(val, \"fatal\"))\n      loglevel = PAPPL_LOGLEVEL_FATAL;\n    else if (!strcmp(val, \"error\"))\n      loglevel = PAPPL_LOGLEVEL_ERROR;\n    else if (!strcmp(val, \"warn\"))\n      loglevel = PAPPL_LOGLEVEL_WARN;\n    else if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n  }\n  else\n    loglevel = PAPPL_LOGLEVEL_UNSPEC;\n\n  if ((val = cupsGetOption(\"server-options\", num_options, options)) != NULL)\n  {\n    const char\t*valptr;\t\t// Pointer into value\n\n    for (valptr = val; valptr && *valptr;)\n    {\n      if (!strcmp(valptr, \"none\") || !strncmp(valptr, \"none,\", 5))\n        soptions = PAPPL_SOPTIONS_NONE;\n      else if (!strcmp(valptr, \"dnssd-host\") || !strncmp(valptr, \"dnssd-host,\", 11))\n        soptions |= PAPPL_SOPTIONS_DNSSD_HOST;\n      else if (!strcmp(valptr, \"no-multi-queue\") || !strncmp(valptr, \"no-multi-queue,\", 15))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_MULTI_QUEUE;\n      else if (!strcmp(valptr, \"raw-socket\") || !strncmp(valptr, \"raw-socket,\", 11))\n        soptions |= PAPPL_SOPTIONS_RAW_SOCKET;\n      else if (!strcmp(valptr, \"usb-printer\") || !strncmp(valptr, \"usb-printer,\", 12))\n        soptions |= PAPPL_SOPTIONS_USB_PRINTER;\n      else if (!strcmp(valptr, \"no-web-interface\") || !strncmp(valptr, \"no-web-interface,\", 17))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_WEB_INTERFACE;\n      else if (!strcmp(valptr, \"web-log\") || !strncmp(valptr, \"web-log,\", 8))\n        soptions |= PAPPL_SOPTIONS_WEB_LOG;\n      else if (!strcmp(valptr, \"web-network\") || !strncmp(valptr, \"web-network,\", 12))\n        soptions |= PAPPL_SOPTIONS_WEB_NETWORK;\n      else if (!strcmp(valptr, \"web-remote\") || !strncmp(valptr, \"web-remote,\", 11))\n        soptions |= PAPPL_SOPTIONS_WEB_REMOTE;\n      else if (!strcmp(valptr, \"web-security\") || !strncmp(valptr, \"web-security,\", 13))\n        soptions |= PAPPL_SOPTIONS_WEB_SECURITY;\n      else if (!strcmp(valptr, \"no-tls\") || !strncmp(valptr, \"no-tls,\", 7))\n        soptions = (pappl_soptions_t)((soptions | PAPPL_SOPTIONS_NO_TLS) & ~PAPPL_SOPTIONS_WEB_TLS);\n\n      if ((valptr = strchr(valptr, ',')) != NULL)\n        valptr ++;\n    }\n  }\n\n  hostname    = cupsGetOption(\"server-hostname\", num_options, options);\n  listenhost  = cupsGetOption(\"listen-hostname\", num_options, options);\n  logfile     = cupsGetOption(\"log-file\", num_options, options);\n  spooldir    = cupsGetOption(\"spool-directory\", num_options, options);\n  system_name = cupsGetOption(\"system-name\", num_options, options);\n\n  if ((val = cupsGetOption(\"server-port\", num_options, options)) != NULL)\n  {\n    if (!isdigit(*val & 255))\n    {\n      fprintf(stderr, \"lprint: Bad server-port value '%s'.\\n\", val);\n      return (NULL);\n    }\n    else\n      port = atoi(val);\n  }\n\n  // Spool directory and state file...\n  if ((val = getenv(\"SNAP_DATA\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else if ((val = getenv(\"XDG_DATA_HOME\")) != NULL)\n  {\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n  }\n#ifdef _WIN32\n  else if ((val = getenv(\"USERPROFILE\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/AppData/Local/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/AppData/Local/lprint.ini\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/AppData/Local/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else\n  {\n    papplCopyString(oldfile, \"/lprint.ini\", sizeof(oldfile));\n    papplCopyString(lprint_statefile, \"/lprint.state\", sizeof(lprint_statefile));\n  }\n#else\n  else if ((val = getenv(\"HOME\")) != NULL)\n  {\n#  ifdef __APPLE__\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/Library/Application Support/lprint.d\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/Library/Application Support/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n#  else\n    snprintf(oldfile, sizeof(oldfile), \"%s/.config\", val);\n    if (access(oldfile, 0))\n    {\n      if (mkdir(oldfile, 0777))\n      {\n\tperror(oldfile);\n\treturn (NULL);\n      }\n    }\n\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/.config/lprint.state\", val);\n#  endif // __APPLE__\n  }\n  else\n  {\n    papplCopyString(oldfile, \"/etc/lprint.conf\", sizeof(oldfile));\n#  ifdef __APPLE__\n    papplCopyString(lprint_statefile, \"/private/var/lib/lprint.state\", sizeof(lprint_statefile));\n#  else\n    papplCopyString(lprint_statefile, \"/var/lib/lprint.state\", sizeof(lprint_statefile));\n#  endif // __APPLE__\n  }\n#endif // _WIN32\n\n  if (!access(oldfile, 0) && access(lprint_statefile, 0))\n  {\n    // Move old state file to new name...\n    rename(oldfile, lprint_statefile);\n  }\n\n  if (spooldir && access(spooldir, 0))\n  {\n    if (mkdir(spooldir, 0777))\n    {\n      perror(spooldir);\n      return (NULL);\n    }\n  }\n\n  // Create the system object...\n  if ((system = papplSystemCreate(soptions, system_name ? system_name : \"LPrint\", port, \"_print,_universal\", spooldir, logfile ? logfile : \"-\", loglevel, cupsGetOption(\"auth-service\", num_options, options), /* tls_only */false)) == NULL)\n    return (NULL);\n\n  if (!cupsGetOption(\"private-server\", num_options, options))\n  {\n    // Listen for TCP/IP connections...\n    papplSystemAddListeners(system, listenhost);\n  }\n\n  papplSystemSetHostName(system, hostname);\n\n  if ((val = cupsGetOption(\"admin-group\", num_options, options)) != NULL)\n    papplSystemSetAdminGroup(system, val);\n\n  papplSystemSetMIMECallback(system, mime_cb, NULL);\n  papplSystemAddMIMEFilter(system, LPRINT_TESTPAGE_MIMETYPE, \"image/pwg-raster\", lprintTestFilterCB, NULL);\n\n  papplSystemSetPrinterDrivers(system, (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])), lprint_drivers, autoadd_cb, create_cb, driver_cb, system);\n\n  papplSystemAddResourceData(system, \"/favicon.png\", \"image/png\", lprint_small_png, sizeof(lprint_small_png));\n  papplSystemAddResourceData(system, \"/navicon.png\", \"image/png\", lprint_png, sizeof(lprint_png));\n  papplSystemAddResourceString(system, \"/style.css\", \"text/css\", lprint_css);\n  papplSystemAddStringsData(system, \"/de.strings\", \"de\", lprint_de_strings);\n  papplSystemAddStringsData(system, \"/en.strings\", \"en\", lprint_en_strings);\n  papplSystemAddStringsData(system, \"/es.strings\", \"es\", lprint_es_strings);\n  papplSystemAddStringsData(system, \"/fr.strings\", \"fr\", lprint_fr_strings);\n  papplSystemAddStringsData(system, \"/it.strings\", \"it\", lprint_it_strings);\n\n  papplSystemSetFooterHTML(system, \"Copyright &copy; 2019-2024 by Michael R Sweet. All rights reserved.\");\n  papplSystemSetSaveCallback(system, (pappl_save_cb_t)papplSystemSaveState, (void *)lprint_statefile);\n  papplSystemSetVersions(system, (int)(sizeof(versions) / sizeof(versions[0])), versions);\n\n  if (!papplSystemLoadState(system, lprint_statefile))\n  {\n    // No old state, use defaults and auto-add printers...\n    cups_array_t\t*devices;\t// Device array\n    lprint_device_t\t*dev;\t\t// Current device\n\n    papplSystemSetDNSSDName(system, system_name ? system_name : \"LPrint\");\n\n    papplLog(system, PAPPL_LOGLEVEL_INFO, \"Auto-adding printers...\");\n    devices = cupsArrayNew(NULL, NULL, NULL, 0, (cups_acopy_cb_t)copy_cb, (cups_afree_cb_t)free_cb);\n    papplDeviceList(PAPPL_DEVTYPE_USB, (pappl_device_cb_t)printer_cb, devices, papplLogDevice, system);\n\n    for (dev = (lprint_device_t *)cupsArrayGetFirst(devices); dev; dev = (lprint_device_t *)cupsArrayGetNext(devices))\n    {\n      const char *driver_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n\t\t\t\t\t// Driver name, if any\n\n      printf(\"%s (%s;%s) -> %s\\n\", dev->device_info, dev->device_uri, dev->device_id, driver_name);\n\n      if (driver_name)\n      {\n\tchar\tname[128],\t\t// Printer name\n\t\t*nameptr;\t\t// Pointer in name\n\n\t// Zebra puts \"Zebra Technologies ZTC\" on the front of their printer names,\n\t// which is a bit, um, wordy.  Clean up the device info string to use as a\n\t// printer name and drop any trailing \"(ID)\" nonsense if we don't need it.\n\tif (!strncasecmp(dev->device_info, \"Zebra Technologies ZTC \", 23))\n\t  snprintf(name, sizeof(name), \"Zebra %s\", dev->device_info + 23);\n\telse\n\t  papplCopyString(name, dev->device_info, sizeof(name));\n\n\tif ((nameptr = strstr(name, \" (\")) != NULL)\n\t  *nameptr = '\\0';\n\n\tif (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n      }\n    }\n\n    cupsArrayDelete(devices);\n  }\n\n  return (system);\n}\n\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 1,
    "end_line": 742,
    "code": "//\n// Main entry for LPrint, a Label Printer Application\n//\n// Copyright \u00a9\u00a02019-2025 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n#include \"lprint.h\"\n#include \"static-resources/lprint-de-strings.h\"\n#include \"static-resources/lprint-en-strings.h\"\n#include \"static-resources/lprint-es-strings.h\"\n#include \"static-resources/lprint-fr-strings.h\"\n#include \"static-resources/lprint-it-strings.h\"\n#include \"static-resources/lprint-css.h\"\n#include \"static-resources/lprint-png.h\"\n#include \"static-resources/lprint-large-png.h\"\n#include \"static-resources/lprint-small-png.h\"\n\n\n//\n// Local types...\n//\n\ntypedef struct lprint_device_s\n{\n  char\t*device_info;\t\t\t// Device description\n  char\t*device_uri;\t\t\t// Device URI\n  char\t*device_id;\t\t\t// Device ID\n} lprint_device_t;\n\n\n//\n// Local functions...\n//\n\nstatic const char\t*autoadd_cb(const char *device_info, const char *device_uri, const char *device_id, void *cbdata);\nstatic lprint_device_t\t*copy_cb(lprint_device_t *src);\nstatic void\t\tcreate_cb(pappl_printer_t *printer, void *cbdata);\nstatic bool\t\tdriver_cb(pappl_system_t *system, const char *driver_name, const char *device_uri, const char *device_id, pappl_pr_driver_data_t *data, ipp_t **attrs, void *cbdata);\nstatic void\t\tfree_cb(lprint_device_t *src);\nstatic int\t\tmatch_id(int num_did, cups_option_t *did, const char *match_id);\nstatic const char\t*mime_cb(const unsigned char *header, size_t headersize, void *data);\nstatic bool\t\tprinter_cb(const char *device_info, const char *device_uri, const char *device_id, cups_array_t *devices);\nstatic pappl_system_t\t*system_cb(int num_options, cups_option_t *options, void *data);\n\n\n//\n// Local globals...\n//\n\nstatic pappl_pr_driver_t\tlprint_drivers[] =\n{\t\t\t\t\t// Driver list\n#ifdef LPRINT_EXPERIMENTAL\n#  include \"lprint-brother.h\"\n#  include \"lprint-cpcl.h\"\n#endif // LPRINT_EXPERIMENTAL\n#include \"lprint-dymo.h\"\n#include \"lprint-epl2.h\"\n#include \"lprint-sii.h\"\n#include \"lprint-tspl.h\"\n#include \"lprint-zpl.h\"\n};\nstatic char\t\t\tlprint_spooldir[1024],\n\t\t\t\t\t// Spool directory\n\t\t\t\tlprint_statefile[1024];\n\t\t\t\t\t// State file\n\n\n//\n// 'main()' - Main entry for LPrint.\n//\n\nint\t\t\t\t\t// O - Exit status\nmain(int  argc,\t\t\t\t// I - Number of command-line arguments\n     char *argv[])\t\t\t// I - Command-line arguments\n{\n  return (papplMainloop(argc, argv,\n                        LPRINT_VERSION,\n                        \"Copyright &copy; 2019-2025 by Michael R Sweet. All Rights Reserved.\",\n                        (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])),\n                        lprint_drivers, autoadd_cb, driver_cb,\n                        /*subcmd_name*/NULL, /*subcmd_cb*/NULL,\n                        system_cb,\n                        /*usage_cb*/NULL,\n                        /*data*/NULL));\n}\n\n\n//\n// 'autoadd_cb()' - Determine the proper driver for a given printer.\n//\n\nstatic const char *\t\t\t// O - Driver name or `NULL` for none\nautoadd_cb(const char *device_info,\t// I - Device information/name (not used)\n           const char *device_uri,\t// I - Device URI\n           const char *device_id,\t// I - IEEE-1284 device ID\n           void       *cbdata)\t\t// I - Callback data (System)\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tscore,\t\t\t// Current driver match score\n\t    \tbest_score = 0,\t\t// Best score\n\t\tnum_did;\t\t// Number of device ID key/value pairs\n  cups_option_t\t*did;\t\t\t// Device ID key/value pairs\n  const char\t*make,\t\t\t// Manufacturer name\n\t\t*best_name = NULL;\t// Best driver\n  char\t\tname[1024] = \"\";\t// Driver name to match\n\n\n  (void)device_info;\n\n  // First parse the device ID and get any potential driver name to match...\n  num_did = papplDeviceParseID(device_id, &did);\n\n  if ((make = cupsGetOption(\"MANUFACTURER\", num_did, did)) == NULL)\n    if ((make = cupsGetOption(\"MANU\", num_did, did)) == NULL)\n      make = cupsGetOption(\"MFG\", num_did, did);\n\n  if (make && !strncasecmp(make, \"Zebra\", 5))\n    lprintZPLQueryDriver((pappl_system_t *)cbdata, device_uri, name, sizeof(name));\n\n  // Then loop through the driver list to find the best match...\n  for (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(name, lprint_drivers[i].name))\n    {\n      // Matching driver name always the best match...\n      best_name = lprint_drivers[i].name;\n      break;\n    }\n\n    if (lprint_drivers[i].device_id)\n    {\n      // See if we have a matching device ID...\n      score = match_id(num_did, did, lprint_drivers[i].device_id);\n      if (score > best_score)\n      {\n        best_score = score;\n        best_name  = lprint_drivers[i].name;\n      }\n    }\n  }\n\n  // Clean up and return...\n  cupsFreeOptions(num_did, did);\n\n  return (best_name);\n}\n\n\n//\n// 'copy_cb()' - Copy a device entry.\n//\n\nstatic lprint_device_t *\t\t// O - New device entry\ncopy_cb(lprint_device_t *src)\t\t// I - Original device entry\n{\n  lprint_device_t\t*dst;\t\t// New device entry\n\n\n  if ((dst = (lprint_device_t *)calloc(1, sizeof(lprint_device_t))) != NULL)\n  {\n    dst->device_info = strdup(src->device_info);\n    dst->device_uri  = strdup(src->device_uri);\n    dst->device_id   = strdup(src->device_id);\n\n    if (!dst->device_info || !dst->device_uri || !dst->device_id)\n    {\n      free_cb(dst);\n      dst = NULL;\n    }\n  }\n\n  return (dst);\n}\n\n\n//\n// 'create_cb()' - Printer creation callback.\n//\n\nstatic void\ncreate_cb(pappl_printer_t *printer,\t// I - Printer\n          void            *cbdata)\t// I - Callback data (not used)\n{\n  char\t\t\tresource[1024];\t// Resource path\n  pappl_pr_driver_data_t data;\t\t// Driver data\n\n\n  (void)cbdata;\n\n  LPRINT_DEBUG(\"create_cb(printer=%p(%s), cbdata=%p)\\n\", printer, printer ? papplPrinterGetName(printer) : \"null\", cbdata);\n\n  // Add custom label media page to replace the standard ready media page...\n  papplSystemRemoveResource(papplPrinterGetSystem(printer), papplPrinterGetPath(printer, \"media\", resource, sizeof(resource)));\n  papplSystemAddResourceCallback(papplPrinterGetSystem(printer), resource, \"text/html\", (pappl_resource_cb_t)lprintMediaUI, printer);\n  LPRINT_DEBUG(\"create_cb: Added new media page for '%s'.\\n\", resource);\n\n  // Load custom media sizes and report them...\n  papplPrinterGetDriverData(printer, &data);\n  lprintMediaLoad(printer, &data);\n  lprintMediaUpdate(printer, &data);\n  papplPrinterSetDriverData(printer, &data, NULL);\n\n  LPRINT_DEBUG(\"create_cb: data.extension=%p\\n\", data.extension);\n}\n\n\n//\n// 'driver_cb()' - Main driver callback.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on error\ndriver_cb(\n    pappl_system_t         *system,\t// I - System\n    const char             *driver_name,// I - Driver name\n    const char             *device_uri,\t// I - Device URI\n    const char             *device_id,\t// I - 1284 device ID\n    pappl_pr_driver_data_t *data,\t// I - Pointer to driver data\n    ipp_t                  **attrs,\t// O - Pointer to driver attributes\n    void                   *cbdata)\t// I - Callback data (not used)\n{\n  bool\tret = false;\t\t\t// Return value\n  int\ti;\t\t\t\t// Looping var\n\n\n  // Copy make/model info...\n  for (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(driver_name, lprint_drivers[i].name))\n    {\n      papplCopyString(data->make_and_model, lprint_drivers[i].description, sizeof(data->make_and_model));\n      break;\n    }\n  }\n\n  // AirPrint version...\n  data->num_features = 1;\n  data->features[0]  = \"airprint-2.1\";\n\n  // Pages per minute (interpret as \"labels per minute\")\n  data->ppm = 60;\n\n  // \"printer-kind\" values...\n  data->kind = PAPPL_KIND_LABEL;\n\n  // Color values...\n  data->color_supported = PAPPL_COLOR_MODE_AUTO | PAPPL_COLOR_MODE_MONOCHROME | PAPPL_COLOR_MODE_BI_LEVEL;\n  data->color_default   = PAPPL_COLOR_MODE_MONOCHROME;\n  data->raster_types    = PAPPL_PWG_RASTER_TYPE_BLACK_1 | PAPPL_PWG_RASTER_TYPE_BLACK_8 | PAPPL_PWG_RASTER_TYPE_SGRAY_8;\n\n  // \"print-quality-default\" value...\n  data->quality_default = IPP_QUALITY_NORMAL;\n\n  // \"sides\" values...\n  data->sides_supported = PAPPL_SIDES_ONE_SIDED;\n  data->sides_default   = PAPPL_SIDES_ONE_SIDED;\n\n  // \"orientation-requested-default\" value...\n  data->orient_default = IPP_ORIENT_NONE;\n\n  // Media capabilities...\n  data->input_face_up  = true;\n  data->output_face_up = true;\n\n  // Standard icons...\n  data->icons[0].data    = lprint_small_png;\n  data->icons[0].datalen = sizeof(lprint_small_png);\n  data->icons[1].data    = lprint_png;\n  data->icons[1].datalen = sizeof(lprint_png);\n  data->icons[2].data    = lprint_large_png;\n  data->icons[2].datalen = sizeof(lprint_large_png);\n\n  // Test page callback...\n  data->testpage_cb = lprintTestPageCB;\n\n  // Use the corresponding sub-driver callback to set things up...\n#ifdef LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"brother_\", 8))\n    ret = lprintBrother(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"cpcl_\", 5))\n    ret = lprintCPCL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else\n#endif // LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"dymo_\", 5))\n    ret = lprintDYMO(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"epl2_\", 5))\n    ret = lprintEPL2(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"sii_\", 4))\n    ret = lprintSII(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"tspl_\", 5))\n    ret = lprintTSPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"zpl_\", 4))\n    ret = lprintZPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n\n  // Update the ready media...\n  for (i = 0; i < data->num_source; i ++)\n  {\n    pwg_media_t *pwg = pwgMediaForPWG(data->media_ready[i].size_name);\n\n    data->media_ready[i].bottom_margin = data->bottom_top;\n    data->media_ready[i].left_margin   = data->left_right;\n    data->media_ready[i].right_margin  = data->left_right;\n    data->media_ready[i].size_width    = pwg->width;\n    data->media_ready[i].size_length   = pwg->length;\n    data->media_ready[i].top_margin    = data->bottom_top;\n    papplCopyString(data->media_ready[i].source, data->source[i], sizeof(data->media_ready[i].source));\n    if (!data->media_ready[i].type[0])\n      papplCopyString(data->media_ready[i].type, data->type[0], sizeof(data->media_ready[i].type));\n  }\n\n  // By default use media from the main source...\n  data->media_default = data->media_ready[0];\n\n  // Return...\n  return (ret);\n}\n\n\n//\n// 'free_cb()' - Free a device entry.\n//\n\nstatic void\nfree_cb(lprint_device_t *dev)\t\t// I - Device entry\n{\n  free(dev->device_info);\n  free(dev->device_uri);\n  free(dev->device_id);\n  free(dev);\n}\n\n\n//\n// 'match_id()' - Compare two IEEE-1284 device IDs and return a score.\n//\n// The score is 2 for each exact match and 1 for a partial match in a comma-\n// delimited field.  Any non-match results in a score of 0.\n//\n\nstatic int\t\t\t\t// O - Score\nmatch_id(int           num_did,\t\t// I - Number of device ID key/value pairs\n         cups_option_t *did,\t\t// I - Device ID key/value pairs\n         const char    *match_id)\t// I - Driver's device ID match string\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tscore = 0,\t\t// Score\n\t\tnum_mid;\t\t// Number of match ID key/value pairs\n  cups_option_t\t*mid,\t\t\t// Match ID key/value pairs\n\t\t*current;\t\t// Current key/value pair\n  const char\t*value,\t\t\t// Device ID value\n\t\t*valptr;\t\t// Pointer into value\n\n\n  // Parse the matching device ID into key/value pairs...\n  if ((num_mid = papplDeviceParseID(match_id, &mid)) == 0)\n    return (0);\n\n  // Loop through the match pairs to find matches (or not)\n  for (i = num_mid, current = mid; i > 0; i --, current ++)\n  {\n    if ((value = cupsGetOption(current->name, num_did, did)) == NULL)\n    {\n      // No match\n      score = 0;\n      break;\n    }\n\n    if (!strcasecmp(current->value, value))\n    {\n      // Full match!\n      score += 2;\n    }\n    else if ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n  }\n\n  cupsFreeOptions(num_mid, mid);\n\n  return (score);\n}\n\n\n//\n// 'mime_cb()' - MIME typing callback...\n//\n\nstatic const char *\t\t\t// O - MIME media type or `NULL` if none\nmime_cb(const unsigned char *header,\t// I - Header data\n        size_t              headersize,\t// I - Size of header data\n        void                *cbdata)\t// I - Callback data (not used)\n{\n  char\ttestpage[] = LPRINT_TESTPAGE_HEADER;\n\t\t\t\t\t// Test page file header\n\n\n  if (headersize >= sizeof(testpage) && !memcmp(header, testpage, sizeof(testpage)))\n    return (LPRINT_TESTPAGE_MIMETYPE);\n  else if (headersize >= 2 && header[0] == '^' && isupper(header[1] & 255))\n    return (LPRINT_ZPL_MIMETYPE);\n  else if (headersize >= 3 && !memcmp(header, \"\\nN\\n\", 3))\n    return (LPRINT_EPL2_MIMETYPE);\n  else\n    return (NULL);\n}\n\n\n//\n// 'printer_cb()' - Try auto-adding printers.\n//\n\nstatic bool\t\t\t\t// O - `false` to continue\nprinter_cb(const char   *device_info,\t// I - Device information\n\t   const char   *device_uri,\t// I - Device URI\n\t   const char   *device_id,\t// I - IEEE-1284 device ID\n\t   cups_array_t *devices)\t// I - Device array\n{\n  lprint_device_t\tdev;\t\t// New device\n\n\n  dev.device_info = (char *)device_info;\n  dev.device_uri  = (char *)device_uri;\n  dev.device_id   = (char *)device_id;\n\n  cupsArrayAdd(devices, &dev);\n\n  return (false);\n}\n\n\n//\n// 'system_cb()' - Setup the system object.\n//\n\nstatic pappl_system_t *\t\t\t// O - System object\nsystem_cb(\n    int           num_options,\t\t// I - Number options\n    cups_option_t *options,\t\t// I - Options\n    void          *data)\t\t// I - Callback data (unused)\n{\n  pappl_system_t\t*system;\t// System object\n  const char\t\t*val,\t\t// Current option value\n\t\t\t*hostname,\t// Hostname, if any\n\t\t\t*listenhost,\t// Listen hostname, if any\n\t\t\t*logfile,\t// Log file, if any\n\t\t\t*spooldir,\t// Spool directory, if any\n\t\t\t*system_name;\t// System name, if any\n  char\t\t\toldfile[1024];\t// Old configuration filename\n  pappl_loglevel_t\tloglevel;\t// Log level\n  int\t\t\tport = 0;\t// Port number, if any\n  pappl_soptions_t\tsoptions = PAPPL_SOPTIONS_MULTI_QUEUE | PAPPL_SOPTIONS_WEB_INTERFACE | PAPPL_SOPTIONS_WEB_LOG | PAPPL_SOPTIONS_WEB_SECURITY | PAPPL_SOPTIONS_WEB_TLS;\n\t\t\t\t\t// System options\n  static pappl_version_t versions[1] =\t// Software versions\n  {\n    { \"LPrint\", \"\", LPRINT_VERSION, { LPRINT_MAJOR_VERSION, LPRINT_MINOR_VERSION, LPRINT_PATCH_VERSION, 0 } }\n  };\n\n\n  (void)data;\n\n  // Parse standard log and server options...\n  if ((val = cupsGetOption(\"log-level\", num_options, options)) != NULL)\n  {\n    if (!strcmp(val, \"fatal\"))\n      loglevel = PAPPL_LOGLEVEL_FATAL;\n    else if (!strcmp(val, \"error\"))\n      loglevel = PAPPL_LOGLEVEL_ERROR;\n    else if (!strcmp(val, \"warn\"))\n      loglevel = PAPPL_LOGLEVEL_WARN;\n    else if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n  }\n  else\n    loglevel = PAPPL_LOGLEVEL_UNSPEC;\n\n  if ((val = cupsGetOption(\"server-options\", num_options, options)) != NULL)\n  {\n    const char\t*valptr;\t\t// Pointer into value\n\n    for (valptr = val; valptr && *valptr;)\n    {\n      if (!strcmp(valptr, \"none\") || !strncmp(valptr, \"none,\", 5))\n        soptions = PAPPL_SOPTIONS_NONE;\n      else if (!strcmp(valptr, \"dnssd-host\") || !strncmp(valptr, \"dnssd-host,\", 11))\n        soptions |= PAPPL_SOPTIONS_DNSSD_HOST;\n      else if (!strcmp(valptr, \"no-multi-queue\") || !strncmp(valptr, \"no-multi-queue,\", 15))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_MULTI_QUEUE;\n      else if (!strcmp(valptr, \"raw-socket\") || !strncmp(valptr, \"raw-socket,\", 11))\n        soptions |= PAPPL_SOPTIONS_RAW_SOCKET;\n      else if (!strcmp(valptr, \"usb-printer\") || !strncmp(valptr, \"usb-printer,\", 12))\n        soptions |= PAPPL_SOPTIONS_USB_PRINTER;\n      else if (!strcmp(valptr, \"no-web-interface\") || !strncmp(valptr, \"no-web-interface,\", 17))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_WEB_INTERFACE;\n      else if (!strcmp(valptr, \"web-log\") || !strncmp(valptr, \"web-log,\", 8))\n        soptions |= PAPPL_SOPTIONS_WEB_LOG;\n      else if (!strcmp(valptr, \"web-network\") || !strncmp(valptr, \"web-network,\", 12))\n        soptions |= PAPPL_SOPTIONS_WEB_NETWORK;\n      else if (!strcmp(valptr, \"web-remote\") || !strncmp(valptr, \"web-remote,\", 11))\n        soptions |= PAPPL_SOPTIONS_WEB_REMOTE;\n      else if (!strcmp(valptr, \"web-security\") || !strncmp(valptr, \"web-security,\", 13))\n        soptions |= PAPPL_SOPTIONS_WEB_SECURITY;\n      else if (!strcmp(valptr, \"no-tls\") || !strncmp(valptr, \"no-tls,\", 7))\n        soptions = (pappl_soptions_t)((soptions | PAPPL_SOPTIONS_NO_TLS) & ~PAPPL_SOPTIONS_WEB_TLS);\n\n      if ((valptr = strchr(valptr, ',')) != NULL)\n        valptr ++;\n    }\n  }\n\n  hostname    = cupsGetOption(\"server-hostname\", num_options, options);\n  listenhost  = cupsGetOption(\"listen-hostname\", num_options, options);\n  logfile     = cupsGetOption(\"log-file\", num_options, options);\n  spooldir    = cupsGetOption(\"spool-directory\", num_options, options);\n  system_name = cupsGetOption(\"system-name\", num_options, options);\n\n  if ((val = cupsGetOption(\"server-port\", num_options, options)) != NULL)\n  {\n    if (!isdigit(*val & 255))\n    {\n      fprintf(stderr, \"lprint: Bad server-port value '%s'.\\n\", val);\n      return (NULL);\n    }\n    else\n      port = atoi(val);\n  }\n\n  // Spool directory and state file...\n  if ((val = getenv(\"SNAP_DATA\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else if ((val = getenv(\"XDG_DATA_HOME\")) != NULL)\n  {\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n  }\n#ifdef _WIN32\n  else if ((val = getenv(\"USERPROFILE\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/AppData/Local/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/AppData/Local/lprint.ini\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/AppData/Local/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else\n  {\n    papplCopyString(oldfile, \"/lprint.ini\", sizeof(oldfile));\n    papplCopyString(lprint_statefile, \"/lprint.state\", sizeof(lprint_statefile));\n  }\n#else\n  else if ((val = getenv(\"HOME\")) != NULL)\n  {\n#  ifdef __APPLE__\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/Library/Application Support/lprint.d\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/Library/Application Support/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n#  else\n    snprintf(oldfile, sizeof(oldfile), \"%s/.config\", val);\n    if (access(oldfile, 0))\n    {\n      if (mkdir(oldfile, 0777))\n      {\n\tperror(oldfile);\n\treturn (NULL);\n      }\n    }\n\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/.config/lprint.state\", val);\n#  endif // __APPLE__\n  }\n  else\n  {\n    papplCopyString(oldfile, \"/etc/lprint.conf\", sizeof(oldfile));\n#  ifdef __APPLE__\n    papplCopyString(lprint_statefile, \"/private/var/lib/lprint.state\", sizeof(lprint_statefile));\n#  else\n    papplCopyString(lprint_statefile, \"/var/lib/lprint.state\", sizeof(lprint_statefile));\n#  endif // __APPLE__\n  }\n#endif // _WIN32\n\n  if (!access(oldfile, 0) && access(lprint_statefile, 0))\n  {\n    // Move old state file to new name...\n    rename(oldfile, lprint_statefile);\n  }\n\n  if (spooldir && access(spooldir, 0))\n  {\n    if (mkdir(spooldir, 0777))\n    {\n      perror(spooldir);\n      return (NULL);\n    }\n  }\n\n  // Create the system object...\n  if ((system = papplSystemCreate(soptions, system_name ? system_name : \"LPrint\", port, \"_print,_universal\", spooldir, logfile ? logfile : \"-\", loglevel, cupsGetOption(\"auth-service\", num_options, options), /* tls_only */false)) == NULL)\n    return (NULL);\n\n  if (!cupsGetOption(\"private-server\", num_options, options))\n  {\n    // Listen for TCP/IP connections...\n    papplSystemAddListeners(system, listenhost);\n  }\n\n  papplSystemSetHostName(system, hostname);\n\n  if ((val = cupsGetOption(\"admin-group\", num_options, options)) != NULL)\n    papplSystemSetAdminGroup(system, val);\n\n  papplSystemSetMIMECallback(system, mime_cb, NULL);\n  papplSystemAddMIMEFilter(system, LPRINT_TESTPAGE_MIMETYPE, \"image/pwg-raster\", lprintTestFilterCB, NULL);\n\n  papplSystemSetPrinterDrivers(system, (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])), lprint_drivers, autoadd_cb, create_cb, driver_cb, system);\n\n  papplSystemAddResourceData(system, \"/favicon.png\", \"image/png\", lprint_small_png, sizeof(lprint_small_png));\n  papplSystemAddResourceData(system, \"/navicon.png\", \"image/png\", lprint_png, sizeof(lprint_png));\n  papplSystemAddResourceString(system, \"/style.css\", \"text/css\", lprint_css);\n  papplSystemAddStringsData(system, \"/de.strings\", \"de\", lprint_de_strings);\n  papplSystemAddStringsData(system, \"/en.strings\", \"en\", lprint_en_strings);\n  papplSystemAddStringsData(system, \"/es.strings\", \"es\", lprint_es_strings);\n  papplSystemAddStringsData(system, \"/fr.strings\", \"fr\", lprint_fr_strings);\n  papplSystemAddStringsData(system, \"/it.strings\", \"it\", lprint_it_strings);\n\n  papplSystemSetFooterHTML(system, \"Copyright &copy; 2019-2024 by Michael R Sweet. All rights reserved.\");\n  papplSystemSetSaveCallback(system, (pappl_save_cb_t)papplSystemSaveState, (void *)lprint_statefile);\n  papplSystemSetVersions(system, (int)(sizeof(versions) / sizeof(versions[0])), versions);\n\n  if (!papplSystemLoadState(system, lprint_statefile))\n  {\n    // No old state, use defaults and auto-add printers...\n    cups_array_t\t*devices;\t// Device array\n    lprint_device_t\t*dev;\t\t// Current device\n\n    papplSystemSetDNSSDName(system, system_name ? system_name : \"LPrint\");\n\n    papplLog(system, PAPPL_LOGLEVEL_INFO, \"Auto-adding printers...\");\n    devices = cupsArrayNew(NULL, NULL, NULL, 0, (cups_acopy_cb_t)copy_cb, (cups_afree_cb_t)free_cb);\n    papplDeviceList(PAPPL_DEVTYPE_USB, (pappl_device_cb_t)printer_cb, devices, papplLogDevice, system);\n\n    for (dev = (lprint_device_t *)cupsArrayGetFirst(devices); dev; dev = (lprint_device_t *)cupsArrayGetNext(devices))\n    {\n      const char *driver_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n\t\t\t\t\t// Driver name, if any\n\n      printf(\"%s (%s;%s) -> %s\\n\", dev->device_info, dev->device_uri, dev->device_id, driver_name);\n\n      if (driver_name)\n      {\n\tchar\tname[128],\t\t// Printer name\n\t\t*nameptr;\t\t// Pointer in name\n\n\t// Zebra puts \"Zebra Technologies ZTC\" on the front of their printer names,\n\t// which is a bit, um, wordy.  Clean up the device info string to use as a\n\t// printer name and drop any trailing \"(ID)\" nonsense if we don't need it.\n\tif (!strncasecmp(dev->device_info, \"Zebra Technologies ZTC \", 23))\n\t  snprintf(name, sizeof(name), \"Zebra %s\", dev->device_info + 23);\n\telse\n\t  papplCopyString(name, dev->device_info, sizeof(name));\n\n\tif ((nameptr = strstr(name, \" (\")) != NULL)\n\t  *nameptr = '\\0';\n\n\tif (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n      }\n    }\n\n    cupsArrayDelete(devices);\n  }\n\n  return (system);\n}\n\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "include",
    "start_line": 10,
    "end_line": 11,
    "code": "nclude \"lprint.h\"\n#i",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "include",
    "start_line": 11,
    "end_line": 12,
    "code": "nclude \"static-resources/lprint-de-strings.h\"\n#i",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "include",
    "start_line": 12,
    "end_line": 13,
    "code": "nclude \"static-resources/lprint-en-strings.h\"\n#i",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "include",
    "start_line": 13,
    "end_line": 14,
    "code": "nclude \"static-resources/lprint-es-strings.h\"\n#i",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "include",
    "start_line": 14,
    "end_line": 15,
    "code": "nclude \"static-resources/lprint-fr-strings.h\"\n#i",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "include",
    "start_line": 15,
    "end_line": 16,
    "code": "nclude \"static-resources/lprint-it-strings.h\"\n#i",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "include",
    "start_line": 16,
    "end_line": 17,
    "code": "nclude \"static-resources/lprint-css.h\"\n#i",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "include",
    "start_line": 17,
    "end_line": 18,
    "code": "nclude \"static-resources/lprint-png.h\"\n#i",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "include",
    "start_line": 18,
    "end_line": 19,
    "code": "nclude \"static-resources/lprint-large-png.h\"\n#i",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "include",
    "start_line": 19,
    "end_line": 20,
    "code": "nclude \"static-resources/lprint-small-png.h\"\n\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "typedef",
    "start_line": 26,
    "end_line": 31,
    "code": "pedef struct lprint_device_s\n{\n  char\t*device_info;\t\t\t// Device description\n  char\t*device_uri;\t\t\t// Device URI\n  char\t*device_id;\t\t\t// Device ID\n} lprint_device_t;\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct",
    "name": "lprint_device_s",
    "hierarchy": "lprint_device_s",
    "start_line": 26,
    "end_line": 31,
    "code": "ruct lprint_device_s\n{\n  char\t*device_info;\t\t\t// Device description\n  char\t*device_uri;\t\t\t// Device URI\n  char\t*device_id;\t\t\t// Device ID\n} l",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "global_variable",
    "start_line": 53,
    "end_line": 64,
    "code": "atic pappl_pr_driver_t\tlprint_drivers[] =\n{\t\t\t\t\t// Driver list\n#ifdef LPRINT_EXPERIMENTAL\n#  include \"lprint-brother.h\"\n#  include \"lprint-cpcl.h\"\n#endif // LPRINT_EXPERIMENTAL\n#include \"lprint-dymo.h\"\n#include \"lprint-epl2.h\"\n#include \"lprint-sii.h\"\n#include \"lprint-tspl.h\"\n#include \"lprint-zpl.h\"\n};\ns",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 53,
    "end_line": 64,
    "code": "atic pappl_pr_driver_t\tlprint_drivers[] =\n{\t\t\t\t\t// Driver list\n#ifdef LPRINT_EXPERIMENTAL\n#  include \"lprint-brother.h\"\n#  include \"lprint-cpcl.h\"\n#endif // LPRINT_EXPERIMENTAL\n#include \"lprint-dymo.h\"\n#include \"lprint-epl2.h\"\n#include \"lprint-sii.h\"\n#include \"lprint-tspl.h\"\n#include \"lprint-zpl.h\"\n};\ns",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 53,
    "end_line": 64,
    "code": "rint_drivers[] =\n{\t\t\t\t\t// Driver list\n#ifdef LPRINT_EXPERIMENTAL\n#  include \"lprint-brother.h\"\n#  include \"lprint-cpcl.h\"\n#endif // LPRINT_EXPERIMENTAL\n#include \"lprint-dymo.h\"\n#include \"lprint-epl2.h\"\n#include \"lprint-sii.h\"\n#include \"lprint-tspl.h\"\n#include \"lprint-zpl.h\"\n};\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function",
    "start_line": 75,
    "end_line": 88,
    "name": "main",
    "parent": null,
    "hierarchy": "main",
    "code": "t\t\t\t\t\t// O - Exit status\nmain(int  argc,\t\t\t\t// I - Number of command-line arguments\n     char *argv[])\t\t\t// I - Command-line arguments\n{\n  return (papplMainloop(argc, argv,\n                        LPRINT_VERSION,\n                        \"Copyright &copy; 2019-2025 by Michael R Sweet. All Rights Reserved.\",\n                        (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])),\n                        lprint_drivers, autoadd_cb, driver_cb,\n                        /*subcmd_name*/NULL, /*subcmd_cb*/NULL,\n                        system_cb,\n                        /*usage_cb*/NULL,\n                        /*data*/NULL));\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 75,
    "end_line": 88,
    "code": "t\t\t\t\t\t// O - Exit status\nmain(int  argc,\t\t\t\t// I - Number of command-line arguments\n     char *argv[])\t\t\t// I - Command-line arguments\n{\n  return (papplMainloop(argc, argv,\n                        LPRINT_VERSION,\n                        \"Copyright &copy; 2019-2025 by Michael R Sweet. All Rights Reserved.\",\n                        (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])),\n                        lprint_drivers, autoadd_cb, driver_cb,\n                        /*subcmd_name*/NULL, /*subcmd_cb*/NULL,\n                        system_cb,\n                        /*usage_cb*/NULL,\n                        /*data*/NULL));\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function",
    "start_line": 95,
    "end_line": 149,
    "name": null,
    "parent": null,
    "hierarchy": null,
    "code": "atic const char *\t\t\t// O - Driver name or `NULL` for none\nautoadd_cb(const char *device_info,\t// I - Device information/name (not used)\n           const char *device_uri,\t// I - Device URI\n           const char *device_id,\t// I - IEEE-1284 device ID\n           void       *cbdata)\t\t// I - Callback data (System)\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tscore,\t\t\t// Current driver match score\n\t    \tbest_score = 0,\t\t// Best score\n\t\tnum_did;\t\t// Number of device ID key/value pairs\n  cups_option_t\t*did;\t\t\t// Device ID key/value pairs\n  const char\t*make,\t\t\t// Manufacturer name\n\t\t*best_name = NULL;\t// Best driver\n  char\t\tname[1024] = \"\";\t// Driver name to match\n\n\n  (void)device_info;\n\n  // First parse the device ID and get any potential driver name to match...\n  num_did = papplDeviceParseID(device_id, &did);\n\n  if ((make = cupsGetOption(\"MANUFACTURER\", num_did, did)) == NULL)\n    if ((make = cupsGetOption(\"MANU\", num_did, did)) == NULL)\n      make = cupsGetOption(\"MFG\", num_did, did);\n\n  if (make && !strncasecmp(make, \"Zebra\", 5))\n    lprintZPLQueryDriver((pappl_system_t *)cbdata, device_uri, name, sizeof(name));\n\n  // Then loop through the driver list to find the best match...\n  for (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(name, lprint_drivers[i].name))\n    {\n      // Matching driver name always the best match...\n      best_name = lprint_drivers[i].name;\n      break;\n    }\n\n    if (lprint_drivers[i].device_id)\n    {\n      // See if we have a matching device ID...\n      score = match_id(num_did, did, lprint_drivers[i].device_id);\n      if (score > best_score)\n      {\n        best_score = score;\n        best_name  = lprint_drivers[i].name;\n      }\n    }\n  }\n\n  // Clean up and return...\n  cupsFreeOptions(num_did, did);\n\n  return (best_name);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 95,
    "end_line": 149,
    "code": "atic const char *\t\t\t// O - Driver name or `NULL` for none\nautoadd_cb(const char *device_info,\t// I - Device information/name (not used)\n           const char *device_uri,\t// I - Device URI\n           const char *device_id,\t// I - IEEE-1284 device ID\n           void       *cbdata)\t\t// I - Callback data (System)\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tscore,\t\t\t// Current driver match score\n\t    \tbest_score = 0,\t\t// Best score\n\t\tnum_did;\t\t// Number of device ID key/value pairs\n  cups_option_t\t*did;\t\t\t// Device ID key/value pairs\n  const char\t*make,\t\t\t// Manufacturer name\n\t\t*best_name = NULL;\t// Best driver\n  char\t\tname[1024] = \"\";\t// Driver name to match\n\n\n  (void)device_info;\n\n  // First parse the device ID and get any potential driver name to match...\n  num_did = papplDeviceParseID(device_id, &did);\n\n  if ((make = cupsGetOption(\"MANUFACTURER\", num_did, did)) == NULL)\n    if ((make = cupsGetOption(\"MANU\", num_did, did)) == NULL)\n      make = cupsGetOption(\"MFG\", num_did, did);\n\n  if (make && !strncasecmp(make, \"Zebra\", 5))\n    lprintZPLQueryDriver((pappl_system_t *)cbdata, device_uri, name, sizeof(name));\n\n  // Then loop through the driver list to find the best match...\n  for (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(name, lprint_drivers[i].name))\n    {\n      // Matching driver name always the best match...\n      best_name = lprint_drivers[i].name;\n      break;\n    }\n\n    if (lprint_drivers[i].device_id)\n    {\n      // See if we have a matching device ID...\n      score = match_id(num_did, did, lprint_drivers[i].device_id);\n      if (score > best_score)\n      {\n        best_score = score;\n        best_name  = lprint_drivers[i].name;\n      }\n    }\n  }\n\n  // Clean up and return...\n  cupsFreeOptions(num_did, did);\n\n  return (best_name);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 100,
    "end_line": 149,
    "code": "  int\t\ti,\t\t\t// Looping var\n\t\tscore,\t\t\t// Current driver match score\n\t    \tbest_score = 0,\t\t// Best score\n\t\tnum_did;\t\t// Number of device ID key/value pairs\n  cups_option_t\t*did;\t\t\t// Device ID key/value pairs\n  const char\t*make,\t\t\t// Manufacturer name\n\t\t*best_name = NULL;\t// Best driver\n  char\t\tname[1024] = \"\";\t// Driver name to match\n\n\n  (void)device_info;\n\n  // First parse the device ID and get any potential driver name to match...\n  num_did = papplDeviceParseID(device_id, &did);\n\n  if ((make = cupsGetOption(\"MANUFACTURER\", num_did, did)) == NULL)\n    if ((make = cupsGetOption(\"MANU\", num_did, did)) == NULL)\n      make = cupsGetOption(\"MFG\", num_did, did);\n\n  if (make && !strncasecmp(make, \"Zebra\", 5))\n    lprintZPLQueryDriver((pappl_system_t *)cbdata, device_uri, name, sizeof(name));\n\n  // Then loop through the driver list to find the best match...\n  for (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(name, lprint_drivers[i].name))\n    {\n      // Matching driver name always the best match...\n      best_name = lprint_drivers[i].name;\n      break;\n    }\n\n    if (lprint_drivers[i].device_id)\n    {\n      // See if we have a matching device ID...\n      score = match_id(num_did, did, lprint_drivers[i].device_id);\n      if (score > best_score)\n      {\n        best_score = score;\n        best_name  = lprint_drivers[i].name;\n      }\n    }\n  }\n\n  // Clean up and return...\n  cupsFreeOptions(num_did, did);\n\n  return (best_name);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "global_variable",
    "start_line": 101,
    "end_line": 104,
    "code": "t\t\ti,\t\t\t// Looping var\n\t\tscore,\t\t\t// Current driver match score\n\t    \tbest_score = 0,\t\t// Best score\n\t\tnum_did;\t\t",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "global_variable",
    "start_line": 106,
    "end_line": 107,
    "code": "nst char\t*make,\t\t\t// Manufacturer name\n\t\t*best_name = NULL;\t/",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "global_variable",
    "start_line": 108,
    "end_line": 108,
    "code": "ar\t\tname[1024] = \"\";\t/",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 124,
    "end_line": 143,
    "code": "r (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(name, lprint_drivers[i].name))\n    {\n      // Matching driver name always the best match...\n      best_name = lprint_drivers[i].name;\n      break;\n    }\n\n    if (lprint_drivers[i].device_id)\n    {\n      // See if we have a matching device ID...\n      score = match_id(num_did, did, lprint_drivers[i].device_id);\n      if (score > best_score)\n      {\n        best_score = score;\n        best_name  = lprint_drivers[i].name;\n      }\n    }\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 125,
    "end_line": 143,
    "code": "    if (!strcmp(name, lprint_drivers[i].name))\n    {\n      // Matching driver name always the best match...\n      best_name = lprint_drivers[i].name;\n      break;\n    }\n\n    if (lprint_drivers[i].device_id)\n    {\n      // See if we have a matching device ID...\n      score = match_id(num_did, did, lprint_drivers[i].device_id);\n      if (score > best_score)\n      {\n        best_score = score;\n        best_name  = lprint_drivers[i].name;\n      }\n    }\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 126,
    "end_line": 131,
    "code": " (!strcmp(name, lprint_drivers[i].name))\n    {\n      // Matching driver name always the best match...\n      best_name = lprint_drivers[i].name;\n      break;\n    }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 127,
    "end_line": 131,
    "code": "      // Matching driver name always the best match...\n      best_name = lprint_drivers[i].name;\n      break;\n    }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 129,
    "end_line": 129,
    "code": "st_name = lprint_drivers[i].name;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 129,
    "end_line": 129,
    "code": "st_name = lprint_drivers[i].name;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 133,
    "end_line": 142,
    "code": " (lprint_drivers[i].device_id)\n    {\n      // See if we have a matching device ID...\n      score = match_id(num_did, did, lprint_drivers[i].device_id);\n      if (score > best_score)\n      {\n        best_score = score;\n        best_name  = lprint_drivers[i].name;\n      }\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 134,
    "end_line": 142,
    "code": "      // See if we have a matching device ID...\n      score = match_id(num_did, did, lprint_drivers[i].device_id);\n      if (score > best_score)\n      {\n        best_score = score;\n        best_name  = lprint_drivers[i].name;\n      }\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 136,
    "end_line": 136,
    "code": "ore = match_id(num_did, did, lprint_drivers[i].device_id);\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 136,
    "end_line": 136,
    "code": "ore = match_id(num_did, did, lprint_drivers[i].device_id);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 137,
    "end_line": 141,
    "code": " (score > best_score)\n      {\n        best_score = score;\n        best_name  = lprint_drivers[i].name;\n      }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 138,
    "end_line": 141,
    "code": "        best_score = score;\n        best_name  = lprint_drivers[i].name;\n      }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 140,
    "end_line": 140,
    "code": "st_name  = lprint_drivers[i].name;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 140,
    "end_line": 140,
    "code": "st_name  = lprint_drivers[i].name;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function",
    "start_line": 156,
    "end_line": 176,
    "name": null,
    "parent": null,
    "hierarchy": null,
    "code": "atic lprint_device_t *\t\t// O - New device entry\ncopy_cb(lprint_device_t *src)\t\t// I - Original device entry\n{\n  lprint_device_t\t*dst;\t\t// New device entry\n\n\n  if ((dst = (lprint_device_t *)calloc(1, sizeof(lprint_device_t))) != NULL)\n  {\n    dst->device_info = strdup(src->device_info);\n    dst->device_uri  = strdup(src->device_uri);\n    dst->device_id   = strdup(src->device_id);\n\n    if (!dst->device_info || !dst->device_uri || !dst->device_id)\n    {\n      free_cb(dst);\n      dst = NULL;\n    }\n  }\n\n  return (dst);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 156,
    "end_line": 176,
    "code": "atic lprint_device_t *\t\t// O - New device entry\ncopy_cb(lprint_device_t *src)\t\t// I - Original device entry\n{\n  lprint_device_t\t*dst;\t\t// New device entry\n\n\n  if ((dst = (lprint_device_t *)calloc(1, sizeof(lprint_device_t))) != NULL)\n  {\n    dst->device_info = strdup(src->device_info);\n    dst->device_uri  = strdup(src->device_uri);\n    dst->device_id   = strdup(src->device_id);\n\n    if (!dst->device_info || !dst->device_uri || !dst->device_id)\n    {\n      free_cb(dst);\n      dst = NULL;\n    }\n  }\n\n  return (dst);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 156,
    "end_line": 176,
    "code": "atic lprint_device_t *\t\t// O - New device entry\ncopy_cb(lprint_device_t *src)\t\t// I - Original device entry\n{\n  lprint_device_t\t*dst;\t\t// New device entry\n\n\n  if ((dst = (lprint_device_t *)calloc(1, sizeof(lprint_device_t))) != NULL)\n  {\n    dst->device_info = strdup(src->device_info);\n    dst->device_uri  = strdup(src->device_uri);\n    dst->device_id   = strdup(src->device_id);\n\n    if (!dst->device_info || !dst->device_uri || !dst->device_id)\n    {\n      free_cb(dst);\n      dst = NULL;\n    }\n  }\n\n  return (dst);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 158,
    "end_line": 176,
    "code": "  lprint_device_t\t*dst;\t\t// New device entry\n\n\n  if ((dst = (lprint_device_t *)calloc(1, sizeof(lprint_device_t))) != NULL)\n  {\n    dst->device_info = strdup(src->device_info);\n    dst->device_uri  = strdup(src->device_uri);\n    dst->device_id   = strdup(src->device_id);\n\n    if (!dst->device_info || !dst->device_uri || !dst->device_id)\n    {\n      free_cb(dst);\n      dst = NULL;\n    }\n  }\n\n  return (dst);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 158,
    "end_line": 176,
    "code": "  lprint_device_t\t*dst;\t\t// New device entry\n\n\n  if ((dst = (lprint_device_t *)calloc(1, sizeof(lprint_device_t))) != NULL)\n  {\n    dst->device_info = strdup(src->device_info);\n    dst->device_uri  = strdup(src->device_uri);\n    dst->device_id   = strdup(src->device_id);\n\n    if (!dst->device_info || !dst->device_uri || !dst->device_id)\n    {\n      free_cb(dst);\n      dst = NULL;\n    }\n  }\n\n  return (dst);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 162,
    "end_line": 173,
    "code": " ((dst = (lprint_device_t *)calloc(1, sizeof(lprint_device_t))) != NULL)\n  {\n    dst->device_info = strdup(src->device_info);\n    dst->device_uri  = strdup(src->device_uri);\n    dst->device_id   = strdup(src->device_id);\n\n    if (!dst->device_info || !dst->device_uri || !dst->device_id)\n    {\n      free_cb(dst);\n      dst = NULL;\n    }\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 162,
    "end_line": 173,
    "code": " ((dst = (lprint_device_t *)calloc(1, sizeof(lprint_device_t))) != NULL)\n  {\n    dst->device_info = strdup(src->device_info);\n    dst->device_uri  = strdup(src->device_uri);\n    dst->device_id   = strdup(src->device_id);\n\n    if (!dst->device_info || !dst->device_uri || !dst->device_id)\n    {\n      free_cb(dst);\n      dst = NULL;\n    }\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 163,
    "end_line": 173,
    "code": "    dst->device_info = strdup(src->device_info);\n    dst->device_uri  = strdup(src->device_uri);\n    dst->device_id   = strdup(src->device_id);\n\n    if (!dst->device_info || !dst->device_uri || !dst->device_id)\n    {\n      free_cb(dst);\n      dst = NULL;\n    }\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 163,
    "end_line": 173,
    "code": "    dst->device_info = strdup(src->device_info);\n    dst->device_uri  = strdup(src->device_uri);\n    dst->device_id   = strdup(src->device_id);\n\n    if (!dst->device_info || !dst->device_uri || !dst->device_id)\n    {\n      free_cb(dst);\n      dst = NULL;\n    }\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 164,
    "end_line": 164,
    "code": "t->device_info = strdup(src->device_info);\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 164,
    "end_line": 164,
    "code": "t->device_info = strdup(src->device_info);\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 164,
    "end_line": 164,
    "code": "t->device_info = strdup(src->device_info);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 164,
    "end_line": 164,
    "code": "t->device_info = strdup(src->device_info);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 165,
    "end_line": 165,
    "code": "t->device_uri  = strdup(src->device_uri);\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 165,
    "end_line": 165,
    "code": "t->device_uri  = strdup(src->device_uri);\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 165,
    "end_line": 165,
    "code": "t->device_uri  = strdup(src->device_uri);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 165,
    "end_line": 165,
    "code": "t->device_uri  = strdup(src->device_uri);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 166,
    "end_line": 166,
    "code": "t->device_id   = strdup(src->device_id);\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 166,
    "end_line": 166,
    "code": "t->device_id   = strdup(src->device_id);\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 166,
    "end_line": 166,
    "code": "t->device_id   = strdup(src->device_id);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 166,
    "end_line": 166,
    "code": "t->device_id   = strdup(src->device_id);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 168,
    "end_line": 172,
    "code": " (!dst->device_info || !dst->device_uri || !dst->device_id)\n    {\n      free_cb(dst);\n      dst = NULL;\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 168,
    "end_line": 172,
    "code": " (!dst->device_info || !dst->device_uri || !dst->device_id)\n    {\n      free_cb(dst);\n      dst = NULL;\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function",
    "start_line": 183,
    "end_line": 207,
    "name": "create_cb",
    "parent": null,
    "hierarchy": "create_cb",
    "code": "atic void\ncreate_cb(pappl_printer_t *printer,\t// I - Printer\n          void            *cbdata)\t// I - Callback data (not used)\n{\n  char\t\t\tresource[1024];\t// Resource path\n  pappl_pr_driver_data_t data;\t\t// Driver data\n\n\n  (void)cbdata;\n\n  LPRINT_DEBUG(\"create_cb(printer=%p(%s), cbdata=%p)\\n\", printer, printer ? papplPrinterGetName(printer) : \"null\", cbdata);\n\n  // Add custom label media page to replace the standard ready media page...\n  papplSystemRemoveResource(papplPrinterGetSystem(printer), papplPrinterGetPath(printer, \"media\", resource, sizeof(resource)));\n  papplSystemAddResourceCallback(papplPrinterGetSystem(printer), resource, \"text/html\", (pappl_resource_cb_t)lprintMediaUI, printer);\n  LPRINT_DEBUG(\"create_cb: Added new media page for '%s'.\\n\", resource);\n\n  // Load custom media sizes and report them...\n  papplPrinterGetDriverData(printer, &data);\n  lprintMediaLoad(printer, &data);\n  lprintMediaUpdate(printer, &data);\n  papplPrinterSetDriverData(printer, &data, NULL);\n\n  LPRINT_DEBUG(\"create_cb: data.extension=%p\\n\", data.extension);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 183,
    "end_line": 207,
    "code": "atic void\ncreate_cb(pappl_printer_t *printer,\t// I - Printer\n          void            *cbdata)\t// I - Callback data (not used)\n{\n  char\t\t\tresource[1024];\t// Resource path\n  pappl_pr_driver_data_t data;\t\t// Driver data\n\n\n  (void)cbdata;\n\n  LPRINT_DEBUG(\"create_cb(printer=%p(%s), cbdata=%p)\\n\", printer, printer ? papplPrinterGetName(printer) : \"null\", cbdata);\n\n  // Add custom label media page to replace the standard ready media page...\n  papplSystemRemoveResource(papplPrinterGetSystem(printer), papplPrinterGetPath(printer, \"media\", resource, sizeof(resource)));\n  papplSystemAddResourceCallback(papplPrinterGetSystem(printer), resource, \"text/html\", (pappl_resource_cb_t)lprintMediaUI, printer);\n  LPRINT_DEBUG(\"create_cb: Added new media page for '%s'.\\n\", resource);\n\n  // Load custom media sizes and report them...\n  papplPrinterGetDriverData(printer, &data);\n  lprintMediaLoad(printer, &data);\n  lprintMediaUpdate(printer, &data);\n  papplPrinterSetDriverData(printer, &data, NULL);\n\n  LPRINT_DEBUG(\"create_cb: data.extension=%p\\n\", data.extension);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 186,
    "end_line": 207,
    "code": "  char\t\t\tresource[1024];\t// Resource path\n  pappl_pr_driver_data_t data;\t\t// Driver data\n\n\n  (void)cbdata;\n\n  LPRINT_DEBUG(\"create_cb(printer=%p(%s), cbdata=%p)\\n\", printer, printer ? papplPrinterGetName(printer) : \"null\", cbdata);\n\n  // Add custom label media page to replace the standard ready media page...\n  papplSystemRemoveResource(papplPrinterGetSystem(printer), papplPrinterGetPath(printer, \"media\", resource, sizeof(resource)));\n  papplSystemAddResourceCallback(papplPrinterGetSystem(printer), resource, \"text/html\", (pappl_resource_cb_t)lprintMediaUI, printer);\n  LPRINT_DEBUG(\"create_cb: Added new media page for '%s'.\\n\", resource);\n\n  // Load custom media sizes and report them...\n  papplPrinterGetDriverData(printer, &data);\n  lprintMediaLoad(printer, &data);\n  lprintMediaUpdate(printer, &data);\n  papplPrinterSetDriverData(printer, &data, NULL);\n\n  LPRINT_DEBUG(\"create_cb: data.extension=%p\\n\", data.extension);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 206,
    "end_line": 206,
    "code": "RINT_DEBUG(\"create_cb: data.extension=%p\\n\", data.extension);\n}",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 206,
    "end_line": 206,
    "code": "RINT_DEBUG(\"create_cb: data.extension=%p\\n\", data.extension);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 206,
    "end_line": 206,
    "code": "create_cb: data.extension=%p\\n\", data.extension);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function",
    "start_line": 214,
    "end_line": 318,
    "name": "driver_cb",
    "parent": null,
    "hierarchy": "driver_cb",
    "code": "atic bool\t\t\t\t// O - `true` on success, `false` on error\ndriver_cb(\n    pappl_system_t         *system,\t// I - System\n    const char             *driver_name,// I - Driver name\n    const char             *device_uri,\t// I - Device URI\n    const char             *device_id,\t// I - 1284 device ID\n    pappl_pr_driver_data_t *data,\t// I - Pointer to driver data\n    ipp_t                  **attrs,\t// O - Pointer to driver attributes\n    void                   *cbdata)\t// I - Callback data (not used)\n{\n  bool\tret = false;\t\t\t// Return value\n  int\ti;\t\t\t\t// Looping var\n\n\n  // Copy make/model info...\n  for (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(driver_name, lprint_drivers[i].name))\n    {\n      papplCopyString(data->make_and_model, lprint_drivers[i].description, sizeof(data->make_and_model));\n      break;\n    }\n  }\n\n  // AirPrint version...\n  data->num_features = 1;\n  data->features[0]  = \"airprint-2.1\";\n\n  // Pages per minute (interpret as \"labels per minute\")\n  data->ppm = 60;\n\n  // \"printer-kind\" values...\n  data->kind = PAPPL_KIND_LABEL;\n\n  // Color values...\n  data->color_supported = PAPPL_COLOR_MODE_AUTO | PAPPL_COLOR_MODE_MONOCHROME | PAPPL_COLOR_MODE_BI_LEVEL;\n  data->color_default   = PAPPL_COLOR_MODE_MONOCHROME;\n  data->raster_types    = PAPPL_PWG_RASTER_TYPE_BLACK_1 | PAPPL_PWG_RASTER_TYPE_BLACK_8 | PAPPL_PWG_RASTER_TYPE_SGRAY_8;\n\n  // \"print-quality-default\" value...\n  data->quality_default = IPP_QUALITY_NORMAL;\n\n  // \"sides\" values...\n  data->sides_supported = PAPPL_SIDES_ONE_SIDED;\n  data->sides_default   = PAPPL_SIDES_ONE_SIDED;\n\n  // \"orientation-requested-default\" value...\n  data->orient_default = IPP_ORIENT_NONE;\n\n  // Media capabilities...\n  data->input_face_up  = true;\n  data->output_face_up = true;\n\n  // Standard icons...\n  data->icons[0].data    = lprint_small_png;\n  data->icons[0].datalen = sizeof(lprint_small_png);\n  data->icons[1].data    = lprint_png;\n  data->icons[1].datalen = sizeof(lprint_png);\n  data->icons[2].data    = lprint_large_png;\n  data->icons[2].datalen = sizeof(lprint_large_png);\n\n  // Test page callback...\n  data->testpage_cb = lprintTestPageCB;\n\n  // Use the corresponding sub-driver callback to set things up...\n#ifdef LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"brother_\", 8))\n    ret = lprintBrother(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"cpcl_\", 5))\n    ret = lprintCPCL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else\n#endif // LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"dymo_\", 5))\n    ret = lprintDYMO(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"epl2_\", 5))\n    ret = lprintEPL2(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"sii_\", 4))\n    ret = lprintSII(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"tspl_\", 5))\n    ret = lprintTSPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"zpl_\", 4))\n    ret = lprintZPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n\n  // Update the ready media...\n  for (i = 0; i < data->num_source; i ++)\n  {\n    pwg_media_t *pwg = pwgMediaForPWG(data->media_ready[i].size_name);\n\n    data->media_ready[i].bottom_margin = data->bottom_top;\n    data->media_ready[i].left_margin   = data->left_right;\n    data->media_ready[i].right_margin  = data->left_right;\n    data->media_ready[i].size_width    = pwg->width;\n    data->media_ready[i].size_length   = pwg->length;\n    data->media_ready[i].top_margin    = data->bottom_top;\n    papplCopyString(data->media_ready[i].source, data->source[i], sizeof(data->media_ready[i].source));\n    if (!data->media_ready[i].type[0])\n      papplCopyString(data->media_ready[i].type, data->type[0], sizeof(data->media_ready[i].type));\n  }\n\n  // By default use media from the main source...\n  data->media_default = data->media_ready[0];\n\n  // Return...\n  return (ret);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 214,
    "end_line": 318,
    "code": "atic bool\t\t\t\t// O - `true` on success, `false` on error\ndriver_cb(\n    pappl_system_t         *system,\t// I - System\n    const char             *driver_name,// I - Driver name\n    const char             *device_uri,\t// I - Device URI\n    const char             *device_id,\t// I - 1284 device ID\n    pappl_pr_driver_data_t *data,\t// I - Pointer to driver data\n    ipp_t                  **attrs,\t// O - Pointer to driver attributes\n    void                   *cbdata)\t// I - Callback data (not used)\n{\n  bool\tret = false;\t\t\t// Return value\n  int\ti;\t\t\t\t// Looping var\n\n\n  // Copy make/model info...\n  for (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(driver_name, lprint_drivers[i].name))\n    {\n      papplCopyString(data->make_and_model, lprint_drivers[i].description, sizeof(data->make_and_model));\n      break;\n    }\n  }\n\n  // AirPrint version...\n  data->num_features = 1;\n  data->features[0]  = \"airprint-2.1\";\n\n  // Pages per minute (interpret as \"labels per minute\")\n  data->ppm = 60;\n\n  // \"printer-kind\" values...\n  data->kind = PAPPL_KIND_LABEL;\n\n  // Color values...\n  data->color_supported = PAPPL_COLOR_MODE_AUTO | PAPPL_COLOR_MODE_MONOCHROME | PAPPL_COLOR_MODE_BI_LEVEL;\n  data->color_default   = PAPPL_COLOR_MODE_MONOCHROME;\n  data->raster_types    = PAPPL_PWG_RASTER_TYPE_BLACK_1 | PAPPL_PWG_RASTER_TYPE_BLACK_8 | PAPPL_PWG_RASTER_TYPE_SGRAY_8;\n\n  // \"print-quality-default\" value...\n  data->quality_default = IPP_QUALITY_NORMAL;\n\n  // \"sides\" values...\n  data->sides_supported = PAPPL_SIDES_ONE_SIDED;\n  data->sides_default   = PAPPL_SIDES_ONE_SIDED;\n\n  // \"orientation-requested-default\" value...\n  data->orient_default = IPP_ORIENT_NONE;\n\n  // Media capabilities...\n  data->input_face_up  = true;\n  data->output_face_up = true;\n\n  // Standard icons...\n  data->icons[0].data    = lprint_small_png;\n  data->icons[0].datalen = sizeof(lprint_small_png);\n  data->icons[1].data    = lprint_png;\n  data->icons[1].datalen = sizeof(lprint_png);\n  data->icons[2].data    = lprint_large_png;\n  data->icons[2].datalen = sizeof(lprint_large_png);\n\n  // Test page callback...\n  data->testpage_cb = lprintTestPageCB;\n\n  // Use the corresponding sub-driver callback to set things up...\n#ifdef LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"brother_\", 8))\n    ret = lprintBrother(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"cpcl_\", 5))\n    ret = lprintCPCL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else\n#endif // LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"dymo_\", 5))\n    ret = lprintDYMO(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"epl2_\", 5))\n    ret = lprintEPL2(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"sii_\", 4))\n    ret = lprintSII(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"tspl_\", 5))\n    ret = lprintTSPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"zpl_\", 4))\n    ret = lprintZPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n\n  // Update the ready media...\n  for (i = 0; i < data->num_source; i ++)\n  {\n    pwg_media_t *pwg = pwgMediaForPWG(data->media_ready[i].size_name);\n\n    data->media_ready[i].bottom_margin = data->bottom_top;\n    data->media_ready[i].left_margin   = data->left_right;\n    data->media_ready[i].right_margin  = data->left_right;\n    data->media_ready[i].size_width    = pwg->width;\n    data->media_ready[i].size_length   = pwg->length;\n    data->media_ready[i].top_margin    = data->bottom_top;\n    papplCopyString(data->media_ready[i].source, data->source[i], sizeof(data->media_ready[i].source));\n    if (!data->media_ready[i].type[0])\n      papplCopyString(data->media_ready[i].type, data->type[0], sizeof(data->media_ready[i].type));\n  }\n\n  // By default use media from the main source...\n  data->media_default = data->media_ready[0];\n\n  // Return...\n  return (ret);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 214,
    "end_line": 318,
    "code": "atic bool\t\t\t\t// O - `true` on success, `false` on error\ndriver_cb(\n    pappl_system_t         *system,\t// I - System\n    const char             *driver_name,// I - Driver name\n    const char             *device_uri,\t// I - Device URI\n    const char             *device_id,\t// I - 1284 device ID\n    pappl_pr_driver_data_t *data,\t// I - Pointer to driver data\n    ipp_t                  **attrs,\t// O - Pointer to driver attributes\n    void                   *cbdata)\t// I - Callback data (not used)\n{\n  bool\tret = false;\t\t\t// Return value\n  int\ti;\t\t\t\t// Looping var\n\n\n  // Copy make/model info...\n  for (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(driver_name, lprint_drivers[i].name))\n    {\n      papplCopyString(data->make_and_model, lprint_drivers[i].description, sizeof(data->make_and_model));\n      break;\n    }\n  }\n\n  // AirPrint version...\n  data->num_features = 1;\n  data->features[0]  = \"airprint-2.1\";\n\n  // Pages per minute (interpret as \"labels per minute\")\n  data->ppm = 60;\n\n  // \"printer-kind\" values...\n  data->kind = PAPPL_KIND_LABEL;\n\n  // Color values...\n  data->color_supported = PAPPL_COLOR_MODE_AUTO | PAPPL_COLOR_MODE_MONOCHROME | PAPPL_COLOR_MODE_BI_LEVEL;\n  data->color_default   = PAPPL_COLOR_MODE_MONOCHROME;\n  data->raster_types    = PAPPL_PWG_RASTER_TYPE_BLACK_1 | PAPPL_PWG_RASTER_TYPE_BLACK_8 | PAPPL_PWG_RASTER_TYPE_SGRAY_8;\n\n  // \"print-quality-default\" value...\n  data->quality_default = IPP_QUALITY_NORMAL;\n\n  // \"sides\" values...\n  data->sides_supported = PAPPL_SIDES_ONE_SIDED;\n  data->sides_default   = PAPPL_SIDES_ONE_SIDED;\n\n  // \"orientation-requested-default\" value...\n  data->orient_default = IPP_ORIENT_NONE;\n\n  // Media capabilities...\n  data->input_face_up  = true;\n  data->output_face_up = true;\n\n  // Standard icons...\n  data->icons[0].data    = lprint_small_png;\n  data->icons[0].datalen = sizeof(lprint_small_png);\n  data->icons[1].data    = lprint_png;\n  data->icons[1].datalen = sizeof(lprint_png);\n  data->icons[2].data    = lprint_large_png;\n  data->icons[2].datalen = sizeof(lprint_large_png);\n\n  // Test page callback...\n  data->testpage_cb = lprintTestPageCB;\n\n  // Use the corresponding sub-driver callback to set things up...\n#ifdef LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"brother_\", 8))\n    ret = lprintBrother(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"cpcl_\", 5))\n    ret = lprintCPCL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else\n#endif // LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"dymo_\", 5))\n    ret = lprintDYMO(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"epl2_\", 5))\n    ret = lprintEPL2(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"sii_\", 4))\n    ret = lprintSII(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"tspl_\", 5))\n    ret = lprintTSPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"zpl_\", 4))\n    ret = lprintZPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n\n  // Update the ready media...\n  for (i = 0; i < data->num_source; i ++)\n  {\n    pwg_media_t *pwg = pwgMediaForPWG(data->media_ready[i].size_name);\n\n    data->media_ready[i].bottom_margin = data->bottom_top;\n    data->media_ready[i].left_margin   = data->left_right;\n    data->media_ready[i].right_margin  = data->left_right;\n    data->media_ready[i].size_width    = pwg->width;\n    data->media_ready[i].size_length   = pwg->length;\n    data->media_ready[i].top_margin    = data->bottom_top;\n    papplCopyString(data->media_ready[i].source, data->source[i], sizeof(data->media_ready[i].source));\n    if (!data->media_ready[i].type[0])\n      papplCopyString(data->media_ready[i].type, data->type[0], sizeof(data->media_ready[i].type));\n  }\n\n  // By default use media from the main source...\n  data->media_default = data->media_ready[0];\n\n  // Return...\n  return (ret);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 223,
    "end_line": 318,
    "code": "  bool\tret = false;\t\t\t// Return value\n  int\ti;\t\t\t\t// Looping var\n\n\n  // Copy make/model info...\n  for (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(driver_name, lprint_drivers[i].name))\n    {\n      papplCopyString(data->make_and_model, lprint_drivers[i].description, sizeof(data->make_and_model));\n      break;\n    }\n  }\n\n  // AirPrint version...\n  data->num_features = 1;\n  data->features[0]  = \"airprint-2.1\";\n\n  // Pages per minute (interpret as \"labels per minute\")\n  data->ppm = 60;\n\n  // \"printer-kind\" values...\n  data->kind = PAPPL_KIND_LABEL;\n\n  // Color values...\n  data->color_supported = PAPPL_COLOR_MODE_AUTO | PAPPL_COLOR_MODE_MONOCHROME | PAPPL_COLOR_MODE_BI_LEVEL;\n  data->color_default   = PAPPL_COLOR_MODE_MONOCHROME;\n  data->raster_types    = PAPPL_PWG_RASTER_TYPE_BLACK_1 | PAPPL_PWG_RASTER_TYPE_BLACK_8 | PAPPL_PWG_RASTER_TYPE_SGRAY_8;\n\n  // \"print-quality-default\" value...\n  data->quality_default = IPP_QUALITY_NORMAL;\n\n  // \"sides\" values...\n  data->sides_supported = PAPPL_SIDES_ONE_SIDED;\n  data->sides_default   = PAPPL_SIDES_ONE_SIDED;\n\n  // \"orientation-requested-default\" value...\n  data->orient_default = IPP_ORIENT_NONE;\n\n  // Media capabilities...\n  data->input_face_up  = true;\n  data->output_face_up = true;\n\n  // Standard icons...\n  data->icons[0].data    = lprint_small_png;\n  data->icons[0].datalen = sizeof(lprint_small_png);\n  data->icons[1].data    = lprint_png;\n  data->icons[1].datalen = sizeof(lprint_png);\n  data->icons[2].data    = lprint_large_png;\n  data->icons[2].datalen = sizeof(lprint_large_png);\n\n  // Test page callback...\n  data->testpage_cb = lprintTestPageCB;\n\n  // Use the corresponding sub-driver callback to set things up...\n#ifdef LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"brother_\", 8))\n    ret = lprintBrother(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"cpcl_\", 5))\n    ret = lprintCPCL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else\n#endif // LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"dymo_\", 5))\n    ret = lprintDYMO(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"epl2_\", 5))\n    ret = lprintEPL2(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"sii_\", 4))\n    ret = lprintSII(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"tspl_\", 5))\n    ret = lprintTSPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"zpl_\", 4))\n    ret = lprintZPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n\n  // Update the ready media...\n  for (i = 0; i < data->num_source; i ++)\n  {\n    pwg_media_t *pwg = pwgMediaForPWG(data->media_ready[i].size_name);\n\n    data->media_ready[i].bottom_margin = data->bottom_top;\n    data->media_ready[i].left_margin   = data->left_right;\n    data->media_ready[i].right_margin  = data->left_right;\n    data->media_ready[i].size_width    = pwg->width;\n    data->media_ready[i].size_length   = pwg->length;\n    data->media_ready[i].top_margin    = data->bottom_top;\n    papplCopyString(data->media_ready[i].source, data->source[i], sizeof(data->media_ready[i].source));\n    if (!data->media_ready[i].type[0])\n      papplCopyString(data->media_ready[i].type, data->type[0], sizeof(data->media_ready[i].type));\n  }\n\n  // By default use media from the main source...\n  data->media_default = data->media_ready[0];\n\n  // Return...\n  return (ret);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 223,
    "end_line": 318,
    "code": "  bool\tret = false;\t\t\t// Return value\n  int\ti;\t\t\t\t// Looping var\n\n\n  // Copy make/model info...\n  for (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(driver_name, lprint_drivers[i].name))\n    {\n      papplCopyString(data->make_and_model, lprint_drivers[i].description, sizeof(data->make_and_model));\n      break;\n    }\n  }\n\n  // AirPrint version...\n  data->num_features = 1;\n  data->features[0]  = \"airprint-2.1\";\n\n  // Pages per minute (interpret as \"labels per minute\")\n  data->ppm = 60;\n\n  // \"printer-kind\" values...\n  data->kind = PAPPL_KIND_LABEL;\n\n  // Color values...\n  data->color_supported = PAPPL_COLOR_MODE_AUTO | PAPPL_COLOR_MODE_MONOCHROME | PAPPL_COLOR_MODE_BI_LEVEL;\n  data->color_default   = PAPPL_COLOR_MODE_MONOCHROME;\n  data->raster_types    = PAPPL_PWG_RASTER_TYPE_BLACK_1 | PAPPL_PWG_RASTER_TYPE_BLACK_8 | PAPPL_PWG_RASTER_TYPE_SGRAY_8;\n\n  // \"print-quality-default\" value...\n  data->quality_default = IPP_QUALITY_NORMAL;\n\n  // \"sides\" values...\n  data->sides_supported = PAPPL_SIDES_ONE_SIDED;\n  data->sides_default   = PAPPL_SIDES_ONE_SIDED;\n\n  // \"orientation-requested-default\" value...\n  data->orient_default = IPP_ORIENT_NONE;\n\n  // Media capabilities...\n  data->input_face_up  = true;\n  data->output_face_up = true;\n\n  // Standard icons...\n  data->icons[0].data    = lprint_small_png;\n  data->icons[0].datalen = sizeof(lprint_small_png);\n  data->icons[1].data    = lprint_png;\n  data->icons[1].datalen = sizeof(lprint_png);\n  data->icons[2].data    = lprint_large_png;\n  data->icons[2].datalen = sizeof(lprint_large_png);\n\n  // Test page callback...\n  data->testpage_cb = lprintTestPageCB;\n\n  // Use the corresponding sub-driver callback to set things up...\n#ifdef LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"brother_\", 8))\n    ret = lprintBrother(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"cpcl_\", 5))\n    ret = lprintCPCL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else\n#endif // LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"dymo_\", 5))\n    ret = lprintDYMO(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"epl2_\", 5))\n    ret = lprintEPL2(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"sii_\", 4))\n    ret = lprintSII(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"tspl_\", 5))\n    ret = lprintTSPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"zpl_\", 4))\n    ret = lprintZPL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n\n  // Update the ready media...\n  for (i = 0; i < data->num_source; i ++)\n  {\n    pwg_media_t *pwg = pwgMediaForPWG(data->media_ready[i].size_name);\n\n    data->media_ready[i].bottom_margin = data->bottom_top;\n    data->media_ready[i].left_margin   = data->left_right;\n    data->media_ready[i].right_margin  = data->left_right;\n    data->media_ready[i].size_width    = pwg->width;\n    data->media_ready[i].size_length   = pwg->length;\n    data->media_ready[i].top_margin    = data->bottom_top;\n    papplCopyString(data->media_ready[i].source, data->source[i], sizeof(data->media_ready[i].source));\n    if (!data->media_ready[i].type[0])\n      papplCopyString(data->media_ready[i].type, data->type[0], sizeof(data->media_ready[i].type));\n  }\n\n  // By default use media from the main source...\n  data->media_default = data->media_ready[0];\n\n  // Return...\n  return (ret);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "global_variable",
    "start_line": 224,
    "end_line": 224,
    "code": "ol\tret = false;\t\t",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 229,
    "end_line": 236,
    "code": "r (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(driver_name, lprint_drivers[i].name))\n    {\n      papplCopyString(data->make_and_model, lprint_drivers[i].description, sizeof(data->make_and_model));\n      break;\n    }\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 229,
    "end_line": 236,
    "code": "r (i = 0; i < (int)(sizeof(lprint_drivers) / sizeof(lprint_drivers[0])); i ++)\n  {\n    if (!strcmp(driver_name, lprint_drivers[i].name))\n    {\n      papplCopyString(data->make_and_model, lprint_drivers[i].description, sizeof(data->make_and_model));\n      break;\n    }\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 239,
    "end_line": 239,
    "code": "ta->num_features = 1;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 239,
    "end_line": 239,
    "code": "ta->num_features = 1;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 240,
    "end_line": 240,
    "code": "ta->features[0]  = \"airprint-2.1\";\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 240,
    "end_line": 240,
    "code": "ta->features[0]  = \"airprint-2.1\";\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 243,
    "end_line": 243,
    "code": "ta->ppm = 60;\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 243,
    "end_line": 243,
    "code": "ta->ppm = 60;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 246,
    "end_line": 246,
    "code": "ta->kind = PAPPL_KIND_LABEL;\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 246,
    "end_line": 246,
    "code": "ta->kind = PAPPL_KIND_LABEL;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 249,
    "end_line": 249,
    "code": "ta->color_supported = PAPPL_COLOR_MODE_AUTO | PAPPL_COLOR_MODE_MONOCHROME | PAPPL_COLOR_MODE_BI_LEVEL;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 249,
    "end_line": 249,
    "code": "ta->color_supported = PAPPL_COLOR_MODE_AUTO | PAPPL_COLOR_MODE_MONOCHROME | PAPPL_COLOR_MODE_BI_LEVEL;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 250,
    "end_line": 250,
    "code": "ta->color_default   = PAPPL_COLOR_MODE_MONOCHROME;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 250,
    "end_line": 250,
    "code": "ta->color_default   = PAPPL_COLOR_MODE_MONOCHROME;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 251,
    "end_line": 251,
    "code": "ta->raster_types    = PAPPL_PWG_RASTER_TYPE_BLACK_1 | PAPPL_PWG_RASTER_TYPE_BLACK_8 | PAPPL_PWG_RASTER_TYPE_SGRAY_8;\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 251,
    "end_line": 251,
    "code": "ta->raster_types    = PAPPL_PWG_RASTER_TYPE_BLACK_1 | PAPPL_PWG_RASTER_TYPE_BLACK_8 | PAPPL_PWG_RASTER_TYPE_SGRAY_8;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 254,
    "end_line": 254,
    "code": "ta->quality_default = IPP_QUALITY_NORMAL;\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 254,
    "end_line": 254,
    "code": "ta->quality_default = IPP_QUALITY_NORMAL;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 257,
    "end_line": 257,
    "code": "ta->sides_supported = PAPPL_SIDES_ONE_SIDED;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 257,
    "end_line": 257,
    "code": "ta->sides_supported = PAPPL_SIDES_ONE_SIDED;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 258,
    "end_line": 258,
    "code": "ta->sides_default   = PAPPL_SIDES_ONE_SIDED;\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 258,
    "end_line": 258,
    "code": "ta->sides_default   = PAPPL_SIDES_ONE_SIDED;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 261,
    "end_line": 261,
    "code": "ta->orient_default = IPP_ORIENT_NONE;\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 261,
    "end_line": 261,
    "code": "ta->orient_default = IPP_ORIENT_NONE;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 264,
    "end_line": 264,
    "code": "ta->input_face_up  = true;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 264,
    "end_line": 264,
    "code": "ta->input_face_up  = true;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 265,
    "end_line": 265,
    "code": "ta->output_face_up = true;\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 265,
    "end_line": 265,
    "code": "ta->output_face_up = true;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 268,
    "end_line": 268,
    "code": "ta->icons[0].data    = lprint_small_png;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 268,
    "end_line": 268,
    "code": "ta->icons[0].data    = lprint_small_png;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 269,
    "end_line": 269,
    "code": "ta->icons[0].datalen = sizeof(lprint_small_png);\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 269,
    "end_line": 269,
    "code": "ta->icons[0].datalen = sizeof(lprint_small_png);\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 269,
    "end_line": 269,
    "code": "ta->icons[0].datalen = sizeof(lprint_small_png);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 269,
    "end_line": 269,
    "code": "ta->icons[0].datalen = sizeof(lprint_small_png);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 270,
    "end_line": 270,
    "code": "ta->icons[1].data    = lprint_png;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 270,
    "end_line": 270,
    "code": "ta->icons[1].data    = lprint_png;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 271,
    "end_line": 271,
    "code": "ta->icons[1].datalen = sizeof(lprint_png);\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 271,
    "end_line": 271,
    "code": "ta->icons[1].datalen = sizeof(lprint_png);\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 271,
    "end_line": 271,
    "code": "ta->icons[1].datalen = sizeof(lprint_png);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 271,
    "end_line": 271,
    "code": "ta->icons[1].datalen = sizeof(lprint_png);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 272,
    "end_line": 272,
    "code": "ta->icons[2].data    = lprint_large_png;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 272,
    "end_line": 272,
    "code": "ta->icons[2].data    = lprint_large_png;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 273,
    "end_line": 273,
    "code": "ta->icons[2].datalen = sizeof(lprint_large_png);\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 273,
    "end_line": 273,
    "code": "ta->icons[2].datalen = sizeof(lprint_large_png);\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 273,
    "end_line": 273,
    "code": "ta->icons[2].datalen = sizeof(lprint_large_png);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 273,
    "end_line": 273,
    "code": "ta->icons[2].datalen = sizeof(lprint_large_png);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 276,
    "end_line": 276,
    "code": "ta->testpage_cb = lprintTestPageCB;\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 276,
    "end_line": 276,
    "code": "ta->testpage_cb = lprintTestPageCB;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "preprocessor",
    "start_line": 279,
    "end_line": 285,
    "code": "fdef LPRINT_EXPERIMENTAL\n  if (!strncmp(driver_name, \"brother_\", 8))\n    ret = lprintBrother(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else if (!strncmp(driver_name, \"cpcl_\", 5))\n    ret = lprintCPCL(system, driver_name, device_uri, device_id, data, attrs, cbdata);\n  else\n#endif /",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 298,
    "end_line": 311,
    "code": "r (i = 0; i < data->num_source; i ++)\n  {\n    pwg_media_t *pwg = pwgMediaForPWG(data->media_ready[i].size_name);\n\n    data->media_ready[i].bottom_margin = data->bottom_top;\n    data->media_ready[i].left_margin   = data->left_right;\n    data->media_ready[i].right_margin  = data->left_right;\n    data->media_ready[i].size_width    = pwg->width;\n    data->media_ready[i].size_length   = pwg->length;\n    data->media_ready[i].top_margin    = data->bottom_top;\n    papplCopyString(data->media_ready[i].source, data->source[i], sizeof(data->media_ready[i].source));\n    if (!data->media_ready[i].type[0])\n      papplCopyString(data->media_ready[i].type, data->type[0], sizeof(data->media_ready[i].type));\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 298,
    "end_line": 311,
    "code": "r (i = 0; i < data->num_source; i ++)\n  {\n    pwg_media_t *pwg = pwgMediaForPWG(data->media_ready[i].size_name);\n\n    data->media_ready[i].bottom_margin = data->bottom_top;\n    data->media_ready[i].left_margin   = data->left_right;\n    data->media_ready[i].right_margin  = data->left_right;\n    data->media_ready[i].size_width    = pwg->width;\n    data->media_ready[i].size_length   = pwg->length;\n    data->media_ready[i].top_margin    = data->bottom_top;\n    papplCopyString(data->media_ready[i].source, data->source[i], sizeof(data->media_ready[i].source));\n    if (!data->media_ready[i].type[0])\n      papplCopyString(data->media_ready[i].type, data->type[0], sizeof(data->media_ready[i].type));\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 299,
    "end_line": 311,
    "code": "    pwg_media_t *pwg = pwgMediaForPWG(data->media_ready[i].size_name);\n\n    data->media_ready[i].bottom_margin = data->bottom_top;\n    data->media_ready[i].left_margin   = data->left_right;\n    data->media_ready[i].right_margin  = data->left_right;\n    data->media_ready[i].size_width    = pwg->width;\n    data->media_ready[i].size_length   = pwg->length;\n    data->media_ready[i].top_margin    = data->bottom_top;\n    papplCopyString(data->media_ready[i].source, data->source[i], sizeof(data->media_ready[i].source));\n    if (!data->media_ready[i].type[0])\n      papplCopyString(data->media_ready[i].type, data->type[0], sizeof(data->media_ready[i].type));\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 299,
    "end_line": 311,
    "code": "    pwg_media_t *pwg = pwgMediaForPWG(data->media_ready[i].size_name);\n\n    data->media_ready[i].bottom_margin = data->bottom_top;\n    data->media_ready[i].left_margin   = data->left_right;\n    data->media_ready[i].right_margin  = data->left_right;\n    data->media_ready[i].size_width    = pwg->width;\n    data->media_ready[i].size_length   = pwg->length;\n    data->media_ready[i].top_margin    = data->bottom_top;\n    papplCopyString(data->media_ready[i].source, data->source[i], sizeof(data->media_ready[i].source));\n    if (!data->media_ready[i].type[0])\n      papplCopyString(data->media_ready[i].type, data->type[0], sizeof(data->media_ready[i].type));\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "global_variable",
    "start_line": 300,
    "end_line": 300,
    "code": "g_media_t *pwg = pwgMediaForPWG(data->media_ready[i].size_name);\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 300,
    "end_line": 300,
    "code": "g_media_t *pwg = pwgMediaForPWG(data->media_ready[i].size_name);\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 300,
    "end_line": 300,
    "code": "g_media_t *pwg = pwgMediaForPWG(data->media_ready[i].size_name);\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 300,
    "end_line": 300,
    "code": "wg = pwgMediaForPWG(data->media_ready[i].size_name);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 300,
    "end_line": 300,
    "code": "wg = pwgMediaForPWG(data->media_ready[i].size_name);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 302,
    "end_line": 302,
    "code": "ta->media_ready[i].bottom_margin = data->bottom_top;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 302,
    "end_line": 302,
    "code": "ta->media_ready[i].bottom_margin = data->bottom_top;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 303,
    "end_line": 303,
    "code": "ta->media_ready[i].left_margin   = data->left_right;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 303,
    "end_line": 303,
    "code": "ta->media_ready[i].left_margin   = data->left_right;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 304,
    "end_line": 304,
    "code": "ta->media_ready[i].right_margin  = data->left_right;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 304,
    "end_line": 304,
    "code": "ta->media_ready[i].right_margin  = data->left_right;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 305,
    "end_line": 305,
    "code": "ta->media_ready[i].size_width    = pwg->width;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 305,
    "end_line": 305,
    "code": "ta->media_ready[i].size_width    = pwg->width;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 306,
    "end_line": 306,
    "code": "ta->media_ready[i].size_length   = pwg->length;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 306,
    "end_line": 306,
    "code": "ta->media_ready[i].size_length   = pwg->length;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 307,
    "end_line": 307,
    "code": "ta->media_ready[i].top_margin    = data->bottom_top;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 307,
    "end_line": 307,
    "code": "ta->media_ready[i].top_margin    = data->bottom_top;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 314,
    "end_line": 314,
    "code": "ta->media_default = data->media_ready[0];\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 314,
    "end_line": 314,
    "code": "ta->media_default = data->media_ready[0];\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function",
    "start_line": 325,
    "end_line": 332,
    "name": "free_cb",
    "parent": null,
    "hierarchy": "free_cb",
    "code": "atic void\nfree_cb(lprint_device_t *dev)\t\t// I - Device entry\n{\n  free(dev->device_info);\n  free(dev->device_uri);\n  free(dev->device_id);\n  free(dev);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function",
    "start_line": 342,
    "end_line": 403,
    "name": "match_id",
    "parent": null,
    "hierarchy": "match_id",
    "code": "atic int\t\t\t\t// O - Score\nmatch_id(int           num_did,\t\t// I - Number of device ID key/value pairs\n         cups_option_t *did,\t\t// I - Device ID key/value pairs\n         const char    *match_id)\t// I - Driver's device ID match string\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tscore = 0,\t\t// Score\n\t\tnum_mid;\t\t// Number of match ID key/value pairs\n  cups_option_t\t*mid,\t\t\t// Match ID key/value pairs\n\t\t*current;\t\t// Current key/value pair\n  const char\t*value,\t\t\t// Device ID value\n\t\t*valptr;\t\t// Pointer into value\n\n\n  // Parse the matching device ID into key/value pairs...\n  if ((num_mid = papplDeviceParseID(match_id, &mid)) == 0)\n    return (0);\n\n  // Loop through the match pairs to find matches (or not)\n  for (i = num_mid, current = mid; i > 0; i --, current ++)\n  {\n    if ((value = cupsGetOption(current->name, num_did, did)) == NULL)\n    {\n      // No match\n      score = 0;\n      break;\n    }\n\n    if (!strcasecmp(current->value, value))\n    {\n      // Full match!\n      score += 2;\n    }\n    else if ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n  }\n\n  cupsFreeOptions(num_mid, mid);\n\n  return (score);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 342,
    "end_line": 403,
    "code": "atic int\t\t\t\t// O - Score\nmatch_id(int           num_did,\t\t// I - Number of device ID key/value pairs\n         cups_option_t *did,\t\t// I - Device ID key/value pairs\n         const char    *match_id)\t// I - Driver's device ID match string\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tscore = 0,\t\t// Score\n\t\tnum_mid;\t\t// Number of match ID key/value pairs\n  cups_option_t\t*mid,\t\t\t// Match ID key/value pairs\n\t\t*current;\t\t// Current key/value pair\n  const char\t*value,\t\t\t// Device ID value\n\t\t*valptr;\t\t// Pointer into value\n\n\n  // Parse the matching device ID into key/value pairs...\n  if ((num_mid = papplDeviceParseID(match_id, &mid)) == 0)\n    return (0);\n\n  // Loop through the match pairs to find matches (or not)\n  for (i = num_mid, current = mid; i > 0; i --, current ++)\n  {\n    if ((value = cupsGetOption(current->name, num_did, did)) == NULL)\n    {\n      // No match\n      score = 0;\n      break;\n    }\n\n    if (!strcasecmp(current->value, value))\n    {\n      // Full match!\n      score += 2;\n    }\n    else if ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n  }\n\n  cupsFreeOptions(num_mid, mid);\n\n  return (score);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 342,
    "end_line": 403,
    "code": "atic int\t\t\t\t// O - Score\nmatch_id(int           num_did,\t\t// I - Number of device ID key/value pairs\n         cups_option_t *did,\t\t// I - Device ID key/value pairs\n         const char    *match_id)\t// I - Driver's device ID match string\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tscore = 0,\t\t// Score\n\t\tnum_mid;\t\t// Number of match ID key/value pairs\n  cups_option_t\t*mid,\t\t\t// Match ID key/value pairs\n\t\t*current;\t\t// Current key/value pair\n  const char\t*value,\t\t\t// Device ID value\n\t\t*valptr;\t\t// Pointer into value\n\n\n  // Parse the matching device ID into key/value pairs...\n  if ((num_mid = papplDeviceParseID(match_id, &mid)) == 0)\n    return (0);\n\n  // Loop through the match pairs to find matches (or not)\n  for (i = num_mid, current = mid; i > 0; i --, current ++)\n  {\n    if ((value = cupsGetOption(current->name, num_did, did)) == NULL)\n    {\n      // No match\n      score = 0;\n      break;\n    }\n\n    if (!strcasecmp(current->value, value))\n    {\n      // Full match!\n      score += 2;\n    }\n    else if ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n  }\n\n  cupsFreeOptions(num_mid, mid);\n\n  return (score);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 346,
    "end_line": 403,
    "code": "  int\t\ti,\t\t\t// Looping var\n\t\tscore = 0,\t\t// Score\n\t\tnum_mid;\t\t// Number of match ID key/value pairs\n  cups_option_t\t*mid,\t\t\t// Match ID key/value pairs\n\t\t*current;\t\t// Current key/value pair\n  const char\t*value,\t\t\t// Device ID value\n\t\t*valptr;\t\t// Pointer into value\n\n\n  // Parse the matching device ID into key/value pairs...\n  if ((num_mid = papplDeviceParseID(match_id, &mid)) == 0)\n    return (0);\n\n  // Loop through the match pairs to find matches (or not)\n  for (i = num_mid, current = mid; i > 0; i --, current ++)\n  {\n    if ((value = cupsGetOption(current->name, num_did, did)) == NULL)\n    {\n      // No match\n      score = 0;\n      break;\n    }\n\n    if (!strcasecmp(current->value, value))\n    {\n      // Full match!\n      score += 2;\n    }\n    else if ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n  }\n\n  cupsFreeOptions(num_mid, mid);\n\n  return (score);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 346,
    "end_line": 403,
    "code": "  int\t\ti,\t\t\t// Looping var\n\t\tscore = 0,\t\t// Score\n\t\tnum_mid;\t\t// Number of match ID key/value pairs\n  cups_option_t\t*mid,\t\t\t// Match ID key/value pairs\n\t\t*current;\t\t// Current key/value pair\n  const char\t*value,\t\t\t// Device ID value\n\t\t*valptr;\t\t// Pointer into value\n\n\n  // Parse the matching device ID into key/value pairs...\n  if ((num_mid = papplDeviceParseID(match_id, &mid)) == 0)\n    return (0);\n\n  // Loop through the match pairs to find matches (or not)\n  for (i = num_mid, current = mid; i > 0; i --, current ++)\n  {\n    if ((value = cupsGetOption(current->name, num_did, did)) == NULL)\n    {\n      // No match\n      score = 0;\n      break;\n    }\n\n    if (!strcasecmp(current->value, value))\n    {\n      // Full match!\n      score += 2;\n    }\n    else if ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n  }\n\n  cupsFreeOptions(num_mid, mid);\n\n  return (score);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "global_variable",
    "start_line": 347,
    "end_line": 349,
    "code": "t\t\ti,\t\t\t// Looping var\n\t\tscore = 0,\t\t// Score\n\t\tnum_mid;\t\t",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 361,
    "end_line": 398,
    "code": "r (i = num_mid, current = mid; i > 0; i --, current ++)\n  {\n    if ((value = cupsGetOption(current->name, num_did, did)) == NULL)\n    {\n      // No match\n      score = 0;\n      break;\n    }\n\n    if (!strcasecmp(current->value, value))\n    {\n      // Full match!\n      score += 2;\n    }\n    else if ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 361,
    "end_line": 398,
    "code": "r (i = num_mid, current = mid; i > 0; i --, current ++)\n  {\n    if ((value = cupsGetOption(current->name, num_did, did)) == NULL)\n    {\n      // No match\n      score = 0;\n      break;\n    }\n\n    if (!strcasecmp(current->value, value))\n    {\n      // Full match!\n      score += 2;\n    }\n    else if ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 362,
    "end_line": 398,
    "code": "    if ((value = cupsGetOption(current->name, num_did, did)) == NULL)\n    {\n      // No match\n      score = 0;\n      break;\n    }\n\n    if (!strcasecmp(current->value, value))\n    {\n      // Full match!\n      score += 2;\n    }\n    else if ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 362,
    "end_line": 398,
    "code": "    if ((value = cupsGetOption(current->name, num_did, did)) == NULL)\n    {\n      // No match\n      score = 0;\n      break;\n    }\n\n    if (!strcasecmp(current->value, value))\n    {\n      // Full match!\n      score += 2;\n    }\n    else if ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 363,
    "end_line": 368,
    "code": " ((value = cupsGetOption(current->name, num_did, did)) == NULL)\n    {\n      // No match\n      score = 0;\n      break;\n    }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 363,
    "end_line": 368,
    "code": " ((value = cupsGetOption(current->name, num_did, did)) == NULL)\n    {\n      // No match\n      score = 0;\n      break;\n    }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 363,
    "end_line": 363,
    "code": "value = cupsGetOption(current->name, num_did, did)) == NULL)\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 363,
    "end_line": 363,
    "code": "alue = cupsGetOption(current->name, num_did, did)) == NULL)\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 363,
    "end_line": 363,
    "code": "alue = cupsGetOption(current->name, num_did, did)) =",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 363,
    "end_line": 363,
    "code": "lue = cupsGetOption(current->name, num_did, did)) ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 370,
    "end_line": 397,
    "code": " (!strcasecmp(current->value, value))\n    {\n      // Full match!\n      score += 2;\n    }\n    else if ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 370,
    "end_line": 397,
    "code": " (!strcasecmp(current->value, value))\n    {\n      // Full match!\n      score += 2;\n    }\n    else if ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 375,
    "end_line": 397,
    "code": "se if ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 375,
    "end_line": 397,
    "code": "se if ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 375,
    "end_line": 397,
    "code": " ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 375,
    "end_line": 397,
    "code": " ((valptr = strstr(value, current->value)) != NULL)\n    {\n      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n    else\n    {\n      // No match\n      score = 0;\n      break;\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 375,
    "end_line": 375,
    "code": "valptr = strstr(value, current->value)) != NULL)\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 375,
    "end_line": 375,
    "code": "alptr = strstr(value, current->value)) != NULL)\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 375,
    "end_line": 375,
    "code": "alptr = strstr(value, current->value)) !",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 375,
    "end_line": 375,
    "code": "lptr = strstr(value, current->value)) ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 376,
    "end_line": 391,
    "code": "      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 376,
    "end_line": 391,
    "code": "      // Possible substring match, check\n      size_t mlen = strlen(current->value);\n\t\t\t\t\t// Length of match value\n      if ((valptr == value || valptr[-1] == ',') && (!valptr[mlen] || valptr[mlen] == ','))\n      {\n        // Partial match!\n        score ++;\n      }\n      else\n      {\n        // No match\n        score = 0;\n        break;\n      }\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "global_variable",
    "start_line": 378,
    "end_line": 378,
    "code": "ze_t mlen = strlen(current->value);\n\t",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 378,
    "end_line": 378,
    "code": "ze_t mlen = strlen(current->value);\n\t",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 378,
    "end_line": 378,
    "code": "ze_t mlen = strlen(current->value);\n\t",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 378,
    "end_line": 378,
    "code": "en = strlen(current->value);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 378,
    "end_line": 378,
    "code": "en = strlen(current->value);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function",
    "start_line": 410,
    "end_line": 427,
    "name": null,
    "parent": null,
    "hierarchy": null,
    "code": "atic const char *\t\t\t// O - MIME media type or `NULL` if none\nmime_cb(const unsigned char *header,\t// I - Header data\n        size_t              headersize,\t// I - Size of header data\n        void                *cbdata)\t// I - Callback data (not used)\n{\n  char\ttestpage[] = LPRINT_TESTPAGE_HEADER;\n\t\t\t\t\t// Test page file header\n\n\n  if (headersize >= sizeof(testpage) && !memcmp(header, testpage, sizeof(testpage)))\n    return (LPRINT_TESTPAGE_MIMETYPE);\n  else if (headersize >= 2 && header[0] == '^' && isupper(header[1] & 255))\n    return (LPRINT_ZPL_MIMETYPE);\n  else if (headersize >= 3 && !memcmp(header, \"\\nN\\n\", 3))\n    return (LPRINT_EPL2_MIMETYPE);\n  else\n    return (NULL);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "global_variable",
    "start_line": 415,
    "end_line": 415,
    "code": "ar\ttestpage[] = LPRINT_TESTPAGE_HEADER;\n\t",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function",
    "start_line": 434,
    "end_line": 450,
    "name": "printer_cb",
    "parent": null,
    "hierarchy": "printer_cb",
    "code": "atic bool\t\t\t\t// O - `false` to continue\nprinter_cb(const char   *device_info,\t// I - Device information\n\t   const char   *device_uri,\t// I - Device URI\n\t   const char   *device_id,\t// I - IEEE-1284 device ID\n\t   cups_array_t *devices)\t// I - Device array\n{\n  lprint_device_t\tdev;\t\t// New device\n\n\n  dev.device_info = (char *)device_info;\n  dev.device_uri  = (char *)device_uri;\n  dev.device_id   = (char *)device_id;\n\n  cupsArrayAdd(devices, &dev);\n\n  return (false);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 434,
    "end_line": 450,
    "code": "atic bool\t\t\t\t// O - `false` to continue\nprinter_cb(const char   *device_info,\t// I - Device information\n\t   const char   *device_uri,\t// I - Device URI\n\t   const char   *device_id,\t// I - IEEE-1284 device ID\n\t   cups_array_t *devices)\t// I - Device array\n{\n  lprint_device_t\tdev;\t\t// New device\n\n\n  dev.device_info = (char *)device_info;\n  dev.device_uri  = (char *)device_uri;\n  dev.device_id   = (char *)device_id;\n\n  cupsArrayAdd(devices, &dev);\n\n  return (false);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 439,
    "end_line": 450,
    "code": "  lprint_device_t\tdev;\t\t// New device\n\n\n  dev.device_info = (char *)device_info;\n  dev.device_uri  = (char *)device_uri;\n  dev.device_id   = (char *)device_id;\n\n  cupsArrayAdd(devices, &dev);\n\n  return (false);\n}\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 443,
    "end_line": 443,
    "code": "v.device_info = (char *)device_info;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 443,
    "end_line": 443,
    "code": "v.device_info = (char *)device_info;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 444,
    "end_line": 444,
    "code": "v.device_uri  = (char *)device_uri;\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 444,
    "end_line": 444,
    "code": "v.device_uri  = (char *)device_uri;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 445,
    "end_line": 445,
    "code": "v.device_id   = (char *)device_id;\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 445,
    "end_line": 445,
    "code": "v.device_id   = (char *)device_id;\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function",
    "start_line": 457,
    "end_line": 609,
    "name": null,
    "parent": null,
    "hierarchy": null,
    "code": "atic pappl_system_t *\t\t\t// O - System object\nsystem_cb(\n    int           num_options,\t\t// I - Number options\n    cups_option_t *options,\t\t// I - Options\n    void          *data)\t\t// I - Callback data (unused)\n{\n  pappl_system_t\t*system;\t// System object\n  const char\t\t*val,\t\t// Current option value\n\t\t\t*hostname,\t// Hostname, if any\n\t\t\t*listenhost,\t// Listen hostname, if any\n\t\t\t*logfile,\t// Log file, if any\n\t\t\t*spooldir,\t// Spool directory, if any\n\t\t\t*system_name;\t// System name, if any\n  char\t\t\toldfile[1024];\t// Old configuration filename\n  pappl_loglevel_t\tloglevel;\t// Log level\n  int\t\t\tport = 0;\t// Port number, if any\n  pappl_soptions_t\tsoptions = PAPPL_SOPTIONS_MULTI_QUEUE | PAPPL_SOPTIONS_WEB_INTERFACE | PAPPL_SOPTIONS_WEB_LOG | PAPPL_SOPTIONS_WEB_SECURITY | PAPPL_SOPTIONS_WEB_TLS;\n\t\t\t\t\t// System options\n  static pappl_version_t versions[1] =\t// Software versions\n  {\n    { \"LPrint\", \"\", LPRINT_VERSION, { LPRINT_MAJOR_VERSION, LPRINT_MINOR_VERSION, LPRINT_PATCH_VERSION, 0 } }\n  };\n\n\n  (void)data;\n\n  // Parse standard log and server options...\n  if ((val = cupsGetOption(\"log-level\", num_options, options)) != NULL)\n  {\n    if (!strcmp(val, \"fatal\"))\n      loglevel = PAPPL_LOGLEVEL_FATAL;\n    else if (!strcmp(val, \"error\"))\n      loglevel = PAPPL_LOGLEVEL_ERROR;\n    else if (!strcmp(val, \"warn\"))\n      loglevel = PAPPL_LOGLEVEL_WARN;\n    else if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n  }\n  else\n    loglevel = PAPPL_LOGLEVEL_UNSPEC;\n\n  if ((val = cupsGetOption(\"server-options\", num_options, options)) != NULL)\n  {\n    const char\t*valptr;\t\t// Pointer into value\n\n    for (valptr = val; valptr && *valptr;)\n    {\n      if (!strcmp(valptr, \"none\") || !strncmp(valptr, \"none,\", 5))\n        soptions = PAPPL_SOPTIONS_NONE;\n      else if (!strcmp(valptr, \"dnssd-host\") || !strncmp(valptr, \"dnssd-host,\", 11))\n        soptions |= PAPPL_SOPTIONS_DNSSD_HOST;\n      else if (!strcmp(valptr, \"no-multi-queue\") || !strncmp(valptr, \"no-multi-queue,\", 15))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_MULTI_QUEUE;\n      else if (!strcmp(valptr, \"raw-socket\") || !strncmp(valptr, \"raw-socket,\", 11))\n        soptions |= PAPPL_SOPTIONS_RAW_SOCKET;\n      else if (!strcmp(valptr, \"usb-printer\") || !strncmp(valptr, \"usb-printer,\", 12))\n        soptions |= PAPPL_SOPTIONS_USB_PRINTER;\n      else if (!strcmp(valptr, \"no-web-interface\") || !strncmp(valptr, \"no-web-interface,\", 17))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_WEB_INTERFACE;\n      else if (!strcmp(valptr, \"web-log\") || !strncmp(valptr, \"web-log,\", 8))\n        soptions |= PAPPL_SOPTIONS_WEB_LOG;\n      else if (!strcmp(valptr, \"web-network\") || !strncmp(valptr, \"web-network,\", 12))\n        soptions |= PAPPL_SOPTIONS_WEB_NETWORK;\n      else if (!strcmp(valptr, \"web-remote\") || !strncmp(valptr, \"web-remote,\", 11))\n        soptions |= PAPPL_SOPTIONS_WEB_REMOTE;\n      else if (!strcmp(valptr, \"web-security\") || !strncmp(valptr, \"web-security,\", 13))\n        soptions |= PAPPL_SOPTIONS_WEB_SECURITY;\n      else if (!strcmp(valptr, \"no-tls\") || !strncmp(valptr, \"no-tls,\", 7))\n        soptions = (pappl_soptions_t)((soptions | PAPPL_SOPTIONS_NO_TLS) & ~PAPPL_SOPTIONS_WEB_TLS);\n\n      if ((valptr = strchr(valptr, ',')) != NULL)\n        valptr ++;\n    }\n  }\n\n  hostname    = cupsGetOption(\"server-hostname\", num_options, options);\n  listenhost  = cupsGetOption(\"listen-hostname\", num_options, options);\n  logfile     = cupsGetOption(\"log-file\", num_options, options);\n  spooldir    = cupsGetOption(\"spool-directory\", num_options, options);\n  system_name = cupsGetOption(\"system-name\", num_options, options);\n\n  if ((val = cupsGetOption(\"server-port\", num_options, options)) != NULL)\n  {\n    if (!isdigit(*val & 255))\n    {\n      fprintf(stderr, \"lprint: Bad server-port value '%s'.\\n\", val);\n      return (NULL);\n    }\n    else\n      port = atoi(val);\n  }\n\n  // Spool directory and state file...\n  if ((val = getenv(\"SNAP_DATA\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else if ((val = getenv(\"XDG_DATA_HOME\")) != NULL)\n  {\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n  }\n#ifdef _WIN32\n  else if ((val = getenv(\"USERPROFILE\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/AppData/Local/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/AppData/Local/lprint.ini\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/AppData/Local/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else\n  {\n    papplCopyString(oldfile, \"/lprint.ini\", sizeof(oldfile));\n    papplCopyString(lprint_statefile, \"/lprint.state\", sizeof(lprint_statefile));\n  }\n#else\n  else if ((val = getenv(\"HOME\")) != NULL)\n  {\n#  ifdef __APPLE__\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/Library/Application Support/lprint.d\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/Library/Application Support/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n#  else\n    snprintf(oldfile, sizeof(oldfile), \"%s/.config\", val);\n    if (access(oldfile, 0))\n    {\n      if (mkdir(oldfile, 0777))\n      {\n\tperror(oldfile);\n\treturn (NULL);\n      }\n    }\n\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/.config/lprint.state\", val);\n#  endif // __APPLE__\n  }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 457,
    "end_line": 609,
    "code": "atic pappl_system_t *\t\t\t// O - System object\nsystem_cb(\n    int           num_options,\t\t// I - Number options\n    cups_option_t *options,\t\t// I - Options\n    void          *data)\t\t// I - Callback data (unused)\n{\n  pappl_system_t\t*system;\t// System object\n  const char\t\t*val,\t\t// Current option value\n\t\t\t*hostname,\t// Hostname, if any\n\t\t\t*listenhost,\t// Listen hostname, if any\n\t\t\t*logfile,\t// Log file, if any\n\t\t\t*spooldir,\t// Spool directory, if any\n\t\t\t*system_name;\t// System name, if any\n  char\t\t\toldfile[1024];\t// Old configuration filename\n  pappl_loglevel_t\tloglevel;\t// Log level\n  int\t\t\tport = 0;\t// Port number, if any\n  pappl_soptions_t\tsoptions = PAPPL_SOPTIONS_MULTI_QUEUE | PAPPL_SOPTIONS_WEB_INTERFACE | PAPPL_SOPTIONS_WEB_LOG | PAPPL_SOPTIONS_WEB_SECURITY | PAPPL_SOPTIONS_WEB_TLS;\n\t\t\t\t\t// System options\n  static pappl_version_t versions[1] =\t// Software versions\n  {\n    { \"LPrint\", \"\", LPRINT_VERSION, { LPRINT_MAJOR_VERSION, LPRINT_MINOR_VERSION, LPRINT_PATCH_VERSION, 0 } }\n  };\n\n\n  (void)data;\n\n  // Parse standard log and server options...\n  if ((val = cupsGetOption(\"log-level\", num_options, options)) != NULL)\n  {\n    if (!strcmp(val, \"fatal\"))\n      loglevel = PAPPL_LOGLEVEL_FATAL;\n    else if (!strcmp(val, \"error\"))\n      loglevel = PAPPL_LOGLEVEL_ERROR;\n    else if (!strcmp(val, \"warn\"))\n      loglevel = PAPPL_LOGLEVEL_WARN;\n    else if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n  }\n  else\n    loglevel = PAPPL_LOGLEVEL_UNSPEC;\n\n  if ((val = cupsGetOption(\"server-options\", num_options, options)) != NULL)\n  {\n    const char\t*valptr;\t\t// Pointer into value\n\n    for (valptr = val; valptr && *valptr;)\n    {\n      if (!strcmp(valptr, \"none\") || !strncmp(valptr, \"none,\", 5))\n        soptions = PAPPL_SOPTIONS_NONE;\n      else if (!strcmp(valptr, \"dnssd-host\") || !strncmp(valptr, \"dnssd-host,\", 11))\n        soptions |= PAPPL_SOPTIONS_DNSSD_HOST;\n      else if (!strcmp(valptr, \"no-multi-queue\") || !strncmp(valptr, \"no-multi-queue,\", 15))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_MULTI_QUEUE;\n      else if (!strcmp(valptr, \"raw-socket\") || !strncmp(valptr, \"raw-socket,\", 11))\n        soptions |= PAPPL_SOPTIONS_RAW_SOCKET;\n      else if (!strcmp(valptr, \"usb-printer\") || !strncmp(valptr, \"usb-printer,\", 12))\n        soptions |= PAPPL_SOPTIONS_USB_PRINTER;\n      else if (!strcmp(valptr, \"no-web-interface\") || !strncmp(valptr, \"no-web-interface,\", 17))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_WEB_INTERFACE;\n      else if (!strcmp(valptr, \"web-log\") || !strncmp(valptr, \"web-log,\", 8))\n        soptions |= PAPPL_SOPTIONS_WEB_LOG;\n      else if (!strcmp(valptr, \"web-network\") || !strncmp(valptr, \"web-network,\", 12))\n        soptions |= PAPPL_SOPTIONS_WEB_NETWORK;\n      else if (!strcmp(valptr, \"web-remote\") || !strncmp(valptr, \"web-remote,\", 11))\n        soptions |= PAPPL_SOPTIONS_WEB_REMOTE;\n      else if (!strcmp(valptr, \"web-security\") || !strncmp(valptr, \"web-security,\", 13))\n        soptions |= PAPPL_SOPTIONS_WEB_SECURITY;\n      else if (!strcmp(valptr, \"no-tls\") || !strncmp(valptr, \"no-tls,\", 7))\n        soptions = (pappl_soptions_t)((soptions | PAPPL_SOPTIONS_NO_TLS) & ~PAPPL_SOPTIONS_WEB_TLS);\n\n      if ((valptr = strchr(valptr, ',')) != NULL)\n        valptr ++;\n    }\n  }\n\n  hostname    = cupsGetOption(\"server-hostname\", num_options, options);\n  listenhost  = cupsGetOption(\"listen-hostname\", num_options, options);\n  logfile     = cupsGetOption(\"log-file\", num_options, options);\n  spooldir    = cupsGetOption(\"spool-directory\", num_options, options);\n  system_name = cupsGetOption(\"system-name\", num_options, options);\n\n  if ((val = cupsGetOption(\"server-port\", num_options, options)) != NULL)\n  {\n    if (!isdigit(*val & 255))\n    {\n      fprintf(stderr, \"lprint: Bad server-port value '%s'.\\n\", val);\n      return (NULL);\n    }\n    else\n      port = atoi(val);\n  }\n\n  // Spool directory and state file...\n  if ((val = getenv(\"SNAP_DATA\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else if ((val = getenv(\"XDG_DATA_HOME\")) != NULL)\n  {\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n  }\n#ifdef _WIN32\n  else if ((val = getenv(\"USERPROFILE\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/AppData/Local/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/AppData/Local/lprint.ini\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/AppData/Local/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else\n  {\n    papplCopyString(oldfile, \"/lprint.ini\", sizeof(oldfile));\n    papplCopyString(lprint_statefile, \"/lprint.state\", sizeof(lprint_statefile));\n  }\n#else\n  else if ((val = getenv(\"HOME\")) != NULL)\n  {\n#  ifdef __APPLE__\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/Library/Application Support/lprint.d\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/Library/Application Support/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n#  else\n    snprintf(oldfile, sizeof(oldfile), \"%s/.config\", val);\n    if (access(oldfile, 0))\n    {\n      if (mkdir(oldfile, 0777))\n      {\n\tperror(oldfile);\n\treturn (NULL);\n      }\n    }\n\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/.config/lprint.state\", val);\n#  endif // __APPLE__\n  }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 457,
    "end_line": 609,
    "code": "atic pappl_system_t *\t\t\t// O - System object\nsystem_cb(\n    int           num_options,\t\t// I - Number options\n    cups_option_t *options,\t\t// I - Options\n    void          *data)\t\t// I - Callback data (unused)\n{\n  pappl_system_t\t*system;\t// System object\n  const char\t\t*val,\t\t// Current option value\n\t\t\t*hostname,\t// Hostname, if any\n\t\t\t*listenhost,\t// Listen hostname, if any\n\t\t\t*logfile,\t// Log file, if any\n\t\t\t*spooldir,\t// Spool directory, if any\n\t\t\t*system_name;\t// System name, if any\n  char\t\t\toldfile[1024];\t// Old configuration filename\n  pappl_loglevel_t\tloglevel;\t// Log level\n  int\t\t\tport = 0;\t// Port number, if any\n  pappl_soptions_t\tsoptions = PAPPL_SOPTIONS_MULTI_QUEUE | PAPPL_SOPTIONS_WEB_INTERFACE | PAPPL_SOPTIONS_WEB_LOG | PAPPL_SOPTIONS_WEB_SECURITY | PAPPL_SOPTIONS_WEB_TLS;\n\t\t\t\t\t// System options\n  static pappl_version_t versions[1] =\t// Software versions\n  {\n    { \"LPrint\", \"\", LPRINT_VERSION, { LPRINT_MAJOR_VERSION, LPRINT_MINOR_VERSION, LPRINT_PATCH_VERSION, 0 } }\n  };\n\n\n  (void)data;\n\n  // Parse standard log and server options...\n  if ((val = cupsGetOption(\"log-level\", num_options, options)) != NULL)\n  {\n    if (!strcmp(val, \"fatal\"))\n      loglevel = PAPPL_LOGLEVEL_FATAL;\n    else if (!strcmp(val, \"error\"))\n      loglevel = PAPPL_LOGLEVEL_ERROR;\n    else if (!strcmp(val, \"warn\"))\n      loglevel = PAPPL_LOGLEVEL_WARN;\n    else if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n  }\n  else\n    loglevel = PAPPL_LOGLEVEL_UNSPEC;\n\n  if ((val = cupsGetOption(\"server-options\", num_options, options)) != NULL)\n  {\n    const char\t*valptr;\t\t// Pointer into value\n\n    for (valptr = val; valptr && *valptr;)\n    {\n      if (!strcmp(valptr, \"none\") || !strncmp(valptr, \"none,\", 5))\n        soptions = PAPPL_SOPTIONS_NONE;\n      else if (!strcmp(valptr, \"dnssd-host\") || !strncmp(valptr, \"dnssd-host,\", 11))\n        soptions |= PAPPL_SOPTIONS_DNSSD_HOST;\n      else if (!strcmp(valptr, \"no-multi-queue\") || !strncmp(valptr, \"no-multi-queue,\", 15))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_MULTI_QUEUE;\n      else if (!strcmp(valptr, \"raw-socket\") || !strncmp(valptr, \"raw-socket,\", 11))\n        soptions |= PAPPL_SOPTIONS_RAW_SOCKET;\n      else if (!strcmp(valptr, \"usb-printer\") || !strncmp(valptr, \"usb-printer,\", 12))\n        soptions |= PAPPL_SOPTIONS_USB_PRINTER;\n      else if (!strcmp(valptr, \"no-web-interface\") || !strncmp(valptr, \"no-web-interface,\", 17))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_WEB_INTERFACE;\n      else if (!strcmp(valptr, \"web-log\") || !strncmp(valptr, \"web-log,\", 8))\n        soptions |= PAPPL_SOPTIONS_WEB_LOG;\n      else if (!strcmp(valptr, \"web-network\") || !strncmp(valptr, \"web-network,\", 12))\n        soptions |= PAPPL_SOPTIONS_WEB_NETWORK;\n      else if (!strcmp(valptr, \"web-remote\") || !strncmp(valptr, \"web-remote,\", 11))\n        soptions |= PAPPL_SOPTIONS_WEB_REMOTE;\n      else if (!strcmp(valptr, \"web-security\") || !strncmp(valptr, \"web-security,\", 13))\n        soptions |= PAPPL_SOPTIONS_WEB_SECURITY;\n      else if (!strcmp(valptr, \"no-tls\") || !strncmp(valptr, \"no-tls,\", 7))\n        soptions = (pappl_soptions_t)((soptions | PAPPL_SOPTIONS_NO_TLS) & ~PAPPL_SOPTIONS_WEB_TLS);\n\n      if ((valptr = strchr(valptr, ',')) != NULL)\n        valptr ++;\n    }\n  }\n\n  hostname    = cupsGetOption(\"server-hostname\", num_options, options);\n  listenhost  = cupsGetOption(\"listen-hostname\", num_options, options);\n  logfile     = cupsGetOption(\"log-file\", num_options, options);\n  spooldir    = cupsGetOption(\"spool-directory\", num_options, options);\n  system_name = cupsGetOption(\"system-name\", num_options, options);\n\n  if ((val = cupsGetOption(\"server-port\", num_options, options)) != NULL)\n  {\n    if (!isdigit(*val & 255))\n    {\n      fprintf(stderr, \"lprint: Bad server-port value '%s'.\\n\", val);\n      return (NULL);\n    }\n    else\n      port = atoi(val);\n  }\n\n  // Spool directory and state file...\n  if ((val = getenv(\"SNAP_DATA\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else if ((val = getenv(\"XDG_DATA_HOME\")) != NULL)\n  {\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n  }\n#ifdef _WIN32\n  else if ((val = getenv(\"USERPROFILE\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/AppData/Local/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/AppData/Local/lprint.ini\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/AppData/Local/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else\n  {\n    papplCopyString(oldfile, \"/lprint.ini\", sizeof(oldfile));\n    papplCopyString(lprint_statefile, \"/lprint.state\", sizeof(lprint_statefile));\n  }\n#else\n  else if ((val = getenv(\"HOME\")) != NULL)\n  {\n#  ifdef __APPLE__\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/Library/Application Support/lprint.d\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/Library/Application Support/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n#  else\n    snprintf(oldfile, sizeof(oldfile), \"%s/.config\", val);\n    if (access(oldfile, 0))\n    {\n      if (mkdir(oldfile, 0777))\n      {\n\tperror(oldfile);\n\treturn (NULL);\n      }\n    }\n\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/.config/lprint.state\", val);\n#  endif // __APPLE__\n  }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 462,
    "end_line": 609,
    "code": "  pappl_system_t\t*system;\t// System object\n  const char\t\t*val,\t\t// Current option value\n\t\t\t*hostname,\t// Hostname, if any\n\t\t\t*listenhost,\t// Listen hostname, if any\n\t\t\t*logfile,\t// Log file, if any\n\t\t\t*spooldir,\t// Spool directory, if any\n\t\t\t*system_name;\t// System name, if any\n  char\t\t\toldfile[1024];\t// Old configuration filename\n  pappl_loglevel_t\tloglevel;\t// Log level\n  int\t\t\tport = 0;\t// Port number, if any\n  pappl_soptions_t\tsoptions = PAPPL_SOPTIONS_MULTI_QUEUE | PAPPL_SOPTIONS_WEB_INTERFACE | PAPPL_SOPTIONS_WEB_LOG | PAPPL_SOPTIONS_WEB_SECURITY | PAPPL_SOPTIONS_WEB_TLS;\n\t\t\t\t\t// System options\n  static pappl_version_t versions[1] =\t// Software versions\n  {\n    { \"LPrint\", \"\", LPRINT_VERSION, { LPRINT_MAJOR_VERSION, LPRINT_MINOR_VERSION, LPRINT_PATCH_VERSION, 0 } }\n  };\n\n\n  (void)data;\n\n  // Parse standard log and server options...\n  if ((val = cupsGetOption(\"log-level\", num_options, options)) != NULL)\n  {\n    if (!strcmp(val, \"fatal\"))\n      loglevel = PAPPL_LOGLEVEL_FATAL;\n    else if (!strcmp(val, \"error\"))\n      loglevel = PAPPL_LOGLEVEL_ERROR;\n    else if (!strcmp(val, \"warn\"))\n      loglevel = PAPPL_LOGLEVEL_WARN;\n    else if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n  }\n  else\n    loglevel = PAPPL_LOGLEVEL_UNSPEC;\n\n  if ((val = cupsGetOption(\"server-options\", num_options, options)) != NULL)\n  {\n    const char\t*valptr;\t\t// Pointer into value\n\n    for (valptr = val; valptr && *valptr;)\n    {\n      if (!strcmp(valptr, \"none\") || !strncmp(valptr, \"none,\", 5))\n        soptions = PAPPL_SOPTIONS_NONE;\n      else if (!strcmp(valptr, \"dnssd-host\") || !strncmp(valptr, \"dnssd-host,\", 11))\n        soptions |= PAPPL_SOPTIONS_DNSSD_HOST;\n      else if (!strcmp(valptr, \"no-multi-queue\") || !strncmp(valptr, \"no-multi-queue,\", 15))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_MULTI_QUEUE;\n      else if (!strcmp(valptr, \"raw-socket\") || !strncmp(valptr, \"raw-socket,\", 11))\n        soptions |= PAPPL_SOPTIONS_RAW_SOCKET;\n      else if (!strcmp(valptr, \"usb-printer\") || !strncmp(valptr, \"usb-printer,\", 12))\n        soptions |= PAPPL_SOPTIONS_USB_PRINTER;\n      else if (!strcmp(valptr, \"no-web-interface\") || !strncmp(valptr, \"no-web-interface,\", 17))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_WEB_INTERFACE;\n      else if (!strcmp(valptr, \"web-log\") || !strncmp(valptr, \"web-log,\", 8))\n        soptions |= PAPPL_SOPTIONS_WEB_LOG;\n      else if (!strcmp(valptr, \"web-network\") || !strncmp(valptr, \"web-network,\", 12))\n        soptions |= PAPPL_SOPTIONS_WEB_NETWORK;\n      else if (!strcmp(valptr, \"web-remote\") || !strncmp(valptr, \"web-remote,\", 11))\n        soptions |= PAPPL_SOPTIONS_WEB_REMOTE;\n      else if (!strcmp(valptr, \"web-security\") || !strncmp(valptr, \"web-security,\", 13))\n        soptions |= PAPPL_SOPTIONS_WEB_SECURITY;\n      else if (!strcmp(valptr, \"no-tls\") || !strncmp(valptr, \"no-tls,\", 7))\n        soptions = (pappl_soptions_t)((soptions | PAPPL_SOPTIONS_NO_TLS) & ~PAPPL_SOPTIONS_WEB_TLS);\n\n      if ((valptr = strchr(valptr, ',')) != NULL)\n        valptr ++;\n    }\n  }\n\n  hostname    = cupsGetOption(\"server-hostname\", num_options, options);\n  listenhost  = cupsGetOption(\"listen-hostname\", num_options, options);\n  logfile     = cupsGetOption(\"log-file\", num_options, options);\n  spooldir    = cupsGetOption(\"spool-directory\", num_options, options);\n  system_name = cupsGetOption(\"system-name\", num_options, options);\n\n  if ((val = cupsGetOption(\"server-port\", num_options, options)) != NULL)\n  {\n    if (!isdigit(*val & 255))\n    {\n      fprintf(stderr, \"lprint: Bad server-port value '%s'.\\n\", val);\n      return (NULL);\n    }\n    else\n      port = atoi(val);\n  }\n\n  // Spool directory and state file...\n  if ((val = getenv(\"SNAP_DATA\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else if ((val = getenv(\"XDG_DATA_HOME\")) != NULL)\n  {\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n  }\n#ifdef _WIN32\n  else if ((val = getenv(\"USERPROFILE\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/AppData/Local/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/AppData/Local/lprint.ini\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/AppData/Local/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else\n  {\n    papplCopyString(oldfile, \"/lprint.ini\", sizeof(oldfile));\n    papplCopyString(lprint_statefile, \"/lprint.state\", sizeof(lprint_statefile));\n  }\n#else\n  else if ((val = getenv(\"HOME\")) != NULL)\n  {\n#  ifdef __APPLE__\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/Library/Application Support/lprint.d\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/Library/Application Support/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n#  else\n    snprintf(oldfile, sizeof(oldfile), \"%s/.config\", val);\n    if (access(oldfile, 0))\n    {\n      if (mkdir(oldfile, 0777))\n      {\n\tperror(oldfile);\n\treturn (NULL);\n      }\n    }\n\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/.config/lprint.state\", val);\n#  endif // __APPLE__\n  }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 462,
    "end_line": 609,
    "code": "  pappl_system_t\t*system;\t// System object\n  const char\t\t*val,\t\t// Current option value\n\t\t\t*hostname,\t// Hostname, if any\n\t\t\t*listenhost,\t// Listen hostname, if any\n\t\t\t*logfile,\t// Log file, if any\n\t\t\t*spooldir,\t// Spool directory, if any\n\t\t\t*system_name;\t// System name, if any\n  char\t\t\toldfile[1024];\t// Old configuration filename\n  pappl_loglevel_t\tloglevel;\t// Log level\n  int\t\t\tport = 0;\t// Port number, if any\n  pappl_soptions_t\tsoptions = PAPPL_SOPTIONS_MULTI_QUEUE | PAPPL_SOPTIONS_WEB_INTERFACE | PAPPL_SOPTIONS_WEB_LOG | PAPPL_SOPTIONS_WEB_SECURITY | PAPPL_SOPTIONS_WEB_TLS;\n\t\t\t\t\t// System options\n  static pappl_version_t versions[1] =\t// Software versions\n  {\n    { \"LPrint\", \"\", LPRINT_VERSION, { LPRINT_MAJOR_VERSION, LPRINT_MINOR_VERSION, LPRINT_PATCH_VERSION, 0 } }\n  };\n\n\n  (void)data;\n\n  // Parse standard log and server options...\n  if ((val = cupsGetOption(\"log-level\", num_options, options)) != NULL)\n  {\n    if (!strcmp(val, \"fatal\"))\n      loglevel = PAPPL_LOGLEVEL_FATAL;\n    else if (!strcmp(val, \"error\"))\n      loglevel = PAPPL_LOGLEVEL_ERROR;\n    else if (!strcmp(val, \"warn\"))\n      loglevel = PAPPL_LOGLEVEL_WARN;\n    else if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n  }\n  else\n    loglevel = PAPPL_LOGLEVEL_UNSPEC;\n\n  if ((val = cupsGetOption(\"server-options\", num_options, options)) != NULL)\n  {\n    const char\t*valptr;\t\t// Pointer into value\n\n    for (valptr = val; valptr && *valptr;)\n    {\n      if (!strcmp(valptr, \"none\") || !strncmp(valptr, \"none,\", 5))\n        soptions = PAPPL_SOPTIONS_NONE;\n      else if (!strcmp(valptr, \"dnssd-host\") || !strncmp(valptr, \"dnssd-host,\", 11))\n        soptions |= PAPPL_SOPTIONS_DNSSD_HOST;\n      else if (!strcmp(valptr, \"no-multi-queue\") || !strncmp(valptr, \"no-multi-queue,\", 15))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_MULTI_QUEUE;\n      else if (!strcmp(valptr, \"raw-socket\") || !strncmp(valptr, \"raw-socket,\", 11))\n        soptions |= PAPPL_SOPTIONS_RAW_SOCKET;\n      else if (!strcmp(valptr, \"usb-printer\") || !strncmp(valptr, \"usb-printer,\", 12))\n        soptions |= PAPPL_SOPTIONS_USB_PRINTER;\n      else if (!strcmp(valptr, \"no-web-interface\") || !strncmp(valptr, \"no-web-interface,\", 17))\n        soptions &= (pappl_soptions_t)~PAPPL_SOPTIONS_WEB_INTERFACE;\n      else if (!strcmp(valptr, \"web-log\") || !strncmp(valptr, \"web-log,\", 8))\n        soptions |= PAPPL_SOPTIONS_WEB_LOG;\n      else if (!strcmp(valptr, \"web-network\") || !strncmp(valptr, \"web-network,\", 12))\n        soptions |= PAPPL_SOPTIONS_WEB_NETWORK;\n      else if (!strcmp(valptr, \"web-remote\") || !strncmp(valptr, \"web-remote,\", 11))\n        soptions |= PAPPL_SOPTIONS_WEB_REMOTE;\n      else if (!strcmp(valptr, \"web-security\") || !strncmp(valptr, \"web-security,\", 13))\n        soptions |= PAPPL_SOPTIONS_WEB_SECURITY;\n      else if (!strcmp(valptr, \"no-tls\") || !strncmp(valptr, \"no-tls,\", 7))\n        soptions = (pappl_soptions_t)((soptions | PAPPL_SOPTIONS_NO_TLS) & ~PAPPL_SOPTIONS_WEB_TLS);\n\n      if ((valptr = strchr(valptr, ',')) != NULL)\n        valptr ++;\n    }\n  }\n\n  hostname    = cupsGetOption(\"server-hostname\", num_options, options);\n  listenhost  = cupsGetOption(\"listen-hostname\", num_options, options);\n  logfile     = cupsGetOption(\"log-file\", num_options, options);\n  spooldir    = cupsGetOption(\"spool-directory\", num_options, options);\n  system_name = cupsGetOption(\"system-name\", num_options, options);\n\n  if ((val = cupsGetOption(\"server-port\", num_options, options)) != NULL)\n  {\n    if (!isdigit(*val & 255))\n    {\n      fprintf(stderr, \"lprint: Bad server-port value '%s'.\\n\", val);\n      return (NULL);\n    }\n    else\n      port = atoi(val);\n  }\n\n  // Spool directory and state file...\n  if ((val = getenv(\"SNAP_DATA\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else if ((val = getenv(\"XDG_DATA_HOME\")) != NULL)\n  {\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n  }\n#ifdef _WIN32\n  else if ((val = getenv(\"USERPROFILE\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/AppData/Local/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/AppData/Local/lprint.ini\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/AppData/Local/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else\n  {\n    papplCopyString(oldfile, \"/lprint.ini\", sizeof(oldfile));\n    papplCopyString(lprint_statefile, \"/lprint.state\", sizeof(lprint_statefile));\n  }\n#else\n  else if ((val = getenv(\"HOME\")) != NULL)\n  {\n#  ifdef __APPLE__\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/Library/Application Support/lprint.d\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/Library/Application Support/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n#  else\n    snprintf(oldfile, sizeof(oldfile), \"%s/.config\", val);\n    if (access(oldfile, 0))\n    {\n      if (mkdir(oldfile, 0777))\n      {\n\tperror(oldfile);\n\treturn (NULL);\n      }\n    }\n\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/.config/lprint.state\", val);\n#  endif // __APPLE__\n  }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "global_variable",
    "start_line": 472,
    "end_line": 472,
    "code": "t\t\t\tport = 0;\t/",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "global_variable",
    "start_line": 473,
    "end_line": 473,
    "code": "ppl_soptions_t\tsoptions = PAPPL_SOPTIONS_MULTI_QUEUE | PAPPL_SOPTIONS_WEB_INTERFACE | PAPPL_SOPTIONS_WEB_LOG | PAPPL_SOPTIONS_WEB_SECURITY | PAPPL_SOPTIONS_WEB_TLS;\n\t",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "global_variable",
    "start_line": 475,
    "end_line": 478,
    "code": "atic pappl_version_t versions[1] =\t// Software versions\n  {\n    { \"LPrint\", \"\", LPRINT_VERSION, { LPRINT_MAJOR_VERSION, LPRINT_MINOR_VERSION, LPRINT_PATCH_VERSION, 0 } }\n  };\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 476,
    "end_line": 478,
    "code": "    { \"LPrint\", \"\", LPRINT_VERSION, { LPRINT_MAJOR_VERSION, LPRINT_MINOR_VERSION, LPRINT_PATCH_VERSION, 0 } }\n  };\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 477,
    "end_line": 477,
    "code": "\"LPrint\", \"\", LPRINT_VERSION, { LPRINT_MAJOR_VERSION, LPRINT_MINOR_VERSION, LPRINT_PATCH_VERSION, 0 } }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 484,
    "end_line": 503,
    "code": " ((val = cupsGetOption(\"log-level\", num_options, options)) != NULL)\n  {\n    if (!strcmp(val, \"fatal\"))\n      loglevel = PAPPL_LOGLEVEL_FATAL;\n    else if (!strcmp(val, \"error\"))\n      loglevel = PAPPL_LOGLEVEL_ERROR;\n    else if (!strcmp(val, \"warn\"))\n      loglevel = PAPPL_LOGLEVEL_WARN;\n    else if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n  }\n  else\n    loglevel = PAPPL_LOGLEVEL_UNSPEC;\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 485,
    "end_line": 501,
    "code": "    if (!strcmp(val, \"fatal\"))\n      loglevel = PAPPL_LOGLEVEL_FATAL;\n    else if (!strcmp(val, \"error\"))\n      loglevel = PAPPL_LOGLEVEL_ERROR;\n    else if (!strcmp(val, \"warn\"))\n      loglevel = PAPPL_LOGLEVEL_WARN;\n    else if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n  }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 486,
    "end_line": 500,
    "code": " (!strcmp(val, \"fatal\"))\n      loglevel = PAPPL_LOGLEVEL_FATAL;\n    else if (!strcmp(val, \"error\"))\n      loglevel = PAPPL_LOGLEVEL_ERROR;\n    else if (!strcmp(val, \"warn\"))\n      loglevel = PAPPL_LOGLEVEL_WARN;\n    else if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 488,
    "end_line": 500,
    "code": "se if (!strcmp(val, \"error\"))\n      loglevel = PAPPL_LOGLEVEL_ERROR;\n    else if (!strcmp(val, \"warn\"))\n      loglevel = PAPPL_LOGLEVEL_WARN;\n    else if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 488,
    "end_line": 500,
    "code": " (!strcmp(val, \"error\"))\n      loglevel = PAPPL_LOGLEVEL_ERROR;\n    else if (!strcmp(val, \"warn\"))\n      loglevel = PAPPL_LOGLEVEL_WARN;\n    else if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 490,
    "end_line": 500,
    "code": "se if (!strcmp(val, \"warn\"))\n      loglevel = PAPPL_LOGLEVEL_WARN;\n    else if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 490,
    "end_line": 500,
    "code": " (!strcmp(val, \"warn\"))\n      loglevel = PAPPL_LOGLEVEL_WARN;\n    else if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 492,
    "end_line": 500,
    "code": "se if (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 492,
    "end_line": 500,
    "code": " (!strcmp(val, \"info\"))\n      loglevel = PAPPL_LOGLEVEL_INFO;\n    else if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 494,
    "end_line": 500,
    "code": "se if (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 494,
    "end_line": 500,
    "code": " (!strcmp(val, \"debug\"))\n      loglevel = PAPPL_LOGLEVEL_DEBUG;\n    else\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 496,
    "end_line": 500,
    "code": "se\n    {\n      fprintf(stderr, \"lprint: Bad log-level value '%s'.\\n\", val);\n      return (NULL);\n    }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 545,
    "end_line": 554,
    "code": " ((val = cupsGetOption(\"server-port\", num_options, options)) != NULL)\n  {\n    if (!isdigit(*val & 255))\n    {\n      fprintf(stderr, \"lprint: Bad server-port value '%s'.\\n\", val);\n      return (NULL);\n    }\n    else\n      port = atoi(val);\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 546,
    "end_line": 554,
    "code": "    if (!isdigit(*val & 255))\n    {\n      fprintf(stderr, \"lprint: Bad server-port value '%s'.\\n\", val);\n      return (NULL);\n    }\n    else\n      port = atoi(val);\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 547,
    "end_line": 553,
    "code": " (!isdigit(*val & 255))\n    {\n      fprintf(stderr, \"lprint: Bad server-port value '%s'.\\n\", val);\n      return (NULL);\n    }\n    else\n      port = atoi(val);\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 557,
    "end_line": 570,
    "code": " ((val = getenv(\"SNAP_DATA\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else if ((val = getenv(\"XDG_DATA_HOME\")) != NULL)\n  {\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n  }\n#",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 558,
    "end_line": 565,
    "code": "    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 566,
    "end_line": 570,
    "code": "se if ((val = getenv(\"XDG_DATA_HOME\")) != NULL)\n  {\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n  }\n#",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 566,
    "end_line": 570,
    "code": " ((val = getenv(\"XDG_DATA_HOME\")) != NULL)\n  {\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/lprint.state\", val);\n  }\n#",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "preprocessor",
    "start_line": 571,
    "end_line": 608,
    "code": "fdef _WIN32\n  else if ((val = getenv(\"USERPROFILE\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/AppData/Local/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/AppData/Local/lprint.ini\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/AppData/Local/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else\n  {\n    papplCopyString(oldfile, \"/lprint.ini\", sizeof(oldfile));\n    papplCopyString(lprint_statefile, \"/lprint.state\", sizeof(lprint_statefile));\n  }\n#else\n  else if ((val = getenv(\"HOME\")) != NULL)\n  {\n#  ifdef __APPLE__\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/Library/Application Support/lprint.d\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/Library/Application Support/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n#  else\n    snprintf(oldfile, sizeof(oldfile), \"%s/.config\", val);\n    if (access(oldfile, 0))\n    {\n      if (mkdir(oldfile, 0777))\n      {\n\tperror(oldfile);\n\treturn (NULL);\n      }\n    }\n\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/.config/lprint.state\", val);\n#  endif // __APPLE__\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 571,
    "end_line": 608,
    "code": "fdef _WIN32\n  else if ((val = getenv(\"USERPROFILE\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/AppData/Local/lprint.d\", val);\n    snprintf(oldfile, sizeof(oldfile), \"%s/AppData/Local/lprint.ini\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/AppData/Local/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else\n  {\n    papplCopyString(oldfile, \"/lprint.ini\", sizeof(oldfile));\n    papplCopyString(lprint_statefile, \"/lprint.state\", sizeof(lprint_statefile));\n  }\n#else\n  else if ((val = getenv(\"HOME\")) != NULL)\n  {\n#  ifdef __APPLE__\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/Library/Application Support/lprint.d\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/Library/Application Support/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n#  else\n    snprintf(oldfile, sizeof(oldfile), \"%s/.config\", val);\n    if (access(oldfile, 0))\n    {\n      if (mkdir(oldfile, 0777))\n      {\n\tperror(oldfile);\n\treturn (NULL);\n      }\n    }\n\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/.config/lprint.state\", val);\n#  endif // __APPLE__\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "global_variable",
    "start_line": 572,
    "end_line": 574,
    "code": "se if ((val = getenv(\"USERPROFILE\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/AppData/Local/lprint.d\", val);\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 572,
    "end_line": 574,
    "code": "se if ((val = getenv(\"USERPROFILE\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/AppData/Local/lprint.d\", val);\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 572,
    "end_line": 574,
    "code": " ((val = getenv(\"USERPROFILE\")) != NULL)\n  {\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/AppData/Local/lprint.d\", val);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 578,
    "end_line": 585,
    "code": " (!spooldir)\n      spooldir = lprint_spooldir;\n  }\n  else\n  {\n    papplCopyString(oldfile, \"/lprint.ini\", sizeof(oldfile));\n    papplCopyString(lprint_statefile, \"/lprint.state\", sizeof(lprint_statefile));\n  }\n#",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 581,
    "end_line": 585,
    "code": "se\n  {\n    papplCopyString(oldfile, \"/lprint.ini\", sizeof(oldfile));\n    papplCopyString(lprint_statefile, \"/lprint.state\", sizeof(lprint_statefile));\n  }\n#",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 586,
    "end_line": 608,
    "code": "lse\n  else if ((val = getenv(\"HOME\")) != NULL)\n  {\n#  ifdef __APPLE__\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/Library/Application Support/lprint.d\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/Library/Application Support/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n#  else\n    snprintf(oldfile, sizeof(oldfile), \"%s/.config\", val);\n    if (access(oldfile, 0))\n    {\n      if (mkdir(oldfile, 0777))\n      {\n\tperror(oldfile);\n\treturn (NULL);\n      }\n    }\n\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/.config/lprint.state\", val);\n#  endif /",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "preprocessor",
    "start_line": 589,
    "end_line": 608,
    "code": " ifdef __APPLE__\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/Library/Application Support/lprint.d\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/Library/Application Support/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n#  else\n    snprintf(oldfile, sizeof(oldfile), \"%s/.config\", val);\n    if (access(oldfile, 0))\n    {\n      if (mkdir(oldfile, 0777))\n      {\n\tperror(oldfile);\n\treturn (NULL);\n      }\n    }\n\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/.config/lprint.state\", val);\n#  endif /",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 589,
    "end_line": 608,
    "code": " ifdef __APPLE__\n    snprintf(lprint_spooldir, sizeof(lprint_spooldir), \"%s/Library/Application Support/lprint.d\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/Library/Application Support/lprint.state\", val);\n\n    if (!spooldir)\n      spooldir = lprint_spooldir;\n#  else\n    snprintf(oldfile, sizeof(oldfile), \"%s/.config\", val);\n    if (access(oldfile, 0))\n    {\n      if (mkdir(oldfile, 0777))\n      {\n\tperror(oldfile);\n\treturn (NULL);\n      }\n    }\n\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/.config/lprint.state\", val);\n#  endif /",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 595,
    "end_line": 607,
    "code": " else\n    snprintf(oldfile, sizeof(oldfile), \"%s/.config\", val);\n    if (access(oldfile, 0))\n    {\n      if (mkdir(oldfile, 0777))\n      {\n\tperror(oldfile);\n\treturn (NULL);\n      }\n    }\n\n    snprintf(oldfile, sizeof(oldfile), \"%s/.lprint.conf\", val);\n    snprintf(lprint_statefile, sizeof(lprint_statefile), \"%s/.config/lprint.state\", val);\n#",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "preprocessor",
    "start_line": 613,
    "end_line": 617,
    "code": " ifdef __APPLE__\n    papplCopyString(lprint_statefile, \"/private/var/lib/lprint.state\", sizeof(lprint_statefile));\n#  else\n    papplCopyString(lprint_statefile, \"/var/lib/lprint.state\", sizeof(lprint_statefile));\n#  endif /",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 640,
    "end_line": 644,
    "code": " (!cupsGetOption(\"private-server\", num_options, options))\n  {\n    // Listen for TCP/IP connections...\n    papplSystemAddListeners(system, listenhost);\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 669,
    "end_line": 736,
    "code": " (!papplSystemLoadState(system, lprint_statefile))\n  {\n    // No old state, use defaults and auto-add printers...\n    cups_array_t\t*devices;\t// Device array\n    lprint_device_t\t*dev;\t\t// Current device\n\n    papplSystemSetDNSSDName(system, system_name ? system_name : \"LPrint\");\n\n    papplLog(system, PAPPL_LOGLEVEL_INFO, \"Auto-adding printers...\");\n    devices = cupsArrayNew(NULL, NULL, NULL, 0, (cups_acopy_cb_t)copy_cb, (cups_afree_cb_t)free_cb);\n    papplDeviceList(PAPPL_DEVTYPE_USB, (pappl_device_cb_t)printer_cb, devices, papplLogDevice, system);\n\n    for (dev = (lprint_device_t *)cupsArrayGetFirst(devices); dev; dev = (lprint_device_t *)cupsArrayGetNext(devices))\n    {\n      const char *driver_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n\t\t\t\t\t// Driver name, if any\n\n      printf(\"%s (%s;%s) -> %s\\n\", dev->device_info, dev->device_uri, dev->device_id, driver_name);\n\n      if (driver_name)\n      {\n\tchar\tname[128],\t\t// Printer name\n\t\t*nameptr;\t\t// Pointer in name\n\n\t// Zebra puts \"Zebra Technologies ZTC\" on the front of their printer names,\n\t// which is a bit, um, wordy.  Clean up the device info string to use as a\n\t// printer name and drop any trailing \"(ID)\" nonsense if we don't need it.\n\tif (!strncasecmp(dev->device_info, \"Zebra Technologies ZTC \", 23))\n\t  snprintf(name, sizeof(name), \"Zebra %s\", dev->device_info + 23);\n\telse\n\t  papplCopyString(name, dev->device_info, sizeof(name));\n\n\tif ((nameptr = strstr(name, \" (\")) != NULL)\n\t  *nameptr = '\\0';\n\n\tif (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n      }\n    }\n\n    cupsArrayDelete(devices);\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 669,
    "end_line": 736,
    "code": " (!papplSystemLoadState(system, lprint_statefile))\n  {\n    // No old state, use defaults and auto-add printers...\n    cups_array_t\t*devices;\t// Device array\n    lprint_device_t\t*dev;\t\t// Current device\n\n    papplSystemSetDNSSDName(system, system_name ? system_name : \"LPrint\");\n\n    papplLog(system, PAPPL_LOGLEVEL_INFO, \"Auto-adding printers...\");\n    devices = cupsArrayNew(NULL, NULL, NULL, 0, (cups_acopy_cb_t)copy_cb, (cups_afree_cb_t)free_cb);\n    papplDeviceList(PAPPL_DEVTYPE_USB, (pappl_device_cb_t)printer_cb, devices, papplLogDevice, system);\n\n    for (dev = (lprint_device_t *)cupsArrayGetFirst(devices); dev; dev = (lprint_device_t *)cupsArrayGetNext(devices))\n    {\n      const char *driver_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n\t\t\t\t\t// Driver name, if any\n\n      printf(\"%s (%s;%s) -> %s\\n\", dev->device_info, dev->device_uri, dev->device_id, driver_name);\n\n      if (driver_name)\n      {\n\tchar\tname[128],\t\t// Printer name\n\t\t*nameptr;\t\t// Pointer in name\n\n\t// Zebra puts \"Zebra Technologies ZTC\" on the front of their printer names,\n\t// which is a bit, um, wordy.  Clean up the device info string to use as a\n\t// printer name and drop any trailing \"(ID)\" nonsense if we don't need it.\n\tif (!strncasecmp(dev->device_info, \"Zebra Technologies ZTC \", 23))\n\t  snprintf(name, sizeof(name), \"Zebra %s\", dev->device_info + 23);\n\telse\n\t  papplCopyString(name, dev->device_info, sizeof(name));\n\n\tif ((nameptr = strstr(name, \" (\")) != NULL)\n\t  *nameptr = '\\0';\n\n\tif (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n      }\n    }\n\n    cupsArrayDelete(devices);\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 670,
    "end_line": 736,
    "code": "    // No old state, use defaults and auto-add printers...\n    cups_array_t\t*devices;\t// Device array\n    lprint_device_t\t*dev;\t\t// Current device\n\n    papplSystemSetDNSSDName(system, system_name ? system_name : \"LPrint\");\n\n    papplLog(system, PAPPL_LOGLEVEL_INFO, \"Auto-adding printers...\");\n    devices = cupsArrayNew(NULL, NULL, NULL, 0, (cups_acopy_cb_t)copy_cb, (cups_afree_cb_t)free_cb);\n    papplDeviceList(PAPPL_DEVTYPE_USB, (pappl_device_cb_t)printer_cb, devices, papplLogDevice, system);\n\n    for (dev = (lprint_device_t *)cupsArrayGetFirst(devices); dev; dev = (lprint_device_t *)cupsArrayGetNext(devices))\n    {\n      const char *driver_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n\t\t\t\t\t// Driver name, if any\n\n      printf(\"%s (%s;%s) -> %s\\n\", dev->device_info, dev->device_uri, dev->device_id, driver_name);\n\n      if (driver_name)\n      {\n\tchar\tname[128],\t\t// Printer name\n\t\t*nameptr;\t\t// Pointer in name\n\n\t// Zebra puts \"Zebra Technologies ZTC\" on the front of their printer names,\n\t// which is a bit, um, wordy.  Clean up the device info string to use as a\n\t// printer name and drop any trailing \"(ID)\" nonsense if we don't need it.\n\tif (!strncasecmp(dev->device_info, \"Zebra Technologies ZTC \", 23))\n\t  snprintf(name, sizeof(name), \"Zebra %s\", dev->device_info + 23);\n\telse\n\t  papplCopyString(name, dev->device_info, sizeof(name));\n\n\tif ((nameptr = strstr(name, \" (\")) != NULL)\n\t  *nameptr = '\\0';\n\n\tif (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n      }\n    }\n\n    cupsArrayDelete(devices);\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 670,
    "end_line": 736,
    "code": "    // No old state, use defaults and auto-add printers...\n    cups_array_t\t*devices;\t// Device array\n    lprint_device_t\t*dev;\t\t// Current device\n\n    papplSystemSetDNSSDName(system, system_name ? system_name : \"LPrint\");\n\n    papplLog(system, PAPPL_LOGLEVEL_INFO, \"Auto-adding printers...\");\n    devices = cupsArrayNew(NULL, NULL, NULL, 0, (cups_acopy_cb_t)copy_cb, (cups_afree_cb_t)free_cb);\n    papplDeviceList(PAPPL_DEVTYPE_USB, (pappl_device_cb_t)printer_cb, devices, papplLogDevice, system);\n\n    for (dev = (lprint_device_t *)cupsArrayGetFirst(devices); dev; dev = (lprint_device_t *)cupsArrayGetNext(devices))\n    {\n      const char *driver_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n\t\t\t\t\t// Driver name, if any\n\n      printf(\"%s (%s;%s) -> %s\\n\", dev->device_info, dev->device_uri, dev->device_id, driver_name);\n\n      if (driver_name)\n      {\n\tchar\tname[128],\t\t// Printer name\n\t\t*nameptr;\t\t// Pointer in name\n\n\t// Zebra puts \"Zebra Technologies ZTC\" on the front of their printer names,\n\t// which is a bit, um, wordy.  Clean up the device info string to use as a\n\t// printer name and drop any trailing \"(ID)\" nonsense if we don't need it.\n\tif (!strncasecmp(dev->device_info, \"Zebra Technologies ZTC \", 23))\n\t  snprintf(name, sizeof(name), \"Zebra %s\", dev->device_info + 23);\n\telse\n\t  papplCopyString(name, dev->device_info, sizeof(name));\n\n\tif ((nameptr = strstr(name, \" (\")) != NULL)\n\t  *nameptr = '\\0';\n\n\tif (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n      }\n    }\n\n    cupsArrayDelete(devices);\n  }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 681,
    "end_line": 733,
    "code": "r (dev = (lprint_device_t *)cupsArrayGetFirst(devices); dev; dev = (lprint_device_t *)cupsArrayGetNext(devices))\n    {\n      const char *driver_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n\t\t\t\t\t// Driver name, if any\n\n      printf(\"%s (%s;%s) -> %s\\n\", dev->device_info, dev->device_uri, dev->device_id, driver_name);\n\n      if (driver_name)\n      {\n\tchar\tname[128],\t\t// Printer name\n\t\t*nameptr;\t\t// Pointer in name\n\n\t// Zebra puts \"Zebra Technologies ZTC\" on the front of their printer names,\n\t// which is a bit, um, wordy.  Clean up the device info string to use as a\n\t// printer name and drop any trailing \"(ID)\" nonsense if we don't need it.\n\tif (!strncasecmp(dev->device_info, \"Zebra Technologies ZTC \", 23))\n\t  snprintf(name, sizeof(name), \"Zebra %s\", dev->device_info + 23);\n\telse\n\t  papplCopyString(name, dev->device_info, sizeof(name));\n\n\tif ((nameptr = strstr(name, \" (\")) != NULL)\n\t  *nameptr = '\\0';\n\n\tif (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n      }\n    }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 681,
    "end_line": 733,
    "code": "r (dev = (lprint_device_t *)cupsArrayGetFirst(devices); dev; dev = (lprint_device_t *)cupsArrayGetNext(devices))\n    {\n      const char *driver_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n\t\t\t\t\t// Driver name, if any\n\n      printf(\"%s (%s;%s) -> %s\\n\", dev->device_info, dev->device_uri, dev->device_id, driver_name);\n\n      if (driver_name)\n      {\n\tchar\tname[128],\t\t// Printer name\n\t\t*nameptr;\t\t// Pointer in name\n\n\t// Zebra puts \"Zebra Technologies ZTC\" on the front of their printer names,\n\t// which is a bit, um, wordy.  Clean up the device info string to use as a\n\t// printer name and drop any trailing \"(ID)\" nonsense if we don't need it.\n\tif (!strncasecmp(dev->device_info, \"Zebra Technologies ZTC \", 23))\n\t  snprintf(name, sizeof(name), \"Zebra %s\", dev->device_info + 23);\n\telse\n\t  papplCopyString(name, dev->device_info, sizeof(name));\n\n\tif ((nameptr = strstr(name, \" (\")) != NULL)\n\t  *nameptr = '\\0';\n\n\tif (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n      }\n    }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 682,
    "end_line": 733,
    "code": "      const char *driver_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n\t\t\t\t\t// Driver name, if any\n\n      printf(\"%s (%s;%s) -> %s\\n\", dev->device_info, dev->device_uri, dev->device_id, driver_name);\n\n      if (driver_name)\n      {\n\tchar\tname[128],\t\t// Printer name\n\t\t*nameptr;\t\t// Pointer in name\n\n\t// Zebra puts \"Zebra Technologies ZTC\" on the front of their printer names,\n\t// which is a bit, um, wordy.  Clean up the device info string to use as a\n\t// printer name and drop any trailing \"(ID)\" nonsense if we don't need it.\n\tif (!strncasecmp(dev->device_info, \"Zebra Technologies ZTC \", 23))\n\t  snprintf(name, sizeof(name), \"Zebra %s\", dev->device_info + 23);\n\telse\n\t  papplCopyString(name, dev->device_info, sizeof(name));\n\n\tif ((nameptr = strstr(name, \" (\")) != NULL)\n\t  *nameptr = '\\0';\n\n\tif (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n      }\n    }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 682,
    "end_line": 733,
    "code": "      const char *driver_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n\t\t\t\t\t// Driver name, if any\n\n      printf(\"%s (%s;%s) -> %s\\n\", dev->device_info, dev->device_uri, dev->device_id, driver_name);\n\n      if (driver_name)\n      {\n\tchar\tname[128],\t\t// Printer name\n\t\t*nameptr;\t\t// Pointer in name\n\n\t// Zebra puts \"Zebra Technologies ZTC\" on the front of their printer names,\n\t// which is a bit, um, wordy.  Clean up the device info string to use as a\n\t// printer name and drop any trailing \"(ID)\" nonsense if we don't need it.\n\tif (!strncasecmp(dev->device_info, \"Zebra Technologies ZTC \", 23))\n\t  snprintf(name, sizeof(name), \"Zebra %s\", dev->device_info + 23);\n\telse\n\t  papplCopyString(name, dev->device_info, sizeof(name));\n\n\tif ((nameptr = strstr(name, \" (\")) != NULL)\n\t  *nameptr = '\\0';\n\n\tif (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n      }\n    }\n\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "global_variable",
    "start_line": 683,
    "end_line": 683,
    "code": "nst char *driver_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n\t",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 683,
    "end_line": 683,
    "code": "nst char *driver_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n\t",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 683,
    "end_line": 683,
    "code": "nst char *driver_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n\t",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 683,
    "end_line": 683,
    "code": "river_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 683,
    "end_line": 683,
    "code": "river_name = autoadd_cb(dev->device_info, dev->device_uri, dev->device_id, system);\n",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 688,
    "end_line": 732,
    "code": " (driver_name)\n      {\n\tchar\tname[128],\t\t// Printer name\n\t\t*nameptr;\t\t// Pointer in name\n\n\t// Zebra puts \"Zebra Technologies ZTC\" on the front of their printer names,\n\t// which is a bit, um, wordy.  Clean up the device info string to use as a\n\t// printer name and drop any trailing \"(ID)\" nonsense if we don't need it.\n\tif (!strncasecmp(dev->device_info, \"Zebra Technologies ZTC \", 23))\n\t  snprintf(name, sizeof(name), \"Zebra %s\", dev->device_info + 23);\n\telse\n\t  papplCopyString(name, dev->device_info, sizeof(name));\n\n\tif ((nameptr = strstr(name, \" (\")) != NULL)\n\t  *nameptr = '\\0';\n\n\tif (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n      }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 688,
    "end_line": 732,
    "code": " (driver_name)\n      {\n\tchar\tname[128],\t\t// Printer name\n\t\t*nameptr;\t\t// Pointer in name\n\n\t// Zebra puts \"Zebra Technologies ZTC\" on the front of their printer names,\n\t// which is a bit, um, wordy.  Clean up the device info string to use as a\n\t// printer name and drop any trailing \"(ID)\" nonsense if we don't need it.\n\tif (!strncasecmp(dev->device_info, \"Zebra Technologies ZTC \", 23))\n\t  snprintf(name, sizeof(name), \"Zebra %s\", dev->device_info + 23);\n\telse\n\t  papplCopyString(name, dev->device_info, sizeof(name));\n\n\tif ((nameptr = strstr(name, \" (\")) != NULL)\n\t  *nameptr = '\\0';\n\n\tif (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n      }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 689,
    "end_line": 732,
    "code": "\tchar\tname[128],\t\t// Printer name\n\t\t*nameptr;\t\t// Pointer in name\n\n\t// Zebra puts \"Zebra Technologies ZTC\" on the front of their printer names,\n\t// which is a bit, um, wordy.  Clean up the device info string to use as a\n\t// printer name and drop any trailing \"(ID)\" nonsense if we don't need it.\n\tif (!strncasecmp(dev->device_info, \"Zebra Technologies ZTC \", 23))\n\t  snprintf(name, sizeof(name), \"Zebra %s\", dev->device_info + 23);\n\telse\n\t  papplCopyString(name, dev->device_info, sizeof(name));\n\n\tif ((nameptr = strstr(name, \" (\")) != NULL)\n\t  *nameptr = '\\0';\n\n\tif (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n      }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 689,
    "end_line": 732,
    "code": "\tchar\tname[128],\t\t// Printer name\n\t\t*nameptr;\t\t// Pointer in name\n\n\t// Zebra puts \"Zebra Technologies ZTC\" on the front of their printer names,\n\t// which is a bit, um, wordy.  Clean up the device info string to use as a\n\t// printer name and drop any trailing \"(ID)\" nonsense if we don't need it.\n\tif (!strncasecmp(dev->device_info, \"Zebra Technologies ZTC \", 23))\n\t  snprintf(name, sizeof(name), \"Zebra %s\", dev->device_info + 23);\n\telse\n\t  papplCopyString(name, dev->device_info, sizeof(name));\n\n\tif ((nameptr = strstr(name, \" (\")) != NULL)\n\t  *nameptr = '\\0';\n\n\tif (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n      }\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 704,
    "end_line": 731,
    "code": " (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 704,
    "end_line": 731,
    "code": " (!papplPrinterCreate(system, 0, name, driver_name, dev->device_id, dev->device_uri))\n\t{\n\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 705,
    "end_line": 731,
    "code": "\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 705,
    "end_line": 731,
    "code": "\t  // Printer already exists with this name, so try adding a number to the\n\t  // name...\n\t  int\ti;\t\t\t// Looping var\n\t  char\tnewname[128],\t\t// New name\n\t\tnumber[4];\t\t// Number string\n\t  size_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t// Length of number string\n\n\t  for (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t}\n ",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "global_variable",
    "start_line": 711,
    "end_line": 712,
    "code": "ze_t namelen = strlen(name),// Length of original name string\n\t\tnumberlen;\t\t",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 714,
    "end_line": 730,
    "code": "r (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 714,
    "end_line": 730,
    "code": "r (i = 2; i < 100; i ++)\n\t  {\n\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 715,
    "end_line": 730,
    "code": "\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t",
    "file": "data/codebase/lprint/lprint.c"
  },
  {
    "type": "function_assignment",
    "start_line": 715,
    "end_line": 730,
    "code": "\t    // Append \" NNN\" to the name, truncating the existing name as needed to\n\t    // include the number at the end...\n\t    snprintf(number, sizeof(number), \" %d\", i);\n\t    numberlen = strlen(number);\n\n\t    papplCopyString(newname, name, sizeof(newname));\n\t    if ((namelen + numberlen) < sizeof(newname))\n\t      memcpy(newname + namelen, number, numberlen + 1);\n\t    else\n\t      memcpy(newname + sizeof(newname) - numberlen - 1, number, numberlen + 1);\n\n\t    // Try creating with this name...\n\t    if (papplPrinterCreate(system, 0, newname, driver_name, dev->device_id, dev->device_uri))\n\t      break;\n\t  }\n\t",
    "file": "data/codebase/lprint/lprint.c"
  }
]