[
  {
    "type": "struct_assignment",
    "start_line": 1,
    "end_line": 963,
    "code": "//\n// ZPL driver for LPrint, a Label Printer Application\n//\n// Copyright \u00a9\u00a02019-2025 by Michael R Sweet.\n// Copyright \u00a9\u00a02007-2019 by Apple Inc.\n// Copyright \u00a9\u00a02001-2007 by Easy Software Products.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n#include \"lprint.h\"\n\n\n// Define to 1 to use run-length encoding, 0 for uncompressed\n#define ZPL_COMPRESSION 1\n\n// Error and warning bits\n#define ZPL_ERROR_MEDIA_OUT\t\t0x00000001\n#define ZPL_ERROR_RIBBON_OUT\t\t0x00000002\n#define ZPL_ERROR_HEAD_OPEN\t\t0x00000004\n#define ZPL_ERROR_CUTTER_FAULT\t\t0x00000008\n#define ZPL_ERROR_CLEAR_PP_FAILED\t0x00008000\n#define ZPL_ERROR_PAPER_FEED\t\t0x00004000\n#define ZPL_ERROR_PRESENTER\t\t0x00002000\n#define ZPL_ERROR_PAPER_JAM\t\t0x00001000\n#define ZPL_ERROR_MARK_NOT_FOUND\t0x00080000\n#define ZPL_ERROR_MARK_CALIBRATE\t0x00040000\n#define ZPL_ERROR_RETRACT_TIMEOUT\t0x00020000\n#define ZPL_ERROR_PAUSED\t\t0x00010000\n\n#define ZPL_WARNING_PAPER_ALMOST_OUT\t0x00000008\n#define ZPL_WARNING_REPLACE_PRINTHEAD\t0x00000004\n#define ZPL_WARNING_CLEAN_PRINTHEAD\t0x00000002\n#define ZPL_WARNING_CALIBRATE_MEDIA\t0x00000001\n#define ZPL_WARNING_PAPER_BEFORE_HEAD\t0x00000010\n#define ZPL_WARNING_BLACK_MARK\t\t0x00000020\n#define ZPL_WARNING_PAPER_AFTER_HEAD\t0x00000040\n#define ZPL_WARNING_LOOP_READY\t\t0x00000080\n#define ZPL_WARNING_PRESENTER\t\t0x00000100\n#define ZPL_WARNING_RETRACT_READY\t0x00000200\n#define ZPL_WARNING_IN_RETRACT\t\t0x00000400\n#define ZPL_WARNING_AT_BIN\t\t0x00000800\n\n\n//\n// Local types...\n//\n\ntypedef struct lprint_zpl_s\t\t// ZPL driver data\n{\n  lprint_dither_t dither;\t\t// Dither buffer\n  unsigned char\t*comp_buffer;\t\t// Compression buffer\n  unsigned char *last_buffer;\t\t// Last line\n  int\t\tlast_buffer_set;\t// Is the last line set?\n} lprint_zpl_t;\n\n\n//\n// Local globals...\n//\n\nstatic const char * const lprint_zpl_2inch_media[] =\n{\t\t\t\t\t// Supported 2 inch media sizes\n  \"oe_1.25x0.25-label_1.25x0.25in\",\n  \"oe_1.25x2.25-label_1.25x2.25in\",\n\n  \"oe_1.5x0.25-label_1.5x0.25in\",\n  \"oe_1.5x0.5-label_1.5x0.5in\",\n  \"oe_1.5x1-label_1.5x1in\",\n  \"oe_1.5x2-label_1.5x2in\",\n\n  \"oe_2x0.37-label_2x0.37in\",\n  \"oe_2x0.5-label_2x0.5in\",\n  \"oe_2x1-label_2x1in\",\n  \"oe_2x1.25-label_2x1.25in\",\n  \"oe_2x2-label_2x2in\",\n  \"oe_2x3-label_2x3in\",\n  \"oe_2x4-label_2x4in\",\n  \"oe_2x5.5-label_2x5.5in\",\n\n  \"roll_max_2x39.6in\",\n  \"roll_min_0.75x0.25in\"\n};\nstatic const char * const lprint_zpl_4inch_media[] =\n{\t\t\t\t\t// Supported 4 inch media sizes\n  \"oe_1.25x0.25-label_1.25x0.25in\",\n  \"oe_1.25x2.25-label_1.25x2.25in\",\n\n  \"oe_1.5x0.25-label_1.5x0.25in\",\n  \"oe_1.5x0.5-label_1.5x0.5in\",\n  \"oe_1.5x1-label_1.5x1in\",\n  \"oe_1.5x2-label_1.5x2in\",\n\n  \"oe_2x0.37-label_2x0.37in\",\n  \"oe_2x0.5-label_2x0.5in\",\n  \"oe_2x1-label_2x1in\",\n  \"oe_2x1.25-label_2x1.25in\",\n  \"oe_2x2-label_2x2in\",\n  \"oe_2x3-label_2x3in\",\n  \"oe_2x4-label_2x4in\",\n  \"oe_2x5.5-label_2x5.5in\",\n\n  \"oe_2.25x0.5-label_2.25x0.5in\",\n  \"oe_2.25x1.25-label_2.25x1.25in\",\n  \"oe_30859-paint-can-label_2.25x3.125in\",\n  \"oe_2.25x4-label_2.25x4in\",\n  \"oe_2.25x5.5-label_2.25x5.5in\",\n\n  \"oe_2.38x5.5-label_2.38x5.5in\",\n\n  \"oe_2.5x1-label_2.5x1in\",\n  \"oe_2.5x2-label_2.5x2in\",\n\n  \"oe_2.75x1.25-label_2.75x1.25in\",\n\n  \"oe_2.9x1-label_2.9x1in\",\n\n  \"oe_3x1-label_3x1in\",\n  \"oe_3x1.25-label_3x1.25in\",\n  \"oe_3x2-label_3x2in\",\n  \"oe_3x3-label_3x3in\",\n  \"na_index-3x5_3x5in\",\n\n  \"oe_3.25x2-label_3.25x2in\",\n  \"oe_3.25x5-label_3.25x5in\",\n  \"oe_3.25x5.5-label_3.25x5.5in\",\n  \"oe_3.25x5.83-label_3.25x5.83in\",\n  \"oe_3.25x7.83-label_3.25x7.83in\",\n\n  \"oe_3.5x1-label_3.5x1in\",\n\n  \"oe_4x1-label_4x1in\",\n  \"oe_4x2-label_4x2in\",\n  \"oe_4x3-label_4x3in\",\n  \"oe_4x4-label_4x4in\",\n  \"oe_4x5-label_4x5in\",\n  \"na_index-4x6_4x6in\",\n  \"oe_4x6.5-label_4x6.5in\",\n  \"oe_4x7.83-label_4x7.83in\",\n  \"oe_4x8-label_4x8in\",\n  \"oe_4x13-label_4x13in\",\n\n  \"roll_max_4x39.6in\",\n  \"roll_min_0.75x0.25in\"\n\n/*\n  \"oe_6x1-label_6x1in\",\n  \"oe_6x2-label_6x2in\",\n  \"oe_6x3-label_6x3in\",\n  \"oe_6x4-label_6x4in\",\n  \"oe_6x5-label_6x5in\",\n  \"oe_6x6-label_6x6in\",\n  \"oe_6x6.5-label_6x6.5in\",\n  \"oe_6x13-label_6x13in\",\n\n  \"oe_8x1-label_8x1in\",\n  \"oe_8x2-label_8x2in\",\n  \"oe_8x3-label_8x3in\",\n  \"oe_8x4-label_8x4in\",\n  \"oe_8x5-label_8x5in\",\n  \"oe_8x6-label_8x6in\",\n  \"oe_8x6.5-label_8x6.5in\",\n  \"oe_8x13-label_8x13in\",\n\n  \"roll_max_8x39.6in\",\n  \"roll_min_1.25x0.25in\"\n*/\n};\n\n\n//\n// Local functions...\n//\n\n#if ZPL_COMPRESSION\nstatic bool\tlprint_zpl_compress(pappl_device_t *device, unsigned char ch, unsigned count);\n#endif // ZPL_COMPRESSION\nstatic bool\tlprint_zpl_printfile(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device);\nstatic bool\tlprint_zpl_rendjob(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device);\nstatic bool\tlprint_zpl_rendpage(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device, unsigned page);\nstatic bool\tlprint_zpl_rstartjob(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device);\nstatic bool\tlprint_zpl_rstartpage(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device, unsigned page);\nstatic bool\tlprint_zpl_rwriteline(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device, unsigned y, const unsigned char *line);\nstatic bool\tlprint_zpl_status(pappl_printer_t *printer);\nstatic bool\tlprint_zpl_update_reasons(pappl_printer_t *printer, pappl_job_t *job, pappl_device_t *device);\n\n\n//\n// 'lprintZPL()' - Initialize the ZPL driver.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on error\nlprintZPL(\n    pappl_system_t         *system,\t// I - System\n    const char             *driver_name,// I - Driver name\n    const char             *device_uri,\t// I - Device URI\n    const char             *device_id,\t// I - 1284 device ID\n    pappl_pr_driver_data_t *data,\t// I - Pointer to driver data\n    ipp_t                  **attrs,\t// O - Pointer to driver attributes\n    void                   *cbdata)\t// I - Callback data (not used)\n{\n  data->printfile_cb  = lprint_zpl_printfile;\n  data->rendjob_cb    = lprint_zpl_rendjob;\n  data->rendpage_cb   = lprint_zpl_rendpage;\n  data->rstartjob_cb  = lprint_zpl_rstartjob;\n  data->rstartpage_cb = lprint_zpl_rstartpage;\n  data->rwriteline_cb = lprint_zpl_rwriteline;\n  data->status_cb     = lprint_zpl_status;\n  data->format        = LPRINT_ZPL_MIMETYPE;\n\n  data->num_resolution = 1;\n\n  if (strstr(driver_name, \"-203dpi\"))\n  {\n    data->x_resolution[0] = 203;\n    data->y_resolution[0] = 203;\n  }\n  else if (strstr(driver_name, \"-300dpi\"))\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n  else\n  {\n    data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  data->x_default = data->y_default = data->x_resolution[0];\n\n  if (strstr(driver_name, \"-cutter\"))\n    data->finishings |= PAPPL_FINISHINGS_TRIM;\n\n  if (!strncmp(driver_name, \"zpl_2inch-\", 16))\n  {\n    // 2 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_2inch_media) / sizeof(lprint_zpl_2inch_media[0]));\n    memcpy(data->media, lprint_zpl_2inch_media, sizeof(lprint_zpl_2inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"oe_2x3-label_2x3in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n  else\n  {\n    // 4 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_4inch_media) / sizeof(lprint_zpl_4inch_media[0]));\n    memcpy(data->media, lprint_zpl_4inch_media, sizeof(lprint_zpl_4inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  data->media_ready[0].tracking = PAPPL_MEDIA_TRACKING_GAP;\n\n  data->bottom_top = data->left_right = 1;\n\n  data->num_source = 1;\n  data->source[0]  = \"main-roll\";\n\n  data->top_offset_supported[0] = -1500;\n  data->top_offset_supported[1] = 1500;\n  data->tracking_supported      = PAPPL_MEDIA_TRACKING_MARK | PAPPL_MEDIA_TRACKING_WEB | PAPPL_MEDIA_TRACKING_GAP | PAPPL_MEDIA_TRACKING_CONTINUOUS;\n\n  data->num_type = 3;\n  data->type[0]  = \"continuous\";\n  data->type[1]  = \"labels\";\n  data->type[2]  = \"labels-continuous\";\n\n  data->mode_configured = PAPPL_LABEL_MODE_TEAR_OFF;\n  data->mode_supported = PAPPL_LABEL_MODE_APPLICATOR | PAPPL_LABEL_MODE_CUTTER | PAPPL_LABEL_MODE_CUTTER_DELAYED | PAPPL_LABEL_MODE_KIOSK | PAPPL_LABEL_MODE_PEEL_OFF | PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL | PAPPL_LABEL_MODE_REWIND | PAPPL_LABEL_MODE_RFID | PAPPL_LABEL_MODE_TEAR_OFF;\n\n  data->tear_offset_configured   = 0;\n  data->tear_offset_supported[0] = -1500;\n  data->tear_offset_supported[1] = 1500;\n\n  data->speed_default      = 0;\n  data->speed_supported[0] = 2540;\n  data->speed_supported[1] = 12 * 2540;\n\n  data->darkness_configured = 50;\n  data->darkness_supported  = 30;\n\n  return (true);\n}\n\n\n//\n// 'lprintZPLQueryDriver()' - Query the printer to determine the proper driver.\n//\n\nvoid\nlprintZPLQueryDriver(\n    pappl_system_t *system,\t\t// I - System\n    const char     *device_uri,\t\t// I - Device URI\n    char           *name,\t\t// I - Name buffer\n    size_t         namesize)\t\t// I - Size of name buffer\n{\n  pappl_device_t\t*device;\t// Device connection\n  char\t\t\tline[1025];\t// Line from device\n  ssize_t\t\tbytes;\t\t// Bytes read\n  char\t\t\tmodel[256],\t// Model name\n\t\t\t*modelptr;\t// Pointer into model name\n  int\t\t\tdpmm = 0;\t// Dots per millimeter\n\n\n  // Make sure name buffer is initialized...\n  *name = '\\0';\n\n  // Connect and send Host Information command...\n  if ((device = papplDeviceOpen(device_uri, \"query\", papplLogDevice, system)) == NULL)\n    return;\n\n  if (papplDevicePuts(device, \"~HI\\n\") < 0)\n    goto done;\n\n  // Read and parse response:\n  //\n  // <stx>MODEL,VERSION,DPMM,MEMORY,OPTIONS<etx><cr><lf>\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) <= 0)\n    goto done;\n\n  line[bytes] = '\\0';\n\n  papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"HI response for '%s' was '%s'.\", device_uri, line);\n\n  if (line[0] == 0x02 && sscanf(line + 1, \"%255[^,],%*[^,],%d\", model, &dpmm) > 1 && (dpmm == 8 || dpmm == 12 || dpmm == 24))\n  {\n    // Got model and dots-per-millimeter values, create a driver name from it...\n    // Note: We currently assume a 4\" print head for auto-detection...\n    const char\t*type = \"tt\";\t\t// Type of printing (direct/transfer)\n    int\t\tdpi;\t\t\t// Print resolution\n\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"model='%s', dpmm=%d\", model, dpmm);\n\n    if ((modelptr = strchr(model, '-')) != NULL && modelptr > model)\n    {\n      if (modelptr[-1] == 'd')\n        type = \"dt\";\n    }\n\n    if (dpmm == 8)\n      dpi = 203;\t\t\t// 203.2\n    else if (dpmm == 12)\n      dpi = 300;\t\t\t// Technically should be 304.8...\n    else\n      dpi = 600;\t\t\t// Technically should be 609.6...\n\n    snprintf(name, namesize, \"zpl_4inch-%ddpi-%s\", dpi, type);\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"auto driver-name='%s'\", name);\n  }\n\n  done:\n\n  papplDeviceClose(device);\n  return;\n}\n\n\n#if ZPL_COMPRESSION\n//\n// 'lprint_zpl_compress()' - Output a RLE run...\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_compress(\n    pappl_device_t *device,\t\t// I - Output device\n    unsigned char  ch,\t\t\t// I - Repeat character\n    unsigned       count)\t\t// I - Repeat count\n{\n  unsigned char\tbuffer[8192],\t\t// Output buffer\n\t\t*bufptr = buffer;\t// Pointer into buffer\n\n\n  if (count > 1)\n  {\n    // Print as many z's as possible - they are the largest denomination\n    // representing 400 characters (zC stands for 400 adjacent C's)\n    while (count >= 400)\n    {\n      count -= 400;\n      *bufptr++ = 'z';\n\n      if (bufptr >= (buffer + sizeof(buffer)))\n      {\n        if (papplDeviceWrite(device, buffer, sizeof(buffer)) < 0)\n          return (0);\n\n\tbufptr = buffer;\n      }\n    }\n\n    // Then print 'g' through 'y' as multiples of 20 characters...\n    if (count >= 20)\n    {\n      *bufptr++ = 'f' + count / 20;\n      count %= 20;\n    }\n\n    // Finally, print 'G' through 'Y' as 1 through 19 characters...\n    if (count > 0)\n      *bufptr++ = 'F' + count;\n  }\n\n  // Then the character to be repeated...\n  *bufptr++ = ch;\n\n  return (papplDeviceWrite(device, buffer, bufptr - buffer) > 0);\n}\n#endif // ZPL_COMPRESSION\n\n\n//\n// 'lprint_zpl_print()' - Print a file.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_printfile(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device)\t\t// I - Output device\n{\n  int\t\tfd;\t\t\t// Input file\n  ssize_t\tbytes;\t\t\t// Bytes read/written\n  char\t\tbuffer[65536];\t\t// Read/write buffer\n\n\n  // Copy the raw file...\n  papplJobSetImpressions(job, 1);\n\n  if ((fd  = open(papplJobGetFilename(job), O_RDONLY)) < 0)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to open print file '%s': %s\", papplJobGetFilename(job), strerror(errno));\n    return (false);\n  }\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Copy print data...\n  while ((bytes = read(fd, buffer, sizeof(buffer))) > 0)\n  {\n    if (papplDeviceWrite(device, buffer, (size_t)bytes) < 0)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to send %d bytes to printer.\", (int)bytes);\n      close(fd);\n      return (false);\n    }\n  }\n  close(fd);\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_rendjob()' - End a job.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rendjob(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device)\t\t// I - Output device\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n\n\n  (void)options;\n\n  free(zpl);\n  papplJobSetData(job, NULL);\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_rendpage()' - End a page.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rendpage(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device,\t\t// I - Output device\n    unsigned           page)\t\t// I - Page number\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n\n\n  (void)page;\n\n  lprint_zpl_rwriteline(job, options, device, options->header.cupsHeight, NULL);\n\n  papplDevicePrintf(device, \"^XA\\n^POI\\n^PW%u\\n^LH0,0\\n^LT%d\\n\", options->header.cupsWidth, options->media.top_offset * options->printer_resolution[1] / 2540);\n\n  if (options->media.type[0] && strcmp(options->media.type, \"labels\"))\n  {\n    // Continuous media, so always set tracking to continuous...\n    options->media.tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS;\n  }\n\n  if (options->media.tracking)\n  {\n    if (options->media.tracking == PAPPL_MEDIA_TRACKING_CONTINUOUS)\n      papplDevicePrintf(device, \"^LL%u\\n^MNN\\n\", options->header.cupsHeight);\n    else if (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n  if (strstr(papplPrinterGetDriverName(papplJobGetPrinter(job)), \"-tt\"))\n    papplDevicePuts(device, \"^MTT\\n\");\t// Thermal transfer\n  else\n    papplDevicePuts(device, \"^MTD\\n\");\t// Direct thermal\n\n  papplDevicePrintf(device, \"^PQ1, 0, 0, N\\n\");\n  papplDevicePuts(device, \"^FO0,0^XGR:LPRINT.GRF,1,1^FS\\n^XZ\\n\");\n  papplDevicePuts(device, \"^XA\\n^IDR:LPRINT.GRF^FS\\n^XZ\\n\");\n\n  if (options->finishings & PAPPL_FINISHINGS_TRIM)\n    papplDevicePuts(device, \"^CN1\\n\");\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Free memory and return...\n  lprintDitherFree(&zpl->dither);\n\n  free(zpl->comp_buffer);\n  free(zpl->last_buffer);\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_rstartjob()' - Start a job.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rstartjob(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device)\t\t// I - Output device\n{\n  pappl_pr_driver_data_t data;\t\t// Driver data\n  int\t\t\tdarkness;\t// Composite darkness value\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)calloc(1, sizeof(lprint_zpl_t));\n\t\t\t\t\t// ZPL driver data\n\n\n  // Initialize driver data...\n  papplJobSetData(job, zpl);\n\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  // label-mode-configured\n  switch (data.mode_configured)\n  {\n    case PAPPL_LABEL_MODE_APPLICATOR :\n        papplDevicePuts(device, \"^MMA,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER :\n        papplDevicePuts(device, \"^MMC,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER_DELAYED :\n        papplDevicePuts(device, \"^MMD,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_KIOSK :\n        papplDevicePuts(device, \"^MMK,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF :\n        papplDevicePuts(device, \"^MMP,N\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL :\n        papplDevicePuts(device, \"^MMP,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_REWIND :\n        papplDevicePuts(device, \"^MMR,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_RFID :\n        papplDevicePuts(device, \"^MMF,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_TEAR_OFF :\n    default :\n        papplDevicePuts(device, \"^MMT,Y\\n\");\n        break;\n  }\n\n  // label-tear-offset-configured\n  if (data.tear_offset_configured < 0)\n    papplDevicePrintf(device, \"~TA%04d\\n\", data.tear_offset_configured);\n  else if (data.tear_offset_configured > 0)\n    papplDevicePrintf(device, \"~TA%03d\\n\", data.tear_offset_configured);\n\n  // print-darkness / printer-darkness-configured\n  if ((darkness = options->print_darkness + options->darkness_configured) < 0)\n    darkness = 0;\n  else if (darkness > 100)\n    darkness = 100;\n\n  papplDevicePrintf(device, \"~SD%02u\\n\", 30 * darkness / 100);\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_rstartpage()' - Start a page.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rstartpage(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device,\t\t// I - Output device\n    unsigned           page)\t\t// I - Page number\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  int\t\tips;\t\t\t// Inches per second\n  double\tout_gamma = 1.0;\t// Output gamma correction\n\n\n  (void)page;\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Setup dither buffer...\n  if (options->header.HWResolution[0] == 300)\n    out_gamma = 1.2;\n  else if (options->header.HWResolution[0] == 600)\n    out_gamma = 1.44;\n\n  if (!lprintDitherAlloc(&zpl->dither, job, options, CUPS_CSPACE_K, out_gamma))\n    return (false);\n\n  // print-speed\n  if ((ips = options->print_speed / 2540) > 0)\n    papplDevicePrintf(device, \"^PR%d,%d,%d\\n\", ips, ips, ips);\n\n  // Download bitmap...\n  papplDevicePrintf(device, \"~DGR:LPRINT.GRF,%u,%u,\\n\", zpl->dither.in_height * zpl->dither.out_width, zpl->dither.out_width);\n\n  // Allocate memory for writing the bitmap...\n  zpl->comp_buffer     = malloc(2 * zpl->dither.out_width + 1);\n  zpl->last_buffer     = malloc(zpl->dither.out_width);\n  zpl->last_buffer_set = 0;\n\n  if (!zpl->comp_buffer || !zpl->last_buffer)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate compression buffers.\");\n    return (false);\n  }\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_rwriteline()' - Write a raster line.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rwriteline(\n    pappl_job_t         *job,\t\t// I - Job\n    pappl_pr_options_t  *options,\t// I - Job options\n    pappl_device_t      *device,\t// I - Output device\n    unsigned            y,\t\t// I - Line number\n    const unsigned char *line)\t\t// I - Line\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  unsigned\t\ti;\t\t// Looping var\n  const unsigned char\t*ptr;\t\t// Pointer into buffer\n  unsigned char\t\t*compptr;\t// Pointer into compression buffer\n#if ZPL_COMPRESSION\n  unsigned char\t\trepeat_char;\t// Repeated character\n  unsigned\t\trepeat_count;\t// Number of repeated characters\n#endif // ZPL_COMPRESSION\n  static const unsigned char *hex = (const unsigned char *)\"0123456789ABCDEF\";\n\t\t\t\t\t// Hex digits\n\n\n  if (!lprintDitherLine(&zpl->dither, y, line))\n    return (true);\n\n  // Determine whether this row is the same as the previous line.\n  // If so, output a ':' and return...\n  if (zpl->last_buffer_set && !memcmp(zpl->dither.output, zpl->last_buffer, zpl->dither.out_width))\n  {\n    papplDeviceWrite(device, \":\", 1);\n    return (true);\n  }\n\n  // Convert the line to hex digits...\n  for (ptr = zpl->dither.output, compptr = zpl->comp_buffer, i = zpl->dither.out_width; i > 0; i --, ptr ++)\n  {\n    *compptr++ = hex[*ptr >> 4];\n    *compptr++ = hex[*ptr & 15];\n  }\n\n#if ZPL_COMPRESSION\n  // Send run-length compressed HEX data...\n  *compptr = '\\0';\n\n  // Run-length compress the graphics...\n  for (compptr = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *compptr; compptr ++)\n  {\n    if (*compptr == repeat_char)\n    {\n      repeat_count ++;\n    }\n    else\n    {\n      lprint_zpl_compress(device, repeat_char, repeat_count);\n      repeat_char  = *compptr;\n      repeat_count = 1;\n    }\n  }\n\n  if (repeat_char == '0')\n  {\n    // Handle 0's on the end of the line...\n    if (repeat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    if (repeat_count > 0)\n      papplDevicePuts(device, \",\");\n  }\n  else\n    lprint_zpl_compress(device, repeat_char, repeat_count);\n\n#else\n  // Send uncompressed HEX data...\n  papplDeviceWrite(device, zpl->comp_buffer, compptr - zpl->comp_buffer);\n#endif // ZPL_COMPRESSION\n\n  // Save this line for the next round...\n  memcpy(zpl->last_buffer, zpl->dither.output, zpl->dither.out_width);\n  zpl->last_buffer_set = 1;\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_status()' - Get current printer status.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_status(\n    pappl_printer_t *printer)\t\t// I - Printer\n{\n  pappl_device_t\t*device;\t// Connection to printer\n  char\t\t\tline[1025];\t// Line from printer\n  ssize_t\t\tbytes;\t\t// Bytes read\n  int\t\t\tlength = 0;\t// Label length\n  bool\t\t\tret = false;\t// Return value\n\n\n  if ((device = papplPrinterOpenDevice(printer)) == NULL)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to open device for status.\");\n    return (false);\n  }\n\n  // Get the printer status...\n  if (!lprint_zpl_update_reasons(printer, NULL, device))\n    goto done;\n\n  // Query host status...\n  if (papplDevicePuts(device, \"~HS\\n\") < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to send HS status command.\");\n    goto done;\n  }\n\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to read HS status response.\");\n    goto done;\n  }\n\n  line[bytes] = '\\0';\n\n  papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"HS returned '%s'.\", line);\n\n  if (sscanf(line + 1, \"%*d,%*d,%*d,%d\", &length) == 1 && length > 11)\n  {\n    // Auto-detect label length for ready media...\n    pappl_pr_driver_data_t\tdata;\t// Driver data\n\n    papplPrinterGetDriverData(printer, &data);\n\n    // Round the length to the nearest dot and snap to the nearest 1/4\"...\n    length = (2540 * length + data.y_resolution[0] / 2) / data.y_resolution[0];\n\n    if ((length % 635) <= 100)\n      length += length % 635;\n    else if ((length % 635) >= 535)\n      length += 635 - (length % 635);\n\n    // Lookup size\n    lprintMediaMatch(printer, 0, 0, length);\n  }\n\n  ret = true;\n\n  done:\n\n  papplPrinterCloseDevice(printer);\n\n  return (ret);\n}\n\n\n//\n// 'lprint_zpl_update_reasons()' - Update \"printer-state-reasons\" values.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_update_reasons(\n    pappl_printer_t *printer,\t\t// I - Printer\n    pappl_job_t     *job,\t\t// I - Current job or `NULL` if none\n    pappl_device_t  *device)\t\t// I - Connection to device\n{\n  char\t\t\tline[1025],\t// Line from printer\n\t\t\t*lineptr;\t// Pointer into line\n  ssize_t\t\tbytes;\t\t// Bytes read\n  unsigned\t\terrors = 0,\t// Detected errors\n\t\t\twarnings = 0;\t// Detected warnings\n  pappl_preason_t\treasons;\t// \"printer-state-reasons\" values\n\n\n  // Get the printer status...\n  if (papplDevicePuts(device, \"~HQES\\n\") < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to send HQES status command.\");\n    return (false);\n  }\n\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to read HQES status response.\");\n    return (false);\n  }\n\n  line[bytes] = '\\0';\n\n  papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"HQES returned '%s'.\", line);\n\n  if ((lineptr = strstr(line, \"ERRORS:\")) != NULL)\n  {\n    if (sscanf(lineptr + 7, \"%*d%*x%x\", &errors) != 1)\n      errors = 0;\n  }\n\n  if ((lineptr = strstr(line, \"WARNINGS:\")) != NULL)\n  {\n    if (sscanf(lineptr + 9, \"%*d%*x%x\", &warnings) != 1)\n      warnings = 0;\n  }\n\n  reasons = PAPPL_PREASON_NONE;\n\n  if (errors & ZPL_ERROR_MEDIA_OUT)\n    reasons |= PAPPL_PREASON_MEDIA_EMPTY;\n\n  if (errors & ZPL_ERROR_PAPER_JAM)\n    reasons |= PAPPL_PREASON_MEDIA_JAM;\n\n  if (errors & ZPL_ERROR_PAUSED)\n    reasons |= PAPPL_PREASON_OFFLINE;\n\n  if (errors & ZPL_ERROR_RIBBON_OUT)\n    reasons |= PAPPL_PREASON_MARKER_SUPPLY_EMPTY;\n\n  if (errors & ~(ZPL_ERROR_MEDIA_OUT | ZPL_ERROR_PAPER_JAM | ZPL_ERROR_PAUSED))\n  {\n    reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_ERROR_HEAD_OPEN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Print head open.\");\n    if (errors & ZPL_ERROR_CUTTER_FAULT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Cutter fault.\");\n    if (errors & ZPL_ERROR_CLEAR_PP_FAILED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Clear paper path failed.\");\n    if (errors & ZPL_ERROR_PAPER_FEED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Paper feed error.\");\n    if (errors & ZPL_ERROR_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Presenter error.\");\n    if (errors & ZPL_ERROR_MARK_NOT_FOUND)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark not found.\");\n    if (errors & ZPL_ERROR_MARK_CALIBRATE)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark calibration error.\");\n    if (errors & ZPL_ERROR_RETRACT_TIMEOUT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Retraction timeout.\");\n  }\n\n  if (warnings & ZPL_WARNING_PAPER_ALMOST_OUT)\n    reasons |= PAPPL_PREASON_MEDIA_LOW;\n\n  if (warnings & ~ZPL_WARNING_PAPER_ALMOST_OUT)\n  {\n    reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_WARNING_REPLACE_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Replace print head.\");\n\n    if (errors & ZPL_WARNING_CLEAN_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Clean print head.\");\n\n    if (errors & ZPL_WARNING_CALIBRATE_MEDIA)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Calibrate media.\");\n\n    if (errors & ZPL_WARNING_PAPER_BEFORE_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper before head.\");\n\n    if (errors & ZPL_WARNING_BLACK_MARK)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Black mark.\");\n\n    if (errors & ZPL_WARNING_PAPER_AFTER_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper after head.\");\n\n    if (errors & ZPL_WARNING_LOOP_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Loop ready.\");\n\n    if (errors & ZPL_WARNING_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Presenter.\");\n\n    if (errors & ZPL_WARNING_RETRACT_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Retract ready.\");\n\n    if (errors & ZPL_WARNING_IN_RETRACT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"In retract.\");\n\n    if (errors & ZPL_WARNING_AT_BIN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"At bin.\");\n  }\n\n  if (job && (reasons & PAPPL_PREASON_MEDIA_EMPTY))\n    reasons |= PAPPL_PREASON_MEDIA_NEEDED;\n\n  papplPrinterSetReasons(printer, reasons, ~reasons);\n\n  return (true);\n}\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 1,
    "end_line": 963,
    "code": "//\n// ZPL driver for LPrint, a Label Printer Application\n//\n// Copyright \u00a9\u00a02019-2025 by Michael R Sweet.\n// Copyright \u00a9\u00a02007-2019 by Apple Inc.\n// Copyright \u00a9\u00a02001-2007 by Easy Software Products.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n#include \"lprint.h\"\n\n\n// Define to 1 to use run-length encoding, 0 for uncompressed\n#define ZPL_COMPRESSION 1\n\n// Error and warning bits\n#define ZPL_ERROR_MEDIA_OUT\t\t0x00000001\n#define ZPL_ERROR_RIBBON_OUT\t\t0x00000002\n#define ZPL_ERROR_HEAD_OPEN\t\t0x00000004\n#define ZPL_ERROR_CUTTER_FAULT\t\t0x00000008\n#define ZPL_ERROR_CLEAR_PP_FAILED\t0x00008000\n#define ZPL_ERROR_PAPER_FEED\t\t0x00004000\n#define ZPL_ERROR_PRESENTER\t\t0x00002000\n#define ZPL_ERROR_PAPER_JAM\t\t0x00001000\n#define ZPL_ERROR_MARK_NOT_FOUND\t0x00080000\n#define ZPL_ERROR_MARK_CALIBRATE\t0x00040000\n#define ZPL_ERROR_RETRACT_TIMEOUT\t0x00020000\n#define ZPL_ERROR_PAUSED\t\t0x00010000\n\n#define ZPL_WARNING_PAPER_ALMOST_OUT\t0x00000008\n#define ZPL_WARNING_REPLACE_PRINTHEAD\t0x00000004\n#define ZPL_WARNING_CLEAN_PRINTHEAD\t0x00000002\n#define ZPL_WARNING_CALIBRATE_MEDIA\t0x00000001\n#define ZPL_WARNING_PAPER_BEFORE_HEAD\t0x00000010\n#define ZPL_WARNING_BLACK_MARK\t\t0x00000020\n#define ZPL_WARNING_PAPER_AFTER_HEAD\t0x00000040\n#define ZPL_WARNING_LOOP_READY\t\t0x00000080\n#define ZPL_WARNING_PRESENTER\t\t0x00000100\n#define ZPL_WARNING_RETRACT_READY\t0x00000200\n#define ZPL_WARNING_IN_RETRACT\t\t0x00000400\n#define ZPL_WARNING_AT_BIN\t\t0x00000800\n\n\n//\n// Local types...\n//\n\ntypedef struct lprint_zpl_s\t\t// ZPL driver data\n{\n  lprint_dither_t dither;\t\t// Dither buffer\n  unsigned char\t*comp_buffer;\t\t// Compression buffer\n  unsigned char *last_buffer;\t\t// Last line\n  int\t\tlast_buffer_set;\t// Is the last line set?\n} lprint_zpl_t;\n\n\n//\n// Local globals...\n//\n\nstatic const char * const lprint_zpl_2inch_media[] =\n{\t\t\t\t\t// Supported 2 inch media sizes\n  \"oe_1.25x0.25-label_1.25x0.25in\",\n  \"oe_1.25x2.25-label_1.25x2.25in\",\n\n  \"oe_1.5x0.25-label_1.5x0.25in\",\n  \"oe_1.5x0.5-label_1.5x0.5in\",\n  \"oe_1.5x1-label_1.5x1in\",\n  \"oe_1.5x2-label_1.5x2in\",\n\n  \"oe_2x0.37-label_2x0.37in\",\n  \"oe_2x0.5-label_2x0.5in\",\n  \"oe_2x1-label_2x1in\",\n  \"oe_2x1.25-label_2x1.25in\",\n  \"oe_2x2-label_2x2in\",\n  \"oe_2x3-label_2x3in\",\n  \"oe_2x4-label_2x4in\",\n  \"oe_2x5.5-label_2x5.5in\",\n\n  \"roll_max_2x39.6in\",\n  \"roll_min_0.75x0.25in\"\n};\nstatic const char * const lprint_zpl_4inch_media[] =\n{\t\t\t\t\t// Supported 4 inch media sizes\n  \"oe_1.25x0.25-label_1.25x0.25in\",\n  \"oe_1.25x2.25-label_1.25x2.25in\",\n\n  \"oe_1.5x0.25-label_1.5x0.25in\",\n  \"oe_1.5x0.5-label_1.5x0.5in\",\n  \"oe_1.5x1-label_1.5x1in\",\n  \"oe_1.5x2-label_1.5x2in\",\n\n  \"oe_2x0.37-label_2x0.37in\",\n  \"oe_2x0.5-label_2x0.5in\",\n  \"oe_2x1-label_2x1in\",\n  \"oe_2x1.25-label_2x1.25in\",\n  \"oe_2x2-label_2x2in\",\n  \"oe_2x3-label_2x3in\",\n  \"oe_2x4-label_2x4in\",\n  \"oe_2x5.5-label_2x5.5in\",\n\n  \"oe_2.25x0.5-label_2.25x0.5in\",\n  \"oe_2.25x1.25-label_2.25x1.25in\",\n  \"oe_30859-paint-can-label_2.25x3.125in\",\n  \"oe_2.25x4-label_2.25x4in\",\n  \"oe_2.25x5.5-label_2.25x5.5in\",\n\n  \"oe_2.38x5.5-label_2.38x5.5in\",\n\n  \"oe_2.5x1-label_2.5x1in\",\n  \"oe_2.5x2-label_2.5x2in\",\n\n  \"oe_2.75x1.25-label_2.75x1.25in\",\n\n  \"oe_2.9x1-label_2.9x1in\",\n\n  \"oe_3x1-label_3x1in\",\n  \"oe_3x1.25-label_3x1.25in\",\n  \"oe_3x2-label_3x2in\",\n  \"oe_3x3-label_3x3in\",\n  \"na_index-3x5_3x5in\",\n\n  \"oe_3.25x2-label_3.25x2in\",\n  \"oe_3.25x5-label_3.25x5in\",\n  \"oe_3.25x5.5-label_3.25x5.5in\",\n  \"oe_3.25x5.83-label_3.25x5.83in\",\n  \"oe_3.25x7.83-label_3.25x7.83in\",\n\n  \"oe_3.5x1-label_3.5x1in\",\n\n  \"oe_4x1-label_4x1in\",\n  \"oe_4x2-label_4x2in\",\n  \"oe_4x3-label_4x3in\",\n  \"oe_4x4-label_4x4in\",\n  \"oe_4x5-label_4x5in\",\n  \"na_index-4x6_4x6in\",\n  \"oe_4x6.5-label_4x6.5in\",\n  \"oe_4x7.83-label_4x7.83in\",\n  \"oe_4x8-label_4x8in\",\n  \"oe_4x13-label_4x13in\",\n\n  \"roll_max_4x39.6in\",\n  \"roll_min_0.75x0.25in\"\n\n/*\n  \"oe_6x1-label_6x1in\",\n  \"oe_6x2-label_6x2in\",\n  \"oe_6x3-label_6x3in\",\n  \"oe_6x4-label_6x4in\",\n  \"oe_6x5-label_6x5in\",\n  \"oe_6x6-label_6x6in\",\n  \"oe_6x6.5-label_6x6.5in\",\n  \"oe_6x13-label_6x13in\",\n\n  \"oe_8x1-label_8x1in\",\n  \"oe_8x2-label_8x2in\",\n  \"oe_8x3-label_8x3in\",\n  \"oe_8x4-label_8x4in\",\n  \"oe_8x5-label_8x5in\",\n  \"oe_8x6-label_8x6in\",\n  \"oe_8x6.5-label_8x6.5in\",\n  \"oe_8x13-label_8x13in\",\n\n  \"roll_max_8x39.6in\",\n  \"roll_min_1.25x0.25in\"\n*/\n};\n\n\n//\n// Local functions...\n//\n\n#if ZPL_COMPRESSION\nstatic bool\tlprint_zpl_compress(pappl_device_t *device, unsigned char ch, unsigned count);\n#endif // ZPL_COMPRESSION\nstatic bool\tlprint_zpl_printfile(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device);\nstatic bool\tlprint_zpl_rendjob(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device);\nstatic bool\tlprint_zpl_rendpage(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device, unsigned page);\nstatic bool\tlprint_zpl_rstartjob(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device);\nstatic bool\tlprint_zpl_rstartpage(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device, unsigned page);\nstatic bool\tlprint_zpl_rwriteline(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device, unsigned y, const unsigned char *line);\nstatic bool\tlprint_zpl_status(pappl_printer_t *printer);\nstatic bool\tlprint_zpl_update_reasons(pappl_printer_t *printer, pappl_job_t *job, pappl_device_t *device);\n\n\n//\n// 'lprintZPL()' - Initialize the ZPL driver.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on error\nlprintZPL(\n    pappl_system_t         *system,\t// I - System\n    const char             *driver_name,// I - Driver name\n    const char             *device_uri,\t// I - Device URI\n    const char             *device_id,\t// I - 1284 device ID\n    pappl_pr_driver_data_t *data,\t// I - Pointer to driver data\n    ipp_t                  **attrs,\t// O - Pointer to driver attributes\n    void                   *cbdata)\t// I - Callback data (not used)\n{\n  data->printfile_cb  = lprint_zpl_printfile;\n  data->rendjob_cb    = lprint_zpl_rendjob;\n  data->rendpage_cb   = lprint_zpl_rendpage;\n  data->rstartjob_cb  = lprint_zpl_rstartjob;\n  data->rstartpage_cb = lprint_zpl_rstartpage;\n  data->rwriteline_cb = lprint_zpl_rwriteline;\n  data->status_cb     = lprint_zpl_status;\n  data->format        = LPRINT_ZPL_MIMETYPE;\n\n  data->num_resolution = 1;\n\n  if (strstr(driver_name, \"-203dpi\"))\n  {\n    data->x_resolution[0] = 203;\n    data->y_resolution[0] = 203;\n  }\n  else if (strstr(driver_name, \"-300dpi\"))\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n  else\n  {\n    data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  data->x_default = data->y_default = data->x_resolution[0];\n\n  if (strstr(driver_name, \"-cutter\"))\n    data->finishings |= PAPPL_FINISHINGS_TRIM;\n\n  if (!strncmp(driver_name, \"zpl_2inch-\", 16))\n  {\n    // 2 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_2inch_media) / sizeof(lprint_zpl_2inch_media[0]));\n    memcpy(data->media, lprint_zpl_2inch_media, sizeof(lprint_zpl_2inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"oe_2x3-label_2x3in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n  else\n  {\n    // 4 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_4inch_media) / sizeof(lprint_zpl_4inch_media[0]));\n    memcpy(data->media, lprint_zpl_4inch_media, sizeof(lprint_zpl_4inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  data->media_ready[0].tracking = PAPPL_MEDIA_TRACKING_GAP;\n\n  data->bottom_top = data->left_right = 1;\n\n  data->num_source = 1;\n  data->source[0]  = \"main-roll\";\n\n  data->top_offset_supported[0] = -1500;\n  data->top_offset_supported[1] = 1500;\n  data->tracking_supported      = PAPPL_MEDIA_TRACKING_MARK | PAPPL_MEDIA_TRACKING_WEB | PAPPL_MEDIA_TRACKING_GAP | PAPPL_MEDIA_TRACKING_CONTINUOUS;\n\n  data->num_type = 3;\n  data->type[0]  = \"continuous\";\n  data->type[1]  = \"labels\";\n  data->type[2]  = \"labels-continuous\";\n\n  data->mode_configured = PAPPL_LABEL_MODE_TEAR_OFF;\n  data->mode_supported = PAPPL_LABEL_MODE_APPLICATOR | PAPPL_LABEL_MODE_CUTTER | PAPPL_LABEL_MODE_CUTTER_DELAYED | PAPPL_LABEL_MODE_KIOSK | PAPPL_LABEL_MODE_PEEL_OFF | PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL | PAPPL_LABEL_MODE_REWIND | PAPPL_LABEL_MODE_RFID | PAPPL_LABEL_MODE_TEAR_OFF;\n\n  data->tear_offset_configured   = 0;\n  data->tear_offset_supported[0] = -1500;\n  data->tear_offset_supported[1] = 1500;\n\n  data->speed_default      = 0;\n  data->speed_supported[0] = 2540;\n  data->speed_supported[1] = 12 * 2540;\n\n  data->darkness_configured = 50;\n  data->darkness_supported  = 30;\n\n  return (true);\n}\n\n\n//\n// 'lprintZPLQueryDriver()' - Query the printer to determine the proper driver.\n//\n\nvoid\nlprintZPLQueryDriver(\n    pappl_system_t *system,\t\t// I - System\n    const char     *device_uri,\t\t// I - Device URI\n    char           *name,\t\t// I - Name buffer\n    size_t         namesize)\t\t// I - Size of name buffer\n{\n  pappl_device_t\t*device;\t// Device connection\n  char\t\t\tline[1025];\t// Line from device\n  ssize_t\t\tbytes;\t\t// Bytes read\n  char\t\t\tmodel[256],\t// Model name\n\t\t\t*modelptr;\t// Pointer into model name\n  int\t\t\tdpmm = 0;\t// Dots per millimeter\n\n\n  // Make sure name buffer is initialized...\n  *name = '\\0';\n\n  // Connect and send Host Information command...\n  if ((device = papplDeviceOpen(device_uri, \"query\", papplLogDevice, system)) == NULL)\n    return;\n\n  if (papplDevicePuts(device, \"~HI\\n\") < 0)\n    goto done;\n\n  // Read and parse response:\n  //\n  // <stx>MODEL,VERSION,DPMM,MEMORY,OPTIONS<etx><cr><lf>\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) <= 0)\n    goto done;\n\n  line[bytes] = '\\0';\n\n  papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"HI response for '%s' was '%s'.\", device_uri, line);\n\n  if (line[0] == 0x02 && sscanf(line + 1, \"%255[^,],%*[^,],%d\", model, &dpmm) > 1 && (dpmm == 8 || dpmm == 12 || dpmm == 24))\n  {\n    // Got model and dots-per-millimeter values, create a driver name from it...\n    // Note: We currently assume a 4\" print head for auto-detection...\n    const char\t*type = \"tt\";\t\t// Type of printing (direct/transfer)\n    int\t\tdpi;\t\t\t// Print resolution\n\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"model='%s', dpmm=%d\", model, dpmm);\n\n    if ((modelptr = strchr(model, '-')) != NULL && modelptr > model)\n    {\n      if (modelptr[-1] == 'd')\n        type = \"dt\";\n    }\n\n    if (dpmm == 8)\n      dpi = 203;\t\t\t// 203.2\n    else if (dpmm == 12)\n      dpi = 300;\t\t\t// Technically should be 304.8...\n    else\n      dpi = 600;\t\t\t// Technically should be 609.6...\n\n    snprintf(name, namesize, \"zpl_4inch-%ddpi-%s\", dpi, type);\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"auto driver-name='%s'\", name);\n  }\n\n  done:\n\n  papplDeviceClose(device);\n  return;\n}\n\n\n#if ZPL_COMPRESSION\n//\n// 'lprint_zpl_compress()' - Output a RLE run...\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_compress(\n    pappl_device_t *device,\t\t// I - Output device\n    unsigned char  ch,\t\t\t// I - Repeat character\n    unsigned       count)\t\t// I - Repeat count\n{\n  unsigned char\tbuffer[8192],\t\t// Output buffer\n\t\t*bufptr = buffer;\t// Pointer into buffer\n\n\n  if (count > 1)\n  {\n    // Print as many z's as possible - they are the largest denomination\n    // representing 400 characters (zC stands for 400 adjacent C's)\n    while (count >= 400)\n    {\n      count -= 400;\n      *bufptr++ = 'z';\n\n      if (bufptr >= (buffer + sizeof(buffer)))\n      {\n        if (papplDeviceWrite(device, buffer, sizeof(buffer)) < 0)\n          return (0);\n\n\tbufptr = buffer;\n      }\n    }\n\n    // Then print 'g' through 'y' as multiples of 20 characters...\n    if (count >= 20)\n    {\n      *bufptr++ = 'f' + count / 20;\n      count %= 20;\n    }\n\n    // Finally, print 'G' through 'Y' as 1 through 19 characters...\n    if (count > 0)\n      *bufptr++ = 'F' + count;\n  }\n\n  // Then the character to be repeated...\n  *bufptr++ = ch;\n\n  return (papplDeviceWrite(device, buffer, bufptr - buffer) > 0);\n}\n#endif // ZPL_COMPRESSION\n\n\n//\n// 'lprint_zpl_print()' - Print a file.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_printfile(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device)\t\t// I - Output device\n{\n  int\t\tfd;\t\t\t// Input file\n  ssize_t\tbytes;\t\t\t// Bytes read/written\n  char\t\tbuffer[65536];\t\t// Read/write buffer\n\n\n  // Copy the raw file...\n  papplJobSetImpressions(job, 1);\n\n  if ((fd  = open(papplJobGetFilename(job), O_RDONLY)) < 0)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to open print file '%s': %s\", papplJobGetFilename(job), strerror(errno));\n    return (false);\n  }\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Copy print data...\n  while ((bytes = read(fd, buffer, sizeof(buffer))) > 0)\n  {\n    if (papplDeviceWrite(device, buffer, (size_t)bytes) < 0)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to send %d bytes to printer.\", (int)bytes);\n      close(fd);\n      return (false);\n    }\n  }\n  close(fd);\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_rendjob()' - End a job.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rendjob(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device)\t\t// I - Output device\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n\n\n  (void)options;\n\n  free(zpl);\n  papplJobSetData(job, NULL);\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_rendpage()' - End a page.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rendpage(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device,\t\t// I - Output device\n    unsigned           page)\t\t// I - Page number\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n\n\n  (void)page;\n\n  lprint_zpl_rwriteline(job, options, device, options->header.cupsHeight, NULL);\n\n  papplDevicePrintf(device, \"^XA\\n^POI\\n^PW%u\\n^LH0,0\\n^LT%d\\n\", options->header.cupsWidth, options->media.top_offset * options->printer_resolution[1] / 2540);\n\n  if (options->media.type[0] && strcmp(options->media.type, \"labels\"))\n  {\n    // Continuous media, so always set tracking to continuous...\n    options->media.tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS;\n  }\n\n  if (options->media.tracking)\n  {\n    if (options->media.tracking == PAPPL_MEDIA_TRACKING_CONTINUOUS)\n      papplDevicePrintf(device, \"^LL%u\\n^MNN\\n\", options->header.cupsHeight);\n    else if (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n  if (strstr(papplPrinterGetDriverName(papplJobGetPrinter(job)), \"-tt\"))\n    papplDevicePuts(device, \"^MTT\\n\");\t// Thermal transfer\n  else\n    papplDevicePuts(device, \"^MTD\\n\");\t// Direct thermal\n\n  papplDevicePrintf(device, \"^PQ1, 0, 0, N\\n\");\n  papplDevicePuts(device, \"^FO0,0^XGR:LPRINT.GRF,1,1^FS\\n^XZ\\n\");\n  papplDevicePuts(device, \"^XA\\n^IDR:LPRINT.GRF^FS\\n^XZ\\n\");\n\n  if (options->finishings & PAPPL_FINISHINGS_TRIM)\n    papplDevicePuts(device, \"^CN1\\n\");\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Free memory and return...\n  lprintDitherFree(&zpl->dither);\n\n  free(zpl->comp_buffer);\n  free(zpl->last_buffer);\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_rstartjob()' - Start a job.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rstartjob(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device)\t\t// I - Output device\n{\n  pappl_pr_driver_data_t data;\t\t// Driver data\n  int\t\t\tdarkness;\t// Composite darkness value\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)calloc(1, sizeof(lprint_zpl_t));\n\t\t\t\t\t// ZPL driver data\n\n\n  // Initialize driver data...\n  papplJobSetData(job, zpl);\n\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  // label-mode-configured\n  switch (data.mode_configured)\n  {\n    case PAPPL_LABEL_MODE_APPLICATOR :\n        papplDevicePuts(device, \"^MMA,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER :\n        papplDevicePuts(device, \"^MMC,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER_DELAYED :\n        papplDevicePuts(device, \"^MMD,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_KIOSK :\n        papplDevicePuts(device, \"^MMK,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF :\n        papplDevicePuts(device, \"^MMP,N\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL :\n        papplDevicePuts(device, \"^MMP,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_REWIND :\n        papplDevicePuts(device, \"^MMR,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_RFID :\n        papplDevicePuts(device, \"^MMF,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_TEAR_OFF :\n    default :\n        papplDevicePuts(device, \"^MMT,Y\\n\");\n        break;\n  }\n\n  // label-tear-offset-configured\n  if (data.tear_offset_configured < 0)\n    papplDevicePrintf(device, \"~TA%04d\\n\", data.tear_offset_configured);\n  else if (data.tear_offset_configured > 0)\n    papplDevicePrintf(device, \"~TA%03d\\n\", data.tear_offset_configured);\n\n  // print-darkness / printer-darkness-configured\n  if ((darkness = options->print_darkness + options->darkness_configured) < 0)\n    darkness = 0;\n  else if (darkness > 100)\n    darkness = 100;\n\n  papplDevicePrintf(device, \"~SD%02u\\n\", 30 * darkness / 100);\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_rstartpage()' - Start a page.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rstartpage(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device,\t\t// I - Output device\n    unsigned           page)\t\t// I - Page number\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  int\t\tips;\t\t\t// Inches per second\n  double\tout_gamma = 1.0;\t// Output gamma correction\n\n\n  (void)page;\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Setup dither buffer...\n  if (options->header.HWResolution[0] == 300)\n    out_gamma = 1.2;\n  else if (options->header.HWResolution[0] == 600)\n    out_gamma = 1.44;\n\n  if (!lprintDitherAlloc(&zpl->dither, job, options, CUPS_CSPACE_K, out_gamma))\n    return (false);\n\n  // print-speed\n  if ((ips = options->print_speed / 2540) > 0)\n    papplDevicePrintf(device, \"^PR%d,%d,%d\\n\", ips, ips, ips);\n\n  // Download bitmap...\n  papplDevicePrintf(device, \"~DGR:LPRINT.GRF,%u,%u,\\n\", zpl->dither.in_height * zpl->dither.out_width, zpl->dither.out_width);\n\n  // Allocate memory for writing the bitmap...\n  zpl->comp_buffer     = malloc(2 * zpl->dither.out_width + 1);\n  zpl->last_buffer     = malloc(zpl->dither.out_width);\n  zpl->last_buffer_set = 0;\n\n  if (!zpl->comp_buffer || !zpl->last_buffer)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate compression buffers.\");\n    return (false);\n  }\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_rwriteline()' - Write a raster line.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rwriteline(\n    pappl_job_t         *job,\t\t// I - Job\n    pappl_pr_options_t  *options,\t// I - Job options\n    pappl_device_t      *device,\t// I - Output device\n    unsigned            y,\t\t// I - Line number\n    const unsigned char *line)\t\t// I - Line\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  unsigned\t\ti;\t\t// Looping var\n  const unsigned char\t*ptr;\t\t// Pointer into buffer\n  unsigned char\t\t*compptr;\t// Pointer into compression buffer\n#if ZPL_COMPRESSION\n  unsigned char\t\trepeat_char;\t// Repeated character\n  unsigned\t\trepeat_count;\t// Number of repeated characters\n#endif // ZPL_COMPRESSION\n  static const unsigned char *hex = (const unsigned char *)\"0123456789ABCDEF\";\n\t\t\t\t\t// Hex digits\n\n\n  if (!lprintDitherLine(&zpl->dither, y, line))\n    return (true);\n\n  // Determine whether this row is the same as the previous line.\n  // If so, output a ':' and return...\n  if (zpl->last_buffer_set && !memcmp(zpl->dither.output, zpl->last_buffer, zpl->dither.out_width))\n  {\n    papplDeviceWrite(device, \":\", 1);\n    return (true);\n  }\n\n  // Convert the line to hex digits...\n  for (ptr = zpl->dither.output, compptr = zpl->comp_buffer, i = zpl->dither.out_width; i > 0; i --, ptr ++)\n  {\n    *compptr++ = hex[*ptr >> 4];\n    *compptr++ = hex[*ptr & 15];\n  }\n\n#if ZPL_COMPRESSION\n  // Send run-length compressed HEX data...\n  *compptr = '\\0';\n\n  // Run-length compress the graphics...\n  for (compptr = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *compptr; compptr ++)\n  {\n    if (*compptr == repeat_char)\n    {\n      repeat_count ++;\n    }\n    else\n    {\n      lprint_zpl_compress(device, repeat_char, repeat_count);\n      repeat_char  = *compptr;\n      repeat_count = 1;\n    }\n  }\n\n  if (repeat_char == '0')\n  {\n    // Handle 0's on the end of the line...\n    if (repeat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    if (repeat_count > 0)\n      papplDevicePuts(device, \",\");\n  }\n  else\n    lprint_zpl_compress(device, repeat_char, repeat_count);\n\n#else\n  // Send uncompressed HEX data...\n  papplDeviceWrite(device, zpl->comp_buffer, compptr - zpl->comp_buffer);\n#endif // ZPL_COMPRESSION\n\n  // Save this line for the next round...\n  memcpy(zpl->last_buffer, zpl->dither.output, zpl->dither.out_width);\n  zpl->last_buffer_set = 1;\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_status()' - Get current printer status.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_status(\n    pappl_printer_t *printer)\t\t// I - Printer\n{\n  pappl_device_t\t*device;\t// Connection to printer\n  char\t\t\tline[1025];\t// Line from printer\n  ssize_t\t\tbytes;\t\t// Bytes read\n  int\t\t\tlength = 0;\t// Label length\n  bool\t\t\tret = false;\t// Return value\n\n\n  if ((device = papplPrinterOpenDevice(printer)) == NULL)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to open device for status.\");\n    return (false);\n  }\n\n  // Get the printer status...\n  if (!lprint_zpl_update_reasons(printer, NULL, device))\n    goto done;\n\n  // Query host status...\n  if (papplDevicePuts(device, \"~HS\\n\") < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to send HS status command.\");\n    goto done;\n  }\n\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to read HS status response.\");\n    goto done;\n  }\n\n  line[bytes] = '\\0';\n\n  papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"HS returned '%s'.\", line);\n\n  if (sscanf(line + 1, \"%*d,%*d,%*d,%d\", &length) == 1 && length > 11)\n  {\n    // Auto-detect label length for ready media...\n    pappl_pr_driver_data_t\tdata;\t// Driver data\n\n    papplPrinterGetDriverData(printer, &data);\n\n    // Round the length to the nearest dot and snap to the nearest 1/4\"...\n    length = (2540 * length + data.y_resolution[0] / 2) / data.y_resolution[0];\n\n    if ((length % 635) <= 100)\n      length += length % 635;\n    else if ((length % 635) >= 535)\n      length += 635 - (length % 635);\n\n    // Lookup size\n    lprintMediaMatch(printer, 0, 0, length);\n  }\n\n  ret = true;\n\n  done:\n\n  papplPrinterCloseDevice(printer);\n\n  return (ret);\n}\n\n\n//\n// 'lprint_zpl_update_reasons()' - Update \"printer-state-reasons\" values.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_update_reasons(\n    pappl_printer_t *printer,\t\t// I - Printer\n    pappl_job_t     *job,\t\t// I - Current job or `NULL` if none\n    pappl_device_t  *device)\t\t// I - Connection to device\n{\n  char\t\t\tline[1025],\t// Line from printer\n\t\t\t*lineptr;\t// Pointer into line\n  ssize_t\t\tbytes;\t\t// Bytes read\n  unsigned\t\terrors = 0,\t// Detected errors\n\t\t\twarnings = 0;\t// Detected warnings\n  pappl_preason_t\treasons;\t// \"printer-state-reasons\" values\n\n\n  // Get the printer status...\n  if (papplDevicePuts(device, \"~HQES\\n\") < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to send HQES status command.\");\n    return (false);\n  }\n\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to read HQES status response.\");\n    return (false);\n  }\n\n  line[bytes] = '\\0';\n\n  papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"HQES returned '%s'.\", line);\n\n  if ((lineptr = strstr(line, \"ERRORS:\")) != NULL)\n  {\n    if (sscanf(lineptr + 7, \"%*d%*x%x\", &errors) != 1)\n      errors = 0;\n  }\n\n  if ((lineptr = strstr(line, \"WARNINGS:\")) != NULL)\n  {\n    if (sscanf(lineptr + 9, \"%*d%*x%x\", &warnings) != 1)\n      warnings = 0;\n  }\n\n  reasons = PAPPL_PREASON_NONE;\n\n  if (errors & ZPL_ERROR_MEDIA_OUT)\n    reasons |= PAPPL_PREASON_MEDIA_EMPTY;\n\n  if (errors & ZPL_ERROR_PAPER_JAM)\n    reasons |= PAPPL_PREASON_MEDIA_JAM;\n\n  if (errors & ZPL_ERROR_PAUSED)\n    reasons |= PAPPL_PREASON_OFFLINE;\n\n  if (errors & ZPL_ERROR_RIBBON_OUT)\n    reasons |= PAPPL_PREASON_MARKER_SUPPLY_EMPTY;\n\n  if (errors & ~(ZPL_ERROR_MEDIA_OUT | ZPL_ERROR_PAPER_JAM | ZPL_ERROR_PAUSED))\n  {\n    reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_ERROR_HEAD_OPEN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Print head open.\");\n    if (errors & ZPL_ERROR_CUTTER_FAULT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Cutter fault.\");\n    if (errors & ZPL_ERROR_CLEAR_PP_FAILED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Clear paper path failed.\");\n    if (errors & ZPL_ERROR_PAPER_FEED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Paper feed error.\");\n    if (errors & ZPL_ERROR_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Presenter error.\");\n    if (errors & ZPL_ERROR_MARK_NOT_FOUND)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark not found.\");\n    if (errors & ZPL_ERROR_MARK_CALIBRATE)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark calibration error.\");\n    if (errors & ZPL_ERROR_RETRACT_TIMEOUT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Retraction timeout.\");\n  }\n\n  if (warnings & ZPL_WARNING_PAPER_ALMOST_OUT)\n    reasons |= PAPPL_PREASON_MEDIA_LOW;\n\n  if (warnings & ~ZPL_WARNING_PAPER_ALMOST_OUT)\n  {\n    reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_WARNING_REPLACE_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Replace print head.\");\n\n    if (errors & ZPL_WARNING_CLEAN_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Clean print head.\");\n\n    if (errors & ZPL_WARNING_CALIBRATE_MEDIA)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Calibrate media.\");\n\n    if (errors & ZPL_WARNING_PAPER_BEFORE_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper before head.\");\n\n    if (errors & ZPL_WARNING_BLACK_MARK)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Black mark.\");\n\n    if (errors & ZPL_WARNING_PAPER_AFTER_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper after head.\");\n\n    if (errors & ZPL_WARNING_LOOP_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Loop ready.\");\n\n    if (errors & ZPL_WARNING_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Presenter.\");\n\n    if (errors & ZPL_WARNING_RETRACT_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Retract ready.\");\n\n    if (errors & ZPL_WARNING_IN_RETRACT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"In retract.\");\n\n    if (errors & ZPL_WARNING_AT_BIN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"At bin.\");\n  }\n\n  if (job && (reasons & PAPPL_PREASON_MEDIA_EMPTY))\n    reasons |= PAPPL_PREASON_MEDIA_NEEDED;\n\n  papplPrinterSetReasons(printer, reasons, ~reasons);\n\n  return (true);\n}\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 1,
    "end_line": 963,
    "code": "//\n// ZPL driver for LPrint, a Label Printer Application\n//\n// Copyright \u00a9\u00a02019-2025 by Michael R Sweet.\n// Copyright \u00a9\u00a02007-2019 by Apple Inc.\n// Copyright \u00a9\u00a02001-2007 by Easy Software Products.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n#include \"lprint.h\"\n\n\n// Define to 1 to use run-length encoding, 0 for uncompressed\n#define ZPL_COMPRESSION 1\n\n// Error and warning bits\n#define ZPL_ERROR_MEDIA_OUT\t\t0x00000001\n#define ZPL_ERROR_RIBBON_OUT\t\t0x00000002\n#define ZPL_ERROR_HEAD_OPEN\t\t0x00000004\n#define ZPL_ERROR_CUTTER_FAULT\t\t0x00000008\n#define ZPL_ERROR_CLEAR_PP_FAILED\t0x00008000\n#define ZPL_ERROR_PAPER_FEED\t\t0x00004000\n#define ZPL_ERROR_PRESENTER\t\t0x00002000\n#define ZPL_ERROR_PAPER_JAM\t\t0x00001000\n#define ZPL_ERROR_MARK_NOT_FOUND\t0x00080000\n#define ZPL_ERROR_MARK_CALIBRATE\t0x00040000\n#define ZPL_ERROR_RETRACT_TIMEOUT\t0x00020000\n#define ZPL_ERROR_PAUSED\t\t0x00010000\n\n#define ZPL_WARNING_PAPER_ALMOST_OUT\t0x00000008\n#define ZPL_WARNING_REPLACE_PRINTHEAD\t0x00000004\n#define ZPL_WARNING_CLEAN_PRINTHEAD\t0x00000002\n#define ZPL_WARNING_CALIBRATE_MEDIA\t0x00000001\n#define ZPL_WARNING_PAPER_BEFORE_HEAD\t0x00000010\n#define ZPL_WARNING_BLACK_MARK\t\t0x00000020\n#define ZPL_WARNING_PAPER_AFTER_HEAD\t0x00000040\n#define ZPL_WARNING_LOOP_READY\t\t0x00000080\n#define ZPL_WARNING_PRESENTER\t\t0x00000100\n#define ZPL_WARNING_RETRACT_READY\t0x00000200\n#define ZPL_WARNING_IN_RETRACT\t\t0x00000400\n#define ZPL_WARNING_AT_BIN\t\t0x00000800\n\n\n//\n// Local types...\n//\n\ntypedef struct lprint_zpl_s\t\t// ZPL driver data\n{\n  lprint_dither_t dither;\t\t// Dither buffer\n  unsigned char\t*comp_buffer;\t\t// Compression buffer\n  unsigned char *last_buffer;\t\t// Last line\n  int\t\tlast_buffer_set;\t// Is the last line set?\n} lprint_zpl_t;\n\n\n//\n// Local globals...\n//\n\nstatic const char * const lprint_zpl_2inch_media[] =\n{\t\t\t\t\t// Supported 2 inch media sizes\n  \"oe_1.25x0.25-label_1.25x0.25in\",\n  \"oe_1.25x2.25-label_1.25x2.25in\",\n\n  \"oe_1.5x0.25-label_1.5x0.25in\",\n  \"oe_1.5x0.5-label_1.5x0.5in\",\n  \"oe_1.5x1-label_1.5x1in\",\n  \"oe_1.5x2-label_1.5x2in\",\n\n  \"oe_2x0.37-label_2x0.37in\",\n  \"oe_2x0.5-label_2x0.5in\",\n  \"oe_2x1-label_2x1in\",\n  \"oe_2x1.25-label_2x1.25in\",\n  \"oe_2x2-label_2x2in\",\n  \"oe_2x3-label_2x3in\",\n  \"oe_2x4-label_2x4in\",\n  \"oe_2x5.5-label_2x5.5in\",\n\n  \"roll_max_2x39.6in\",\n  \"roll_min_0.75x0.25in\"\n};\nstatic const char * const lprint_zpl_4inch_media[] =\n{\t\t\t\t\t// Supported 4 inch media sizes\n  \"oe_1.25x0.25-label_1.25x0.25in\",\n  \"oe_1.25x2.25-label_1.25x2.25in\",\n\n  \"oe_1.5x0.25-label_1.5x0.25in\",\n  \"oe_1.5x0.5-label_1.5x0.5in\",\n  \"oe_1.5x1-label_1.5x1in\",\n  \"oe_1.5x2-label_1.5x2in\",\n\n  \"oe_2x0.37-label_2x0.37in\",\n  \"oe_2x0.5-label_2x0.5in\",\n  \"oe_2x1-label_2x1in\",\n  \"oe_2x1.25-label_2x1.25in\",\n  \"oe_2x2-label_2x2in\",\n  \"oe_2x3-label_2x3in\",\n  \"oe_2x4-label_2x4in\",\n  \"oe_2x5.5-label_2x5.5in\",\n\n  \"oe_2.25x0.5-label_2.25x0.5in\",\n  \"oe_2.25x1.25-label_2.25x1.25in\",\n  \"oe_30859-paint-can-label_2.25x3.125in\",\n  \"oe_2.25x4-label_2.25x4in\",\n  \"oe_2.25x5.5-label_2.25x5.5in\",\n\n  \"oe_2.38x5.5-label_2.38x5.5in\",\n\n  \"oe_2.5x1-label_2.5x1in\",\n  \"oe_2.5x2-label_2.5x2in\",\n\n  \"oe_2.75x1.25-label_2.75x1.25in\",\n\n  \"oe_2.9x1-label_2.9x1in\",\n\n  \"oe_3x1-label_3x1in\",\n  \"oe_3x1.25-label_3x1.25in\",\n  \"oe_3x2-label_3x2in\",\n  \"oe_3x3-label_3x3in\",\n  \"na_index-3x5_3x5in\",\n\n  \"oe_3.25x2-label_3.25x2in\",\n  \"oe_3.25x5-label_3.25x5in\",\n  \"oe_3.25x5.5-label_3.25x5.5in\",\n  \"oe_3.25x5.83-label_3.25x5.83in\",\n  \"oe_3.25x7.83-label_3.25x7.83in\",\n\n  \"oe_3.5x1-label_3.5x1in\",\n\n  \"oe_4x1-label_4x1in\",\n  \"oe_4x2-label_4x2in\",\n  \"oe_4x3-label_4x3in\",\n  \"oe_4x4-label_4x4in\",\n  \"oe_4x5-label_4x5in\",\n  \"na_index-4x6_4x6in\",\n  \"oe_4x6.5-label_4x6.5in\",\n  \"oe_4x7.83-label_4x7.83in\",\n  \"oe_4x8-label_4x8in\",\n  \"oe_4x13-label_4x13in\",\n\n  \"roll_max_4x39.6in\",\n  \"roll_min_0.75x0.25in\"\n\n/*\n  \"oe_6x1-label_6x1in\",\n  \"oe_6x2-label_6x2in\",\n  \"oe_6x3-label_6x3in\",\n  \"oe_6x4-label_6x4in\",\n  \"oe_6x5-label_6x5in\",\n  \"oe_6x6-label_6x6in\",\n  \"oe_6x6.5-label_6x6.5in\",\n  \"oe_6x13-label_6x13in\",\n\n  \"oe_8x1-label_8x1in\",\n  \"oe_8x2-label_8x2in\",\n  \"oe_8x3-label_8x3in\",\n  \"oe_8x4-label_8x4in\",\n  \"oe_8x5-label_8x5in\",\n  \"oe_8x6-label_8x6in\",\n  \"oe_8x6.5-label_8x6.5in\",\n  \"oe_8x13-label_8x13in\",\n\n  \"roll_max_8x39.6in\",\n  \"roll_min_1.25x0.25in\"\n*/\n};\n\n\n//\n// Local functions...\n//\n\n#if ZPL_COMPRESSION\nstatic bool\tlprint_zpl_compress(pappl_device_t *device, unsigned char ch, unsigned count);\n#endif // ZPL_COMPRESSION\nstatic bool\tlprint_zpl_printfile(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device);\nstatic bool\tlprint_zpl_rendjob(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device);\nstatic bool\tlprint_zpl_rendpage(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device, unsigned page);\nstatic bool\tlprint_zpl_rstartjob(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device);\nstatic bool\tlprint_zpl_rstartpage(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device, unsigned page);\nstatic bool\tlprint_zpl_rwriteline(pappl_job_t *job, pappl_pr_options_t *options, pappl_device_t *device, unsigned y, const unsigned char *line);\nstatic bool\tlprint_zpl_status(pappl_printer_t *printer);\nstatic bool\tlprint_zpl_update_reasons(pappl_printer_t *printer, pappl_job_t *job, pappl_device_t *device);\n\n\n//\n// 'lprintZPL()' - Initialize the ZPL driver.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on error\nlprintZPL(\n    pappl_system_t         *system,\t// I - System\n    const char             *driver_name,// I - Driver name\n    const char             *device_uri,\t// I - Device URI\n    const char             *device_id,\t// I - 1284 device ID\n    pappl_pr_driver_data_t *data,\t// I - Pointer to driver data\n    ipp_t                  **attrs,\t// O - Pointer to driver attributes\n    void                   *cbdata)\t// I - Callback data (not used)\n{\n  data->printfile_cb  = lprint_zpl_printfile;\n  data->rendjob_cb    = lprint_zpl_rendjob;\n  data->rendpage_cb   = lprint_zpl_rendpage;\n  data->rstartjob_cb  = lprint_zpl_rstartjob;\n  data->rstartpage_cb = lprint_zpl_rstartpage;\n  data->rwriteline_cb = lprint_zpl_rwriteline;\n  data->status_cb     = lprint_zpl_status;\n  data->format        = LPRINT_ZPL_MIMETYPE;\n\n  data->num_resolution = 1;\n\n  if (strstr(driver_name, \"-203dpi\"))\n  {\n    data->x_resolution[0] = 203;\n    data->y_resolution[0] = 203;\n  }\n  else if (strstr(driver_name, \"-300dpi\"))\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n  else\n  {\n    data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  data->x_default = data->y_default = data->x_resolution[0];\n\n  if (strstr(driver_name, \"-cutter\"))\n    data->finishings |= PAPPL_FINISHINGS_TRIM;\n\n  if (!strncmp(driver_name, \"zpl_2inch-\", 16))\n  {\n    // 2 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_2inch_media) / sizeof(lprint_zpl_2inch_media[0]));\n    memcpy(data->media, lprint_zpl_2inch_media, sizeof(lprint_zpl_2inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"oe_2x3-label_2x3in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n  else\n  {\n    // 4 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_4inch_media) / sizeof(lprint_zpl_4inch_media[0]));\n    memcpy(data->media, lprint_zpl_4inch_media, sizeof(lprint_zpl_4inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  data->media_ready[0].tracking = PAPPL_MEDIA_TRACKING_GAP;\n\n  data->bottom_top = data->left_right = 1;\n\n  data->num_source = 1;\n  data->source[0]  = \"main-roll\";\n\n  data->top_offset_supported[0] = -1500;\n  data->top_offset_supported[1] = 1500;\n  data->tracking_supported      = PAPPL_MEDIA_TRACKING_MARK | PAPPL_MEDIA_TRACKING_WEB | PAPPL_MEDIA_TRACKING_GAP | PAPPL_MEDIA_TRACKING_CONTINUOUS;\n\n  data->num_type = 3;\n  data->type[0]  = \"continuous\";\n  data->type[1]  = \"labels\";\n  data->type[2]  = \"labels-continuous\";\n\n  data->mode_configured = PAPPL_LABEL_MODE_TEAR_OFF;\n  data->mode_supported = PAPPL_LABEL_MODE_APPLICATOR | PAPPL_LABEL_MODE_CUTTER | PAPPL_LABEL_MODE_CUTTER_DELAYED | PAPPL_LABEL_MODE_KIOSK | PAPPL_LABEL_MODE_PEEL_OFF | PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL | PAPPL_LABEL_MODE_REWIND | PAPPL_LABEL_MODE_RFID | PAPPL_LABEL_MODE_TEAR_OFF;\n\n  data->tear_offset_configured   = 0;\n  data->tear_offset_supported[0] = -1500;\n  data->tear_offset_supported[1] = 1500;\n\n  data->speed_default      = 0;\n  data->speed_supported[0] = 2540;\n  data->speed_supported[1] = 12 * 2540;\n\n  data->darkness_configured = 50;\n  data->darkness_supported  = 30;\n\n  return (true);\n}\n\n\n//\n// 'lprintZPLQueryDriver()' - Query the printer to determine the proper driver.\n//\n\nvoid\nlprintZPLQueryDriver(\n    pappl_system_t *system,\t\t// I - System\n    const char     *device_uri,\t\t// I - Device URI\n    char           *name,\t\t// I - Name buffer\n    size_t         namesize)\t\t// I - Size of name buffer\n{\n  pappl_device_t\t*device;\t// Device connection\n  char\t\t\tline[1025];\t// Line from device\n  ssize_t\t\tbytes;\t\t// Bytes read\n  char\t\t\tmodel[256],\t// Model name\n\t\t\t*modelptr;\t// Pointer into model name\n  int\t\t\tdpmm = 0;\t// Dots per millimeter\n\n\n  // Make sure name buffer is initialized...\n  *name = '\\0';\n\n  // Connect and send Host Information command...\n  if ((device = papplDeviceOpen(device_uri, \"query\", papplLogDevice, system)) == NULL)\n    return;\n\n  if (papplDevicePuts(device, \"~HI\\n\") < 0)\n    goto done;\n\n  // Read and parse response:\n  //\n  // <stx>MODEL,VERSION,DPMM,MEMORY,OPTIONS<etx><cr><lf>\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) <= 0)\n    goto done;\n\n  line[bytes] = '\\0';\n\n  papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"HI response for '%s' was '%s'.\", device_uri, line);\n\n  if (line[0] == 0x02 && sscanf(line + 1, \"%255[^,],%*[^,],%d\", model, &dpmm) > 1 && (dpmm == 8 || dpmm == 12 || dpmm == 24))\n  {\n    // Got model and dots-per-millimeter values, create a driver name from it...\n    // Note: We currently assume a 4\" print head for auto-detection...\n    const char\t*type = \"tt\";\t\t// Type of printing (direct/transfer)\n    int\t\tdpi;\t\t\t// Print resolution\n\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"model='%s', dpmm=%d\", model, dpmm);\n\n    if ((modelptr = strchr(model, '-')) != NULL && modelptr > model)\n    {\n      if (modelptr[-1] == 'd')\n        type = \"dt\";\n    }\n\n    if (dpmm == 8)\n      dpi = 203;\t\t\t// 203.2\n    else if (dpmm == 12)\n      dpi = 300;\t\t\t// Technically should be 304.8...\n    else\n      dpi = 600;\t\t\t// Technically should be 609.6...\n\n    snprintf(name, namesize, \"zpl_4inch-%ddpi-%s\", dpi, type);\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"auto driver-name='%s'\", name);\n  }\n\n  done:\n\n  papplDeviceClose(device);\n  return;\n}\n\n\n#if ZPL_COMPRESSION\n//\n// 'lprint_zpl_compress()' - Output a RLE run...\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_compress(\n    pappl_device_t *device,\t\t// I - Output device\n    unsigned char  ch,\t\t\t// I - Repeat character\n    unsigned       count)\t\t// I - Repeat count\n{\n  unsigned char\tbuffer[8192],\t\t// Output buffer\n\t\t*bufptr = buffer;\t// Pointer into buffer\n\n\n  if (count > 1)\n  {\n    // Print as many z's as possible - they are the largest denomination\n    // representing 400 characters (zC stands for 400 adjacent C's)\n    while (count >= 400)\n    {\n      count -= 400;\n      *bufptr++ = 'z';\n\n      if (bufptr >= (buffer + sizeof(buffer)))\n      {\n        if (papplDeviceWrite(device, buffer, sizeof(buffer)) < 0)\n          return (0);\n\n\tbufptr = buffer;\n      }\n    }\n\n    // Then print 'g' through 'y' as multiples of 20 characters...\n    if (count >= 20)\n    {\n      *bufptr++ = 'f' + count / 20;\n      count %= 20;\n    }\n\n    // Finally, print 'G' through 'Y' as 1 through 19 characters...\n    if (count > 0)\n      *bufptr++ = 'F' + count;\n  }\n\n  // Then the character to be repeated...\n  *bufptr++ = ch;\n\n  return (papplDeviceWrite(device, buffer, bufptr - buffer) > 0);\n}\n#endif // ZPL_COMPRESSION\n\n\n//\n// 'lprint_zpl_print()' - Print a file.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_printfile(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device)\t\t// I - Output device\n{\n  int\t\tfd;\t\t\t// Input file\n  ssize_t\tbytes;\t\t\t// Bytes read/written\n  char\t\tbuffer[65536];\t\t// Read/write buffer\n\n\n  // Copy the raw file...\n  papplJobSetImpressions(job, 1);\n\n  if ((fd  = open(papplJobGetFilename(job), O_RDONLY)) < 0)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to open print file '%s': %s\", papplJobGetFilename(job), strerror(errno));\n    return (false);\n  }\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Copy print data...\n  while ((bytes = read(fd, buffer, sizeof(buffer))) > 0)\n  {\n    if (papplDeviceWrite(device, buffer, (size_t)bytes) < 0)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to send %d bytes to printer.\", (int)bytes);\n      close(fd);\n      return (false);\n    }\n  }\n  close(fd);\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_rendjob()' - End a job.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rendjob(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device)\t\t// I - Output device\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n\n\n  (void)options;\n\n  free(zpl);\n  papplJobSetData(job, NULL);\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_rendpage()' - End a page.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rendpage(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device,\t\t// I - Output device\n    unsigned           page)\t\t// I - Page number\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n\n\n  (void)page;\n\n  lprint_zpl_rwriteline(job, options, device, options->header.cupsHeight, NULL);\n\n  papplDevicePrintf(device, \"^XA\\n^POI\\n^PW%u\\n^LH0,0\\n^LT%d\\n\", options->header.cupsWidth, options->media.top_offset * options->printer_resolution[1] / 2540);\n\n  if (options->media.type[0] && strcmp(options->media.type, \"labels\"))\n  {\n    // Continuous media, so always set tracking to continuous...\n    options->media.tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS;\n  }\n\n  if (options->media.tracking)\n  {\n    if (options->media.tracking == PAPPL_MEDIA_TRACKING_CONTINUOUS)\n      papplDevicePrintf(device, \"^LL%u\\n^MNN\\n\", options->header.cupsHeight);\n    else if (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n  if (strstr(papplPrinterGetDriverName(papplJobGetPrinter(job)), \"-tt\"))\n    papplDevicePuts(device, \"^MTT\\n\");\t// Thermal transfer\n  else\n    papplDevicePuts(device, \"^MTD\\n\");\t// Direct thermal\n\n  papplDevicePrintf(device, \"^PQ1, 0, 0, N\\n\");\n  papplDevicePuts(device, \"^FO0,0^XGR:LPRINT.GRF,1,1^FS\\n^XZ\\n\");\n  papplDevicePuts(device, \"^XA\\n^IDR:LPRINT.GRF^FS\\n^XZ\\n\");\n\n  if (options->finishings & PAPPL_FINISHINGS_TRIM)\n    papplDevicePuts(device, \"^CN1\\n\");\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Free memory and return...\n  lprintDitherFree(&zpl->dither);\n\n  free(zpl->comp_buffer);\n  free(zpl->last_buffer);\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_rstartjob()' - Start a job.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rstartjob(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device)\t\t// I - Output device\n{\n  pappl_pr_driver_data_t data;\t\t// Driver data\n  int\t\t\tdarkness;\t// Composite darkness value\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)calloc(1, sizeof(lprint_zpl_t));\n\t\t\t\t\t// ZPL driver data\n\n\n  // Initialize driver data...\n  papplJobSetData(job, zpl);\n\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  // label-mode-configured\n  switch (data.mode_configured)\n  {\n    case PAPPL_LABEL_MODE_APPLICATOR :\n        papplDevicePuts(device, \"^MMA,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER :\n        papplDevicePuts(device, \"^MMC,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER_DELAYED :\n        papplDevicePuts(device, \"^MMD,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_KIOSK :\n        papplDevicePuts(device, \"^MMK,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF :\n        papplDevicePuts(device, \"^MMP,N\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL :\n        papplDevicePuts(device, \"^MMP,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_REWIND :\n        papplDevicePuts(device, \"^MMR,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_RFID :\n        papplDevicePuts(device, \"^MMF,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_TEAR_OFF :\n    default :\n        papplDevicePuts(device, \"^MMT,Y\\n\");\n        break;\n  }\n\n  // label-tear-offset-configured\n  if (data.tear_offset_configured < 0)\n    papplDevicePrintf(device, \"~TA%04d\\n\", data.tear_offset_configured);\n  else if (data.tear_offset_configured > 0)\n    papplDevicePrintf(device, \"~TA%03d\\n\", data.tear_offset_configured);\n\n  // print-darkness / printer-darkness-configured\n  if ((darkness = options->print_darkness + options->darkness_configured) < 0)\n    darkness = 0;\n  else if (darkness > 100)\n    darkness = 100;\n\n  papplDevicePrintf(device, \"~SD%02u\\n\", 30 * darkness / 100);\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_rstartpage()' - Start a page.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rstartpage(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device,\t\t// I - Output device\n    unsigned           page)\t\t// I - Page number\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  int\t\tips;\t\t\t// Inches per second\n  double\tout_gamma = 1.0;\t// Output gamma correction\n\n\n  (void)page;\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Setup dither buffer...\n  if (options->header.HWResolution[0] == 300)\n    out_gamma = 1.2;\n  else if (options->header.HWResolution[0] == 600)\n    out_gamma = 1.44;\n\n  if (!lprintDitherAlloc(&zpl->dither, job, options, CUPS_CSPACE_K, out_gamma))\n    return (false);\n\n  // print-speed\n  if ((ips = options->print_speed / 2540) > 0)\n    papplDevicePrintf(device, \"^PR%d,%d,%d\\n\", ips, ips, ips);\n\n  // Download bitmap...\n  papplDevicePrintf(device, \"~DGR:LPRINT.GRF,%u,%u,\\n\", zpl->dither.in_height * zpl->dither.out_width, zpl->dither.out_width);\n\n  // Allocate memory for writing the bitmap...\n  zpl->comp_buffer     = malloc(2 * zpl->dither.out_width + 1);\n  zpl->last_buffer     = malloc(zpl->dither.out_width);\n  zpl->last_buffer_set = 0;\n\n  if (!zpl->comp_buffer || !zpl->last_buffer)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate compression buffers.\");\n    return (false);\n  }\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_rwriteline()' - Write a raster line.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rwriteline(\n    pappl_job_t         *job,\t\t// I - Job\n    pappl_pr_options_t  *options,\t// I - Job options\n    pappl_device_t      *device,\t// I - Output device\n    unsigned            y,\t\t// I - Line number\n    const unsigned char *line)\t\t// I - Line\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  unsigned\t\ti;\t\t// Looping var\n  const unsigned char\t*ptr;\t\t// Pointer into buffer\n  unsigned char\t\t*compptr;\t// Pointer into compression buffer\n#if ZPL_COMPRESSION\n  unsigned char\t\trepeat_char;\t// Repeated character\n  unsigned\t\trepeat_count;\t// Number of repeated characters\n#endif // ZPL_COMPRESSION\n  static const unsigned char *hex = (const unsigned char *)\"0123456789ABCDEF\";\n\t\t\t\t\t// Hex digits\n\n\n  if (!lprintDitherLine(&zpl->dither, y, line))\n    return (true);\n\n  // Determine whether this row is the same as the previous line.\n  // If so, output a ':' and return...\n  if (zpl->last_buffer_set && !memcmp(zpl->dither.output, zpl->last_buffer, zpl->dither.out_width))\n  {\n    papplDeviceWrite(device, \":\", 1);\n    return (true);\n  }\n\n  // Convert the line to hex digits...\n  for (ptr = zpl->dither.output, compptr = zpl->comp_buffer, i = zpl->dither.out_width; i > 0; i --, ptr ++)\n  {\n    *compptr++ = hex[*ptr >> 4];\n    *compptr++ = hex[*ptr & 15];\n  }\n\n#if ZPL_COMPRESSION\n  // Send run-length compressed HEX data...\n  *compptr = '\\0';\n\n  // Run-length compress the graphics...\n  for (compptr = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *compptr; compptr ++)\n  {\n    if (*compptr == repeat_char)\n    {\n      repeat_count ++;\n    }\n    else\n    {\n      lprint_zpl_compress(device, repeat_char, repeat_count);\n      repeat_char  = *compptr;\n      repeat_count = 1;\n    }\n  }\n\n  if (repeat_char == '0')\n  {\n    // Handle 0's on the end of the line...\n    if (repeat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    if (repeat_count > 0)\n      papplDevicePuts(device, \",\");\n  }\n  else\n    lprint_zpl_compress(device, repeat_char, repeat_count);\n\n#else\n  // Send uncompressed HEX data...\n  papplDeviceWrite(device, zpl->comp_buffer, compptr - zpl->comp_buffer);\n#endif // ZPL_COMPRESSION\n\n  // Save this line for the next round...\n  memcpy(zpl->last_buffer, zpl->dither.output, zpl->dither.out_width);\n  zpl->last_buffer_set = 1;\n\n  return (true);\n}\n\n\n//\n// 'lprint_zpl_status()' - Get current printer status.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_status(\n    pappl_printer_t *printer)\t\t// I - Printer\n{\n  pappl_device_t\t*device;\t// Connection to printer\n  char\t\t\tline[1025];\t// Line from printer\n  ssize_t\t\tbytes;\t\t// Bytes read\n  int\t\t\tlength = 0;\t// Label length\n  bool\t\t\tret = false;\t// Return value\n\n\n  if ((device = papplPrinterOpenDevice(printer)) == NULL)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to open device for status.\");\n    return (false);\n  }\n\n  // Get the printer status...\n  if (!lprint_zpl_update_reasons(printer, NULL, device))\n    goto done;\n\n  // Query host status...\n  if (papplDevicePuts(device, \"~HS\\n\") < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to send HS status command.\");\n    goto done;\n  }\n\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to read HS status response.\");\n    goto done;\n  }\n\n  line[bytes] = '\\0';\n\n  papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"HS returned '%s'.\", line);\n\n  if (sscanf(line + 1, \"%*d,%*d,%*d,%d\", &length) == 1 && length > 11)\n  {\n    // Auto-detect label length for ready media...\n    pappl_pr_driver_data_t\tdata;\t// Driver data\n\n    papplPrinterGetDriverData(printer, &data);\n\n    // Round the length to the nearest dot and snap to the nearest 1/4\"...\n    length = (2540 * length + data.y_resolution[0] / 2) / data.y_resolution[0];\n\n    if ((length % 635) <= 100)\n      length += length % 635;\n    else if ((length % 635) >= 535)\n      length += 635 - (length % 635);\n\n    // Lookup size\n    lprintMediaMatch(printer, 0, 0, length);\n  }\n\n  ret = true;\n\n  done:\n\n  papplPrinterCloseDevice(printer);\n\n  return (ret);\n}\n\n\n//\n// 'lprint_zpl_update_reasons()' - Update \"printer-state-reasons\" values.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_update_reasons(\n    pappl_printer_t *printer,\t\t// I - Printer\n    pappl_job_t     *job,\t\t// I - Current job or `NULL` if none\n    pappl_device_t  *device)\t\t// I - Connection to device\n{\n  char\t\t\tline[1025],\t// Line from printer\n\t\t\t*lineptr;\t// Pointer into line\n  ssize_t\t\tbytes;\t\t// Bytes read\n  unsigned\t\terrors = 0,\t// Detected errors\n\t\t\twarnings = 0;\t// Detected warnings\n  pappl_preason_t\treasons;\t// \"printer-state-reasons\" values\n\n\n  // Get the printer status...\n  if (papplDevicePuts(device, \"~HQES\\n\") < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to send HQES status command.\");\n    return (false);\n  }\n\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to read HQES status response.\");\n    return (false);\n  }\n\n  line[bytes] = '\\0';\n\n  papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"HQES returned '%s'.\", line);\n\n  if ((lineptr = strstr(line, \"ERRORS:\")) != NULL)\n  {\n    if (sscanf(lineptr + 7, \"%*d%*x%x\", &errors) != 1)\n      errors = 0;\n  }\n\n  if ((lineptr = strstr(line, \"WARNINGS:\")) != NULL)\n  {\n    if (sscanf(lineptr + 9, \"%*d%*x%x\", &warnings) != 1)\n      warnings = 0;\n  }\n\n  reasons = PAPPL_PREASON_NONE;\n\n  if (errors & ZPL_ERROR_MEDIA_OUT)\n    reasons |= PAPPL_PREASON_MEDIA_EMPTY;\n\n  if (errors & ZPL_ERROR_PAPER_JAM)\n    reasons |= PAPPL_PREASON_MEDIA_JAM;\n\n  if (errors & ZPL_ERROR_PAUSED)\n    reasons |= PAPPL_PREASON_OFFLINE;\n\n  if (errors & ZPL_ERROR_RIBBON_OUT)\n    reasons |= PAPPL_PREASON_MARKER_SUPPLY_EMPTY;\n\n  if (errors & ~(ZPL_ERROR_MEDIA_OUT | ZPL_ERROR_PAPER_JAM | ZPL_ERROR_PAUSED))\n  {\n    reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_ERROR_HEAD_OPEN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Print head open.\");\n    if (errors & ZPL_ERROR_CUTTER_FAULT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Cutter fault.\");\n    if (errors & ZPL_ERROR_CLEAR_PP_FAILED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Clear paper path failed.\");\n    if (errors & ZPL_ERROR_PAPER_FEED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Paper feed error.\");\n    if (errors & ZPL_ERROR_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Presenter error.\");\n    if (errors & ZPL_ERROR_MARK_NOT_FOUND)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark not found.\");\n    if (errors & ZPL_ERROR_MARK_CALIBRATE)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark calibration error.\");\n    if (errors & ZPL_ERROR_RETRACT_TIMEOUT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Retraction timeout.\");\n  }\n\n  if (warnings & ZPL_WARNING_PAPER_ALMOST_OUT)\n    reasons |= PAPPL_PREASON_MEDIA_LOW;\n\n  if (warnings & ~ZPL_WARNING_PAPER_ALMOST_OUT)\n  {\n    reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_WARNING_REPLACE_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Replace print head.\");\n\n    if (errors & ZPL_WARNING_CLEAN_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Clean print head.\");\n\n    if (errors & ZPL_WARNING_CALIBRATE_MEDIA)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Calibrate media.\");\n\n    if (errors & ZPL_WARNING_PAPER_BEFORE_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper before head.\");\n\n    if (errors & ZPL_WARNING_BLACK_MARK)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Black mark.\");\n\n    if (errors & ZPL_WARNING_PAPER_AFTER_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper after head.\");\n\n    if (errors & ZPL_WARNING_LOOP_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Loop ready.\");\n\n    if (errors & ZPL_WARNING_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Presenter.\");\n\n    if (errors & ZPL_WARNING_RETRACT_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Retract ready.\");\n\n    if (errors & ZPL_WARNING_IN_RETRACT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"In retract.\");\n\n    if (errors & ZPL_WARNING_AT_BIN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"At bin.\");\n  }\n\n  if (job && (reasons & PAPPL_PREASON_MEDIA_EMPTY))\n    reasons |= PAPPL_PREASON_MEDIA_NEEDED;\n\n  papplPrinterSetReasons(printer, reasons, ~reasons);\n\n  return (true);\n}\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "include",
    "start_line": 12,
    "end_line": 13,
    "code": "de \"lprint.h\"\n\n\n// D",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 16,
    "end_line": 17,
    "code": "e ZPL_COMPRESSION 1\n\n// Er",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 19,
    "end_line": 20,
    "code": "e ZPL_ERROR_MEDIA_OUT\t\t0x00000001\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 20,
    "end_line": 21,
    "code": "e ZPL_ERROR_RIBBON_OUT\t\t0x00000002\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 21,
    "end_line": 22,
    "code": "e ZPL_ERROR_HEAD_OPEN\t\t0x00000004\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 22,
    "end_line": 23,
    "code": "e ZPL_ERROR_CUTTER_FAULT\t\t0x00000008\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 23,
    "end_line": 24,
    "code": "e ZPL_ERROR_CLEAR_PP_FAILED\t0x00008000\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 24,
    "end_line": 25,
    "code": "e ZPL_ERROR_PAPER_FEED\t\t0x00004000\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 25,
    "end_line": 26,
    "code": "e ZPL_ERROR_PRESENTER\t\t0x00002000\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 26,
    "end_line": 27,
    "code": "e ZPL_ERROR_PAPER_JAM\t\t0x00001000\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 27,
    "end_line": 28,
    "code": "e ZPL_ERROR_MARK_NOT_FOUND\t0x00080000\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 28,
    "end_line": 29,
    "code": "e ZPL_ERROR_MARK_CALIBRATE\t0x00040000\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 29,
    "end_line": 30,
    "code": "e ZPL_ERROR_RETRACT_TIMEOUT\t0x00020000\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 30,
    "end_line": 31,
    "code": "e ZPL_ERROR_PAUSED\t\t0x00010000\n\n#defi",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 32,
    "end_line": 33,
    "code": "e ZPL_WARNING_PAPER_ALMOST_OUT\t0x00000008\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 33,
    "end_line": 34,
    "code": "e ZPL_WARNING_REPLACE_PRINTHEAD\t0x00000004\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 34,
    "end_line": 35,
    "code": "e ZPL_WARNING_CLEAN_PRINTHEAD\t0x00000002\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 35,
    "end_line": 36,
    "code": "e ZPL_WARNING_CALIBRATE_MEDIA\t0x00000001\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 36,
    "end_line": 37,
    "code": "e ZPL_WARNING_PAPER_BEFORE_HEAD\t0x00000010\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 37,
    "end_line": 38,
    "code": "e ZPL_WARNING_BLACK_MARK\t\t0x00000020\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 38,
    "end_line": 39,
    "code": "e ZPL_WARNING_PAPER_AFTER_HEAD\t0x00000040\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 39,
    "end_line": 40,
    "code": "e ZPL_WARNING_LOOP_READY\t\t0x00000080\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 40,
    "end_line": 41,
    "code": "e ZPL_WARNING_PRESENTER\t\t0x00000100\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 41,
    "end_line": 42,
    "code": "e ZPL_WARNING_RETRACT_READY\t0x00000200\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 42,
    "end_line": 43,
    "code": "e ZPL_WARNING_IN_RETRACT\t\t0x00000400\n#defin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "macro",
    "start_line": 43,
    "end_line": 44,
    "code": "e ZPL_WARNING_AT_BIN\t\t0x00000800\n\n\n//\n/",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "typedef",
    "start_line": 50,
    "end_line": 56,
    "code": "f struct lprint_zpl_s\t\t// ZPL driver data\n{\n  lprint_dither_t dither;\t\t// Dither buffer\n  unsigned char\t*comp_buffer;\t\t// Compression buffer\n  unsigned char *last_buffer;\t\t// Last line\n  int\t\tlast_buffer_set;\t// Is the last line set?\n} lprint_zpl_t;\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct",
    "name": "lprint_zpl_s",
    "hierarchy": "lprint_zpl_s",
    "start_line": 50,
    "end_line": 56,
    "code": " lprint_zpl_s\t\t// ZPL driver data\n{\n  lprint_dither_t dither;\t\t// Dither buffer\n  unsigned char\t*comp_buffer;\t\t// Compression buffer\n  unsigned char *last_buffer;\t\t// Last line\n  int\t\tlast_buffer_set;\t// Is the last line set?\n} lprin",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "global_variable",
    "start_line": 63,
    "end_line": 84,
    "code": " const char * const lprint_zpl_2inch_media[] =\n{\t\t\t\t\t// Supported 2 inch media sizes\n  \"oe_1.25x0.25-label_1.25x0.25in\",\n  \"oe_1.25x2.25-label_1.25x2.25in\",\n\n  \"oe_1.5x0.25-label_1.5x0.25in\",\n  \"oe_1.5x0.5-label_1.5x0.5in\",\n  \"oe_1.5x1-label_1.5x1in\",\n  \"oe_1.5x2-label_1.5x2in\",\n\n  \"oe_2x0.37-label_2x0.37in\",\n  \"oe_2x0.5-label_2x0.5in\",\n  \"oe_2x1-label_2x1in\",\n  \"oe_2x1.25-label_2x1.25in\",\n  \"oe_2x2-label_2x2in\",\n  \"oe_2x3-label_2x3in\",\n  \"oe_2x4-label_2x4in\",\n  \"oe_2x5.5-label_2x5.5in\",\n\n  \"roll_max_2x39.6in\",\n  \"roll_min_0.75x0.25in\"\n};\nstati",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 63,
    "end_line": 84,
    "code": " const char * const lprint_zpl_2inch_media[] =\n{\t\t\t\t\t// Supported 2 inch media sizes\n  \"oe_1.25x0.25-label_1.25x0.25in\",\n  \"oe_1.25x2.25-label_1.25x2.25in\",\n\n  \"oe_1.5x0.25-label_1.5x0.25in\",\n  \"oe_1.5x0.5-label_1.5x0.5in\",\n  \"oe_1.5x1-label_1.5x1in\",\n  \"oe_1.5x2-label_1.5x2in\",\n\n  \"oe_2x0.37-label_2x0.37in\",\n  \"oe_2x0.5-label_2x0.5in\",\n  \"oe_2x1-label_2x1in\",\n  \"oe_2x1.25-label_2x1.25in\",\n  \"oe_2x2-label_2x2in\",\n  \"oe_2x3-label_2x3in\",\n  \"oe_2x4-label_2x4in\",\n  \"oe_2x5.5-label_2x5.5in\",\n\n  \"roll_max_2x39.6in\",\n  \"roll_min_0.75x0.25in\"\n};\nstati",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 63,
    "end_line": 84,
    "code": "t lprint_zpl_2inch_media[] =\n{\t\t\t\t\t// Supported 2 inch media sizes\n  \"oe_1.25x0.25-label_1.25x0.25in\",\n  \"oe_1.25x2.25-label_1.25x2.25in\",\n\n  \"oe_1.5x0.25-label_1.5x0.25in\",\n  \"oe_1.5x0.5-label_1.5x0.5in\",\n  \"oe_1.5x1-label_1.5x1in\",\n  \"oe_1.5x2-label_1.5x2in\",\n\n  \"oe_2x0.37-label_2x0.37in\",\n  \"oe_2x0.5-label_2x0.5in\",\n  \"oe_2x1-label_2x1in\",\n  \"oe_2x1.25-label_2x1.25in\",\n  \"oe_2x2-label_2x2in\",\n  \"oe_2x3-label_2x3in\",\n  \"oe_2x4-label_2x4in\",\n  \"oe_2x5.5-label_2x5.5in\",\n\n  \"roll_max_2x39.6in\",\n  \"roll_min_0.75x0.25in\"\n};\nstat",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "global_variable",
    "start_line": 85,
    "end_line": 169,
    "code": " const char * const lprint_zpl_4inch_media[] =\n{\t\t\t\t\t// Supported 4 inch media sizes\n  \"oe_1.25x0.25-label_1.25x0.25in\",\n  \"oe_1.25x2.25-label_1.25x2.25in\",\n\n  \"oe_1.5x0.25-label_1.5x0.25in\",\n  \"oe_1.5x0.5-label_1.5x0.5in\",\n  \"oe_1.5x1-label_1.5x1in\",\n  \"oe_1.5x2-label_1.5x2in\",\n\n  \"oe_2x0.37-label_2x0.37in\",\n  \"oe_2x0.5-label_2x0.5in\",\n  \"oe_2x1-label_2x1in\",\n  \"oe_2x1.25-label_2x1.25in\",\n  \"oe_2x2-label_2x2in\",\n  \"oe_2x3-label_2x3in\",\n  \"oe_2x4-label_2x4in\",\n  \"oe_2x5.5-label_2x5.5in\",\n\n  \"oe_2.25x0.5-label_2.25x0.5in\",\n  \"oe_2.25x1.25-label_2.25x1.25in\",\n  \"oe_30859-paint-can-label_2.25x3.125in\",\n  \"oe_2.25x4-label_2.25x4in\",\n  \"oe_2.25x5.5-label_2.25x5.5in\",\n\n  \"oe_2.38x5.5-label_2.38x5.5in\",\n\n  \"oe_2.5x1-label_2.5x1in\",\n  \"oe_2.5x2-label_2.5x2in\",\n\n  \"oe_2.75x1.25-label_2.75x1.25in\",\n\n  \"oe_2.9x1-label_2.9x1in\",\n\n  \"oe_3x1-label_3x1in\",\n  \"oe_3x1.25-label_3x1.25in\",\n  \"oe_3x2-label_3x2in\",\n  \"oe_3x3-label_3x3in\",\n  \"na_index-3x5_3x5in\",\n\n  \"oe_3.25x2-label_3.25x2in\",\n  \"oe_3.25x5-label_3.25x5in\",\n  \"oe_3.25x5.5-label_3.25x5.5in\",\n  \"oe_3.25x5.83-label_3.25x5.83in\",\n  \"oe_3.25x7.83-label_3.25x7.83in\",\n\n  \"oe_3.5x1-label_3.5x1in\",\n\n  \"oe_4x1-label_4x1in\",\n  \"oe_4x2-label_4x2in\",\n  \"oe_4x3-label_4x3in\",\n  \"oe_4x4-label_4x4in\",\n  \"oe_4x5-label_4x5in\",\n  \"na_index-4x6_4x6in\",\n  \"oe_4x6.5-label_4x6.5in\",\n  \"oe_4x7.83-label_4x7.83in\",\n  \"oe_4x8-label_4x8in\",\n  \"oe_4x13-label_4x13in\",\n\n  \"roll_max_4x39.6in\",\n  \"roll_min_0.75x0.25in\"\n\n/*\n  \"oe_6x1-label_6x1in\",\n  \"oe_6x2-label_6x2in\",\n  \"oe_6x3-label_6x3in\",\n  \"oe_6x4-label_6x4in\",\n  \"oe_6x5-label_6x5in\",\n  \"oe_6x6-label_6x6in\",\n  \"oe_6x6.5-label_6x6.5in\",\n  \"oe_6x13-label_6x13in\",\n\n  \"oe_8x1-label_8x1in\",\n  \"oe_8x2-label_8x2in\",\n  \"oe_8x3-label_8x3in\",\n  \"oe_8x4-label_8x4in\",\n  \"oe_8x5-label_8x5in\",\n  \"oe_8x6-label_8x6in\",\n  \"oe_8x6.5-label_8x6.5in\",\n  \"oe_8x13-label_8x13in\",\n\n  \"roll_max_8x39.6in\",\n  \"roll_min_1.25x0.25in\"\n*/\n};\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 85,
    "end_line": 169,
    "code": " const char * const lprint_zpl_4inch_media[] =\n{\t\t\t\t\t// Supported 4 inch media sizes\n  \"oe_1.25x0.25-label_1.25x0.25in\",\n  \"oe_1.25x2.25-label_1.25x2.25in\",\n\n  \"oe_1.5x0.25-label_1.5x0.25in\",\n  \"oe_1.5x0.5-label_1.5x0.5in\",\n  \"oe_1.5x1-label_1.5x1in\",\n  \"oe_1.5x2-label_1.5x2in\",\n\n  \"oe_2x0.37-label_2x0.37in\",\n  \"oe_2x0.5-label_2x0.5in\",\n  \"oe_2x1-label_2x1in\",\n  \"oe_2x1.25-label_2x1.25in\",\n  \"oe_2x2-label_2x2in\",\n  \"oe_2x3-label_2x3in\",\n  \"oe_2x4-label_2x4in\",\n  \"oe_2x5.5-label_2x5.5in\",\n\n  \"oe_2.25x0.5-label_2.25x0.5in\",\n  \"oe_2.25x1.25-label_2.25x1.25in\",\n  \"oe_30859-paint-can-label_2.25x3.125in\",\n  \"oe_2.25x4-label_2.25x4in\",\n  \"oe_2.25x5.5-label_2.25x5.5in\",\n\n  \"oe_2.38x5.5-label_2.38x5.5in\",\n\n  \"oe_2.5x1-label_2.5x1in\",\n  \"oe_2.5x2-label_2.5x2in\",\n\n  \"oe_2.75x1.25-label_2.75x1.25in\",\n\n  \"oe_2.9x1-label_2.9x1in\",\n\n  \"oe_3x1-label_3x1in\",\n  \"oe_3x1.25-label_3x1.25in\",\n  \"oe_3x2-label_3x2in\",\n  \"oe_3x3-label_3x3in\",\n  \"na_index-3x5_3x5in\",\n\n  \"oe_3.25x2-label_3.25x2in\",\n  \"oe_3.25x5-label_3.25x5in\",\n  \"oe_3.25x5.5-label_3.25x5.5in\",\n  \"oe_3.25x5.83-label_3.25x5.83in\",\n  \"oe_3.25x7.83-label_3.25x7.83in\",\n\n  \"oe_3.5x1-label_3.5x1in\",\n\n  \"oe_4x1-label_4x1in\",\n  \"oe_4x2-label_4x2in\",\n  \"oe_4x3-label_4x3in\",\n  \"oe_4x4-label_4x4in\",\n  \"oe_4x5-label_4x5in\",\n  \"na_index-4x6_4x6in\",\n  \"oe_4x6.5-label_4x6.5in\",\n  \"oe_4x7.83-label_4x7.83in\",\n  \"oe_4x8-label_4x8in\",\n  \"oe_4x13-label_4x13in\",\n\n  \"roll_max_4x39.6in\",\n  \"roll_min_0.75x0.25in\"\n\n/*\n  \"oe_6x1-label_6x1in\",\n  \"oe_6x2-label_6x2in\",\n  \"oe_6x3-label_6x3in\",\n  \"oe_6x4-label_6x4in\",\n  \"oe_6x5-label_6x5in\",\n  \"oe_6x6-label_6x6in\",\n  \"oe_6x6.5-label_6x6.5in\",\n  \"oe_6x13-label_6x13in\",\n\n  \"oe_8x1-label_8x1in\",\n  \"oe_8x2-label_8x2in\",\n  \"oe_8x3-label_8x3in\",\n  \"oe_8x4-label_8x4in\",\n  \"oe_8x5-label_8x5in\",\n  \"oe_8x6-label_8x6in\",\n  \"oe_8x6.5-label_8x6.5in\",\n  \"oe_8x13-label_8x13in\",\n\n  \"roll_max_8x39.6in\",\n  \"roll_min_1.25x0.25in\"\n*/\n};\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 85,
    "end_line": 169,
    "code": "t lprint_zpl_4inch_media[] =\n{\t\t\t\t\t// Supported 4 inch media sizes\n  \"oe_1.25x0.25-label_1.25x0.25in\",\n  \"oe_1.25x2.25-label_1.25x2.25in\",\n\n  \"oe_1.5x0.25-label_1.5x0.25in\",\n  \"oe_1.5x0.5-label_1.5x0.5in\",\n  \"oe_1.5x1-label_1.5x1in\",\n  \"oe_1.5x2-label_1.5x2in\",\n\n  \"oe_2x0.37-label_2x0.37in\",\n  \"oe_2x0.5-label_2x0.5in\",\n  \"oe_2x1-label_2x1in\",\n  \"oe_2x1.25-label_2x1.25in\",\n  \"oe_2x2-label_2x2in\",\n  \"oe_2x3-label_2x3in\",\n  \"oe_2x4-label_2x4in\",\n  \"oe_2x5.5-label_2x5.5in\",\n\n  \"oe_2.25x0.5-label_2.25x0.5in\",\n  \"oe_2.25x1.25-label_2.25x1.25in\",\n  \"oe_30859-paint-can-label_2.25x3.125in\",\n  \"oe_2.25x4-label_2.25x4in\",\n  \"oe_2.25x5.5-label_2.25x5.5in\",\n\n  \"oe_2.38x5.5-label_2.38x5.5in\",\n\n  \"oe_2.5x1-label_2.5x1in\",\n  \"oe_2.5x2-label_2.5x2in\",\n\n  \"oe_2.75x1.25-label_2.75x1.25in\",\n\n  \"oe_2.9x1-label_2.9x1in\",\n\n  \"oe_3x1-label_3x1in\",\n  \"oe_3x1.25-label_3x1.25in\",\n  \"oe_3x2-label_3x2in\",\n  \"oe_3x3-label_3x3in\",\n  \"na_index-3x5_3x5in\",\n\n  \"oe_3.25x2-label_3.25x2in\",\n  \"oe_3.25x5-label_3.25x5in\",\n  \"oe_3.25x5.5-label_3.25x5.5in\",\n  \"oe_3.25x5.83-label_3.25x5.83in\",\n  \"oe_3.25x7.83-label_3.25x7.83in\",\n\n  \"oe_3.5x1-label_3.5x1in\",\n\n  \"oe_4x1-label_4x1in\",\n  \"oe_4x2-label_4x2in\",\n  \"oe_4x3-label_4x3in\",\n  \"oe_4x4-label_4x4in\",\n  \"oe_4x5-label_4x5in\",\n  \"na_index-4x6_4x6in\",\n  \"oe_4x6.5-label_4x6.5in\",\n  \"oe_4x7.83-label_4x7.83in\",\n  \"oe_4x8-label_4x8in\",\n  \"oe_4x13-label_4x13in\",\n\n  \"roll_max_4x39.6in\",\n  \"roll_min_0.75x0.25in\"\n\n/*\n  \"oe_6x1-label_6x1in\",\n  \"oe_6x2-label_6x2in\",\n  \"oe_6x3-label_6x3in\",\n  \"oe_6x4-label_6x4in\",\n  \"oe_6x5-label_6x5in\",\n  \"oe_6x6-label_6x6in\",\n  \"oe_6x6.5-label_6x6.5in\",\n  \"oe_6x13-label_6x13in\",\n\n  \"oe_8x1-label_8x1in\",\n  \"oe_8x2-label_8x2in\",\n  \"oe_8x3-label_8x3in\",\n  \"oe_8x4-label_8x4in\",\n  \"oe_8x5-label_8x5in\",\n  \"oe_8x6-label_8x6in\",\n  \"oe_8x6.5-label_8x6.5in\",\n  \"oe_8x13-label_8x13in\",\n\n  \"roll_max_8x39.6in\",\n  \"roll_min_1.25x0.25in\"\n*/\n};\n\n\n//",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "preprocessor",
    "start_line": 176,
    "end_line": 178,
    "code": "L_COMPRESSION\nstatic bool\tlprint_zpl_compress(pappl_device_t *device, unsigned char ch, unsigned count);\n#endif // ZP",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function",
    "start_line": 193,
    "end_line": 285,
    "name": "lprintZPL",
    "parent": null,
    "hierarchy": "lprintZPL",
    "code": "\t\t\t// O - `true` on success, `false` on error\nlprintZPL(\n    pappl_system_t         *system,\t// I - System\n    const char             *driver_name,// I - Driver name\n    const char             *device_uri,\t// I - Device URI\n    const char             *device_id,\t// I - 1284 device ID\n    pappl_pr_driver_data_t *data,\t// I - Pointer to driver data\n    ipp_t                  **attrs,\t// O - Pointer to driver attributes\n    void                   *cbdata)\t// I - Callback data (not used)\n{\n  data->printfile_cb  = lprint_zpl_printfile;\n  data->rendjob_cb    = lprint_zpl_rendjob;\n  data->rendpage_cb   = lprint_zpl_rendpage;\n  data->rstartjob_cb  = lprint_zpl_rstartjob;\n  data->rstartpage_cb = lprint_zpl_rstartpage;\n  data->rwriteline_cb = lprint_zpl_rwriteline;\n  data->status_cb     = lprint_zpl_status;\n  data->format        = LPRINT_ZPL_MIMETYPE;\n\n  data->num_resolution = 1;\n\n  if (strstr(driver_name, \"-203dpi\"))\n  {\n    data->x_resolution[0] = 203;\n    data->y_resolution[0] = 203;\n  }\n  else if (strstr(driver_name, \"-300dpi\"))\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n  else\n  {\n    data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  data->x_default = data->y_default = data->x_resolution[0];\n\n  if (strstr(driver_name, \"-cutter\"))\n    data->finishings |= PAPPL_FINISHINGS_TRIM;\n\n  if (!strncmp(driver_name, \"zpl_2inch-\", 16))\n  {\n    // 2 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_2inch_media) / sizeof(lprint_zpl_2inch_media[0]));\n    memcpy(data->media, lprint_zpl_2inch_media, sizeof(lprint_zpl_2inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"oe_2x3-label_2x3in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n  else\n  {\n    // 4 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_4inch_media) / sizeof(lprint_zpl_4inch_media[0]));\n    memcpy(data->media, lprint_zpl_4inch_media, sizeof(lprint_zpl_4inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  data->media_ready[0].tracking = PAPPL_MEDIA_TRACKING_GAP;\n\n  data->bottom_top = data->left_right = 1;\n\n  data->num_source = 1;\n  data->source[0]  = \"main-roll\";\n\n  data->top_offset_supported[0] = -1500;\n  data->top_offset_supported[1] = 1500;\n  data->tracking_supported      = PAPPL_MEDIA_TRACKING_MARK | PAPPL_MEDIA_TRACKING_WEB | PAPPL_MEDIA_TRACKING_GAP | PAPPL_MEDIA_TRACKING_CONTINUOUS;\n\n  data->num_type = 3;\n  data->type[0]  = \"continuous\";\n  data->type[1]  = \"labels\";\n  data->type[2]  = \"labels-continuous\";\n\n  data->mode_configured = PAPPL_LABEL_MODE_TEAR_OFF;\n  data->mode_supported = PAPPL_LABEL_MODE_APPLICATOR | PAPPL_LABEL_MODE_CUTTER | PAPPL_LABEL_MODE_CUTTER_DELAYED | PAPPL_LABEL_MODE_KIOSK | PAPPL_LABEL_MODE_PEEL_OFF | PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL | PAPPL_LABEL_MODE_REWIND | PAPPL_LABEL_MODE_RFID | PAPPL_LABEL_MODE_TEAR_OFF;\n\n  data->tear_offset_configured   = 0;\n  data->tear_offset_supported[0] = -1500;\n  data->tear_offset_supported[1] = 1500;\n\n  data->speed_default      = 0;\n  data->speed_supported[0] = 2540;\n  data->speed_supported[1] = 12 * 2540;\n\n  data->darkness_configured = 50;\n  data->darkness_supported  = 30;\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 193,
    "end_line": 285,
    "code": "\t\t\t// O - `true` on success, `false` on error\nlprintZPL(\n    pappl_system_t         *system,\t// I - System\n    const char             *driver_name,// I - Driver name\n    const char             *device_uri,\t// I - Device URI\n    const char             *device_id,\t// I - 1284 device ID\n    pappl_pr_driver_data_t *data,\t// I - Pointer to driver data\n    ipp_t                  **attrs,\t// O - Pointer to driver attributes\n    void                   *cbdata)\t// I - Callback data (not used)\n{\n  data->printfile_cb  = lprint_zpl_printfile;\n  data->rendjob_cb    = lprint_zpl_rendjob;\n  data->rendpage_cb   = lprint_zpl_rendpage;\n  data->rstartjob_cb  = lprint_zpl_rstartjob;\n  data->rstartpage_cb = lprint_zpl_rstartpage;\n  data->rwriteline_cb = lprint_zpl_rwriteline;\n  data->status_cb     = lprint_zpl_status;\n  data->format        = LPRINT_ZPL_MIMETYPE;\n\n  data->num_resolution = 1;\n\n  if (strstr(driver_name, \"-203dpi\"))\n  {\n    data->x_resolution[0] = 203;\n    data->y_resolution[0] = 203;\n  }\n  else if (strstr(driver_name, \"-300dpi\"))\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n  else\n  {\n    data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  data->x_default = data->y_default = data->x_resolution[0];\n\n  if (strstr(driver_name, \"-cutter\"))\n    data->finishings |= PAPPL_FINISHINGS_TRIM;\n\n  if (!strncmp(driver_name, \"zpl_2inch-\", 16))\n  {\n    // 2 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_2inch_media) / sizeof(lprint_zpl_2inch_media[0]));\n    memcpy(data->media, lprint_zpl_2inch_media, sizeof(lprint_zpl_2inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"oe_2x3-label_2x3in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n  else\n  {\n    // 4 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_4inch_media) / sizeof(lprint_zpl_4inch_media[0]));\n    memcpy(data->media, lprint_zpl_4inch_media, sizeof(lprint_zpl_4inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  data->media_ready[0].tracking = PAPPL_MEDIA_TRACKING_GAP;\n\n  data->bottom_top = data->left_right = 1;\n\n  data->num_source = 1;\n  data->source[0]  = \"main-roll\";\n\n  data->top_offset_supported[0] = -1500;\n  data->top_offset_supported[1] = 1500;\n  data->tracking_supported      = PAPPL_MEDIA_TRACKING_MARK | PAPPL_MEDIA_TRACKING_WEB | PAPPL_MEDIA_TRACKING_GAP | PAPPL_MEDIA_TRACKING_CONTINUOUS;\n\n  data->num_type = 3;\n  data->type[0]  = \"continuous\";\n  data->type[1]  = \"labels\";\n  data->type[2]  = \"labels-continuous\";\n\n  data->mode_configured = PAPPL_LABEL_MODE_TEAR_OFF;\n  data->mode_supported = PAPPL_LABEL_MODE_APPLICATOR | PAPPL_LABEL_MODE_CUTTER | PAPPL_LABEL_MODE_CUTTER_DELAYED | PAPPL_LABEL_MODE_KIOSK | PAPPL_LABEL_MODE_PEEL_OFF | PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL | PAPPL_LABEL_MODE_REWIND | PAPPL_LABEL_MODE_RFID | PAPPL_LABEL_MODE_TEAR_OFF;\n\n  data->tear_offset_configured   = 0;\n  data->tear_offset_supported[0] = -1500;\n  data->tear_offset_supported[1] = 1500;\n\n  data->speed_default      = 0;\n  data->speed_supported[0] = 2540;\n  data->speed_supported[1] = 12 * 2540;\n\n  data->darkness_configured = 50;\n  data->darkness_supported  = 30;\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 193,
    "end_line": 285,
    "code": "\t\t\t// O - `true` on success, `false` on error\nlprintZPL(\n    pappl_system_t         *system,\t// I - System\n    const char             *driver_name,// I - Driver name\n    const char             *device_uri,\t// I - Device URI\n    const char             *device_id,\t// I - 1284 device ID\n    pappl_pr_driver_data_t *data,\t// I - Pointer to driver data\n    ipp_t                  **attrs,\t// O - Pointer to driver attributes\n    void                   *cbdata)\t// I - Callback data (not used)\n{\n  data->printfile_cb  = lprint_zpl_printfile;\n  data->rendjob_cb    = lprint_zpl_rendjob;\n  data->rendpage_cb   = lprint_zpl_rendpage;\n  data->rstartjob_cb  = lprint_zpl_rstartjob;\n  data->rstartpage_cb = lprint_zpl_rstartpage;\n  data->rwriteline_cb = lprint_zpl_rwriteline;\n  data->status_cb     = lprint_zpl_status;\n  data->format        = LPRINT_ZPL_MIMETYPE;\n\n  data->num_resolution = 1;\n\n  if (strstr(driver_name, \"-203dpi\"))\n  {\n    data->x_resolution[0] = 203;\n    data->y_resolution[0] = 203;\n  }\n  else if (strstr(driver_name, \"-300dpi\"))\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n  else\n  {\n    data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  data->x_default = data->y_default = data->x_resolution[0];\n\n  if (strstr(driver_name, \"-cutter\"))\n    data->finishings |= PAPPL_FINISHINGS_TRIM;\n\n  if (!strncmp(driver_name, \"zpl_2inch-\", 16))\n  {\n    // 2 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_2inch_media) / sizeof(lprint_zpl_2inch_media[0]));\n    memcpy(data->media, lprint_zpl_2inch_media, sizeof(lprint_zpl_2inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"oe_2x3-label_2x3in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n  else\n  {\n    // 4 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_4inch_media) / sizeof(lprint_zpl_4inch_media[0]));\n    memcpy(data->media, lprint_zpl_4inch_media, sizeof(lprint_zpl_4inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  data->media_ready[0].tracking = PAPPL_MEDIA_TRACKING_GAP;\n\n  data->bottom_top = data->left_right = 1;\n\n  data->num_source = 1;\n  data->source[0]  = \"main-roll\";\n\n  data->top_offset_supported[0] = -1500;\n  data->top_offset_supported[1] = 1500;\n  data->tracking_supported      = PAPPL_MEDIA_TRACKING_MARK | PAPPL_MEDIA_TRACKING_WEB | PAPPL_MEDIA_TRACKING_GAP | PAPPL_MEDIA_TRACKING_CONTINUOUS;\n\n  data->num_type = 3;\n  data->type[0]  = \"continuous\";\n  data->type[1]  = \"labels\";\n  data->type[2]  = \"labels-continuous\";\n\n  data->mode_configured = PAPPL_LABEL_MODE_TEAR_OFF;\n  data->mode_supported = PAPPL_LABEL_MODE_APPLICATOR | PAPPL_LABEL_MODE_CUTTER | PAPPL_LABEL_MODE_CUTTER_DELAYED | PAPPL_LABEL_MODE_KIOSK | PAPPL_LABEL_MODE_PEEL_OFF | PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL | PAPPL_LABEL_MODE_REWIND | PAPPL_LABEL_MODE_RFID | PAPPL_LABEL_MODE_TEAR_OFF;\n\n  data->tear_offset_configured   = 0;\n  data->tear_offset_supported[0] = -1500;\n  data->tear_offset_supported[1] = 1500;\n\n  data->speed_default      = 0;\n  data->speed_supported[0] = 2540;\n  data->speed_supported[1] = 12 * 2540;\n\n  data->darkness_configured = 50;\n  data->darkness_supported  = 30;\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 202,
    "end_line": 285,
    "code": "ta->printfile_cb  = lprint_zpl_printfile;\n  data->rendjob_cb    = lprint_zpl_rendjob;\n  data->rendpage_cb   = lprint_zpl_rendpage;\n  data->rstartjob_cb  = lprint_zpl_rstartjob;\n  data->rstartpage_cb = lprint_zpl_rstartpage;\n  data->rwriteline_cb = lprint_zpl_rwriteline;\n  data->status_cb     = lprint_zpl_status;\n  data->format        = LPRINT_ZPL_MIMETYPE;\n\n  data->num_resolution = 1;\n\n  if (strstr(driver_name, \"-203dpi\"))\n  {\n    data->x_resolution[0] = 203;\n    data->y_resolution[0] = 203;\n  }\n  else if (strstr(driver_name, \"-300dpi\"))\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n  else\n  {\n    data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  data->x_default = data->y_default = data->x_resolution[0];\n\n  if (strstr(driver_name, \"-cutter\"))\n    data->finishings |= PAPPL_FINISHINGS_TRIM;\n\n  if (!strncmp(driver_name, \"zpl_2inch-\", 16))\n  {\n    // 2 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_2inch_media) / sizeof(lprint_zpl_2inch_media[0]));\n    memcpy(data->media, lprint_zpl_2inch_media, sizeof(lprint_zpl_2inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"oe_2x3-label_2x3in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n  else\n  {\n    // 4 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_4inch_media) / sizeof(lprint_zpl_4inch_media[0]));\n    memcpy(data->media, lprint_zpl_4inch_media, sizeof(lprint_zpl_4inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  data->media_ready[0].tracking = PAPPL_MEDIA_TRACKING_GAP;\n\n  data->bottom_top = data->left_right = 1;\n\n  data->num_source = 1;\n  data->source[0]  = \"main-roll\";\n\n  data->top_offset_supported[0] = -1500;\n  data->top_offset_supported[1] = 1500;\n  data->tracking_supported      = PAPPL_MEDIA_TRACKING_MARK | PAPPL_MEDIA_TRACKING_WEB | PAPPL_MEDIA_TRACKING_GAP | PAPPL_MEDIA_TRACKING_CONTINUOUS;\n\n  data->num_type = 3;\n  data->type[0]  = \"continuous\";\n  data->type[1]  = \"labels\";\n  data->type[2]  = \"labels-continuous\";\n\n  data->mode_configured = PAPPL_LABEL_MODE_TEAR_OFF;\n  data->mode_supported = PAPPL_LABEL_MODE_APPLICATOR | PAPPL_LABEL_MODE_CUTTER | PAPPL_LABEL_MODE_CUTTER_DELAYED | PAPPL_LABEL_MODE_KIOSK | PAPPL_LABEL_MODE_PEEL_OFF | PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL | PAPPL_LABEL_MODE_REWIND | PAPPL_LABEL_MODE_RFID | PAPPL_LABEL_MODE_TEAR_OFF;\n\n  data->tear_offset_configured   = 0;\n  data->tear_offset_supported[0] = -1500;\n  data->tear_offset_supported[1] = 1500;\n\n  data->speed_default      = 0;\n  data->speed_supported[0] = 2540;\n  data->speed_supported[1] = 12 * 2540;\n\n  data->darkness_configured = 50;\n  data->darkness_supported  = 30;\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 202,
    "end_line": 285,
    "code": "ta->printfile_cb  = lprint_zpl_printfile;\n  data->rendjob_cb    = lprint_zpl_rendjob;\n  data->rendpage_cb   = lprint_zpl_rendpage;\n  data->rstartjob_cb  = lprint_zpl_rstartjob;\n  data->rstartpage_cb = lprint_zpl_rstartpage;\n  data->rwriteline_cb = lprint_zpl_rwriteline;\n  data->status_cb     = lprint_zpl_status;\n  data->format        = LPRINT_ZPL_MIMETYPE;\n\n  data->num_resolution = 1;\n\n  if (strstr(driver_name, \"-203dpi\"))\n  {\n    data->x_resolution[0] = 203;\n    data->y_resolution[0] = 203;\n  }\n  else if (strstr(driver_name, \"-300dpi\"))\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n  else\n  {\n    data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  data->x_default = data->y_default = data->x_resolution[0];\n\n  if (strstr(driver_name, \"-cutter\"))\n    data->finishings |= PAPPL_FINISHINGS_TRIM;\n\n  if (!strncmp(driver_name, \"zpl_2inch-\", 16))\n  {\n    // 2 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_2inch_media) / sizeof(lprint_zpl_2inch_media[0]));\n    memcpy(data->media, lprint_zpl_2inch_media, sizeof(lprint_zpl_2inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"oe_2x3-label_2x3in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n  else\n  {\n    // 4 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_4inch_media) / sizeof(lprint_zpl_4inch_media[0]));\n    memcpy(data->media, lprint_zpl_4inch_media, sizeof(lprint_zpl_4inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  data->media_ready[0].tracking = PAPPL_MEDIA_TRACKING_GAP;\n\n  data->bottom_top = data->left_right = 1;\n\n  data->num_source = 1;\n  data->source[0]  = \"main-roll\";\n\n  data->top_offset_supported[0] = -1500;\n  data->top_offset_supported[1] = 1500;\n  data->tracking_supported      = PAPPL_MEDIA_TRACKING_MARK | PAPPL_MEDIA_TRACKING_WEB | PAPPL_MEDIA_TRACKING_GAP | PAPPL_MEDIA_TRACKING_CONTINUOUS;\n\n  data->num_type = 3;\n  data->type[0]  = \"continuous\";\n  data->type[1]  = \"labels\";\n  data->type[2]  = \"labels-continuous\";\n\n  data->mode_configured = PAPPL_LABEL_MODE_TEAR_OFF;\n  data->mode_supported = PAPPL_LABEL_MODE_APPLICATOR | PAPPL_LABEL_MODE_CUTTER | PAPPL_LABEL_MODE_CUTTER_DELAYED | PAPPL_LABEL_MODE_KIOSK | PAPPL_LABEL_MODE_PEEL_OFF | PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL | PAPPL_LABEL_MODE_REWIND | PAPPL_LABEL_MODE_RFID | PAPPL_LABEL_MODE_TEAR_OFF;\n\n  data->tear_offset_configured   = 0;\n  data->tear_offset_supported[0] = -1500;\n  data->tear_offset_supported[1] = 1500;\n\n  data->speed_default      = 0;\n  data->speed_supported[0] = 2540;\n  data->speed_supported[1] = 12 * 2540;\n\n  data->darkness_configured = 50;\n  data->darkness_supported  = 30;\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 214,
    "end_line": 228,
    "code": "rstr(driver_name, \"-203dpi\"))\n  {\n    data->x_resolution[0] = 203;\n    data->y_resolution[0] = 203;\n  }\n  else if (strstr(driver_name, \"-300dpi\"))\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n  else\n  {\n    data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  da",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 214,
    "end_line": 228,
    "code": "rstr(driver_name, \"-203dpi\"))\n  {\n    data->x_resolution[0] = 203;\n    data->y_resolution[0] = 203;\n  }\n  else if (strstr(driver_name, \"-300dpi\"))\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n  else\n  {\n    data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  da",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 215,
    "end_line": 218,
    "code": "data->x_resolution[0] = 203;\n    data->y_resolution[0] = 203;\n  }\n  els",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 219,
    "end_line": 228,
    "code": "f (strstr(driver_name, \"-300dpi\"))\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n  else\n  {\n    data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  da",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 219,
    "end_line": 228,
    "code": "f (strstr(driver_name, \"-300dpi\"))\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n  else\n  {\n    data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  da",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 219,
    "end_line": 228,
    "code": "rstr(driver_name, \"-300dpi\"))\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n  else\n  {\n    data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  da",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 219,
    "end_line": 228,
    "code": "rstr(driver_name, \"-300dpi\"))\n  {\n    data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n  else\n  {\n    data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  da",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 220,
    "end_line": 223,
    "code": "data->x_resolution[0] = 300;\n    data->y_resolution[0] = 300;\n  }\n  els",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 224,
    "end_line": 228,
    "code": " {\n    data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  da",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 225,
    "end_line": 228,
    "code": "data->x_resolution[0] = 600;\n    data->y_resolution[0] = 600;\n  }\n\n  da",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 230,
    "end_line": 230,
    "code": "x_default = data->y_default = data->x_resolution[0];\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 230,
    "end_line": 230,
    "code": "x_default = data->y_default = data->x_resolution[0];\n\n  i",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 230,
    "end_line": 230,
    "code": "y_default = data->x_resolution[0];\n\n  i",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 232,
    "end_line": 233,
    "code": "rstr(driver_name, \"-cutter\"))\n    data->finishings |= PAPPL_FINISHINGS_TRIM;\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 232,
    "end_line": 233,
    "code": "rstr(driver_name, \"-cutter\"))\n    data->finishings |= PAPPL_FINISHINGS_TRIM;\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 235,
    "end_line": 252,
    "code": "trncmp(driver_name, \"zpl_2inch-\", 16))\n  {\n    // 2 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_2inch_media) / sizeof(lprint_zpl_2inch_media[0]));\n    memcpy(data->media, lprint_zpl_2inch_media, sizeof(lprint_zpl_2inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"oe_2x3-label_2x3in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n  else\n  {\n    // 4 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_4inch_media) / sizeof(lprint_zpl_4inch_media[0]));\n    memcpy(data->media, lprint_zpl_4inch_media, sizeof(lprint_zpl_4inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  da",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 235,
    "end_line": 252,
    "code": "trncmp(driver_name, \"zpl_2inch-\", 16))\n  {\n    // 2 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_2inch_media) / sizeof(lprint_zpl_2inch_media[0]));\n    memcpy(data->media, lprint_zpl_2inch_media, sizeof(lprint_zpl_2inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"oe_2x3-label_2x3in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n  else\n  {\n    // 4 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_4inch_media) / sizeof(lprint_zpl_4inch_media[0]));\n    memcpy(data->media, lprint_zpl_4inch_media, sizeof(lprint_zpl_4inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  da",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 236,
    "end_line": 243,
    "code": "// 2 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_2inch_media) / sizeof(lprint_zpl_2inch_media[0]));\n    memcpy(data->media, lprint_zpl_2inch_media, sizeof(lprint_zpl_2inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"oe_2x3-label_2x3in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n  els",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 236,
    "end_line": 243,
    "code": "// 2 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_2inch_media) / sizeof(lprint_zpl_2inch_media[0]));\n    memcpy(data->media, lprint_zpl_2inch_media, sizeof(lprint_zpl_2inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"oe_2x3-label_2x3in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n  els",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 244,
    "end_line": 252,
    "code": " {\n    // 4 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_4inch_media) / sizeof(lprint_zpl_4inch_media[0]));\n    memcpy(data->media, lprint_zpl_4inch_media, sizeof(lprint_zpl_4inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  da",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 244,
    "end_line": 252,
    "code": " {\n    // 4 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_4inch_media) / sizeof(lprint_zpl_4inch_media[0]));\n    memcpy(data->media, lprint_zpl_4inch_media, sizeof(lprint_zpl_4inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  da",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 245,
    "end_line": 252,
    "code": "// 4 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_4inch_media) / sizeof(lprint_zpl_4inch_media[0]));\n    memcpy(data->media, lprint_zpl_4inch_media, sizeof(lprint_zpl_4inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  da",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 245,
    "end_line": 252,
    "code": "// 4 inch printer...\n    data->num_media = (int)(sizeof(lprint_zpl_4inch_media) / sizeof(lprint_zpl_4inch_media[0]));\n    memcpy(data->media, lprint_zpl_4inch_media, sizeof(lprint_zpl_4inch_media));\n\n    papplCopyString(data->media_ready[0].size_name, \"na_index-4x6_4x6in\", sizeof(data->media_ready[0].size_name));\n    papplCopyString(data->media_ready[0].type, \"labels\", sizeof(data->media_ready[0].type));\n  }\n\n  da",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 254,
    "end_line": 254,
    "code": "media_ready[0].tracking = PAPPL_MEDIA_TRACKING_GAP;\n\n  da",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 254,
    "end_line": 254,
    "code": "media_ready[0].tracking = PAPPL_MEDIA_TRACKING_GAP;\n\n  d",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 256,
    "end_line": 256,
    "code": "bottom_top = data->left_right = 1;\n\n  da",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 256,
    "end_line": 256,
    "code": "bottom_top = data->left_right = 1;\n\n  d",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function",
    "start_line": 292,
    "end_line": 357,
    "name": "lprintZPLQueryDriver",
    "parent": null,
    "hierarchy": "lprintZPLQueryDriver",
    "code": "printZPLQueryDriver(\n    pappl_system_t *system,\t\t// I - System\n    const char     *device_uri,\t\t// I - Device URI\n    char           *name,\t\t// I - Name buffer\n    size_t         namesize)\t\t// I - Size of name buffer\n{\n  pappl_device_t\t*device;\t// Device connection\n  char\t\t\tline[1025];\t// Line from device\n  ssize_t\t\tbytes;\t\t// Bytes read\n  char\t\t\tmodel[256],\t// Model name\n\t\t\t*modelptr;\t// Pointer into model name\n  int\t\t\tdpmm = 0;\t// Dots per millimeter\n\n\n  // Make sure name buffer is initialized...\n  *name = '\\0';\n\n  // Connect and send Host Information command...\n  if ((device = papplDeviceOpen(device_uri, \"query\", papplLogDevice, system)) == NULL)\n    return;\n\n  if (papplDevicePuts(device, \"~HI\\n\") < 0)\n    goto done;\n\n  // Read and parse response:\n  //\n  // <stx>MODEL,VERSION,DPMM,MEMORY,OPTIONS<etx><cr><lf>\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) <= 0)\n    goto done;\n\n  line[bytes] = '\\0';\n\n  papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"HI response for '%s' was '%s'.\", device_uri, line);\n\n  if (line[0] == 0x02 && sscanf(line + 1, \"%255[^,],%*[^,],%d\", model, &dpmm) > 1 && (dpmm == 8 || dpmm == 12 || dpmm == 24))\n  {\n    // Got model and dots-per-millimeter values, create a driver name from it...\n    // Note: We currently assume a 4\" print head for auto-detection...\n    const char\t*type = \"tt\";\t\t// Type of printing (direct/transfer)\n    int\t\tdpi;\t\t\t// Print resolution\n\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"model='%s', dpmm=%d\", model, dpmm);\n\n    if ((modelptr = strchr(model, '-')) != NULL && modelptr > model)\n    {\n      if (modelptr[-1] == 'd')\n        type = \"dt\";\n    }\n\n    if (dpmm == 8)\n      dpi = 203;\t\t\t// 203.2\n    else if (dpmm == 12)\n      dpi = 300;\t\t\t// Technically should be 304.8...\n    else\n      dpi = 600;\t\t\t// Technically should be 609.6...\n\n    snprintf(name, namesize, \"zpl_4inch-%ddpi-%s\", dpi, type);\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"auto driver-name='%s'\", name);\n  }\n\n  done:\n\n  papplDeviceClose(device);\n  return;\n}\n\n\n#if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 292,
    "end_line": 357,
    "code": "printZPLQueryDriver(\n    pappl_system_t *system,\t\t// I - System\n    const char     *device_uri,\t\t// I - Device URI\n    char           *name,\t\t// I - Name buffer\n    size_t         namesize)\t\t// I - Size of name buffer\n{\n  pappl_device_t\t*device;\t// Device connection\n  char\t\t\tline[1025];\t// Line from device\n  ssize_t\t\tbytes;\t\t// Bytes read\n  char\t\t\tmodel[256],\t// Model name\n\t\t\t*modelptr;\t// Pointer into model name\n  int\t\t\tdpmm = 0;\t// Dots per millimeter\n\n\n  // Make sure name buffer is initialized...\n  *name = '\\0';\n\n  // Connect and send Host Information command...\n  if ((device = papplDeviceOpen(device_uri, \"query\", papplLogDevice, system)) == NULL)\n    return;\n\n  if (papplDevicePuts(device, \"~HI\\n\") < 0)\n    goto done;\n\n  // Read and parse response:\n  //\n  // <stx>MODEL,VERSION,DPMM,MEMORY,OPTIONS<etx><cr><lf>\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) <= 0)\n    goto done;\n\n  line[bytes] = '\\0';\n\n  papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"HI response for '%s' was '%s'.\", device_uri, line);\n\n  if (line[0] == 0x02 && sscanf(line + 1, \"%255[^,],%*[^,],%d\", model, &dpmm) > 1 && (dpmm == 8 || dpmm == 12 || dpmm == 24))\n  {\n    // Got model and dots-per-millimeter values, create a driver name from it...\n    // Note: We currently assume a 4\" print head for auto-detection...\n    const char\t*type = \"tt\";\t\t// Type of printing (direct/transfer)\n    int\t\tdpi;\t\t\t// Print resolution\n\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"model='%s', dpmm=%d\", model, dpmm);\n\n    if ((modelptr = strchr(model, '-')) != NULL && modelptr > model)\n    {\n      if (modelptr[-1] == 'd')\n        type = \"dt\";\n    }\n\n    if (dpmm == 8)\n      dpi = 203;\t\t\t// 203.2\n    else if (dpmm == 12)\n      dpi = 300;\t\t\t// Technically should be 304.8...\n    else\n      dpi = 600;\t\t\t// Technically should be 609.6...\n\n    snprintf(name, namesize, \"zpl_4inch-%ddpi-%s\", dpi, type);\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"auto driver-name='%s'\", name);\n  }\n\n  done:\n\n  papplDeviceClose(device);\n  return;\n}\n\n\n#if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 298,
    "end_line": 357,
    "code": "ppl_device_t\t*device;\t// Device connection\n  char\t\t\tline[1025];\t// Line from device\n  ssize_t\t\tbytes;\t\t// Bytes read\n  char\t\t\tmodel[256],\t// Model name\n\t\t\t*modelptr;\t// Pointer into model name\n  int\t\t\tdpmm = 0;\t// Dots per millimeter\n\n\n  // Make sure name buffer is initialized...\n  *name = '\\0';\n\n  // Connect and send Host Information command...\n  if ((device = papplDeviceOpen(device_uri, \"query\", papplLogDevice, system)) == NULL)\n    return;\n\n  if (papplDevicePuts(device, \"~HI\\n\") < 0)\n    goto done;\n\n  // Read and parse response:\n  //\n  // <stx>MODEL,VERSION,DPMM,MEMORY,OPTIONS<etx><cr><lf>\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) <= 0)\n    goto done;\n\n  line[bytes] = '\\0';\n\n  papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"HI response for '%s' was '%s'.\", device_uri, line);\n\n  if (line[0] == 0x02 && sscanf(line + 1, \"%255[^,],%*[^,],%d\", model, &dpmm) > 1 && (dpmm == 8 || dpmm == 12 || dpmm == 24))\n  {\n    // Got model and dots-per-millimeter values, create a driver name from it...\n    // Note: We currently assume a 4\" print head for auto-detection...\n    const char\t*type = \"tt\";\t\t// Type of printing (direct/transfer)\n    int\t\tdpi;\t\t\t// Print resolution\n\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"model='%s', dpmm=%d\", model, dpmm);\n\n    if ((modelptr = strchr(model, '-')) != NULL && modelptr > model)\n    {\n      if (modelptr[-1] == 'd')\n        type = \"dt\";\n    }\n\n    if (dpmm == 8)\n      dpi = 203;\t\t\t// 203.2\n    else if (dpmm == 12)\n      dpi = 300;\t\t\t// Technically should be 304.8...\n    else\n      dpi = 600;\t\t\t// Technically should be 609.6...\n\n    snprintf(name, namesize, \"zpl_4inch-%ddpi-%s\", dpi, type);\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"auto driver-name='%s'\", name);\n  }\n\n  done:\n\n  papplDeviceClose(device);\n  return;\n}\n\n\n#if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "global_variable",
    "start_line": 304,
    "end_line": 304,
    "code": "dpmm = 0;\t// Do",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 327,
    "end_line": 351,
    "code": "ne[0] == 0x02 && sscanf(line + 1, \"%255[^,],%*[^,],%d\", model, &dpmm) > 1 && (dpmm == 8 || dpmm == 12 || dpmm == 24))\n  {\n    // Got model and dots-per-millimeter values, create a driver name from it...\n    // Note: We currently assume a 4\" print head for auto-detection...\n    const char\t*type = \"tt\";\t\t// Type of printing (direct/transfer)\n    int\t\tdpi;\t\t\t// Print resolution\n\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"model='%s', dpmm=%d\", model, dpmm);\n\n    if ((modelptr = strchr(model, '-')) != NULL && modelptr > model)\n    {\n      if (modelptr[-1] == 'd')\n        type = \"dt\";\n    }\n\n    if (dpmm == 8)\n      dpi = 203;\t\t\t// 203.2\n    else if (dpmm == 12)\n      dpi = 300;\t\t\t// Technically should be 304.8...\n    else\n      dpi = 600;\t\t\t// Technically should be 609.6...\n\n    snprintf(name, namesize, \"zpl_4inch-%ddpi-%s\", dpi, type);\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"auto driver-name='%s'\", name);\n  }\n\n  do",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 328,
    "end_line": 351,
    "code": "// Got model and dots-per-millimeter values, create a driver name from it...\n    // Note: We currently assume a 4\" print head for auto-detection...\n    const char\t*type = \"tt\";\t\t// Type of printing (direct/transfer)\n    int\t\tdpi;\t\t\t// Print resolution\n\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"model='%s', dpmm=%d\", model, dpmm);\n\n    if ((modelptr = strchr(model, '-')) != NULL && modelptr > model)\n    {\n      if (modelptr[-1] == 'd')\n        type = \"dt\";\n    }\n\n    if (dpmm == 8)\n      dpi = 203;\t\t\t// 203.2\n    else if (dpmm == 12)\n      dpi = 300;\t\t\t// Technically should be 304.8...\n    else\n      dpi = 600;\t\t\t// Technically should be 609.6...\n\n    snprintf(name, namesize, \"zpl_4inch-%ddpi-%s\", dpi, type);\n    papplLog(system, PAPPL_LOGLEVEL_DEBUG, \"auto driver-name='%s'\", name);\n  }\n\n  do",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "global_variable",
    "start_line": 331,
    "end_line": 331,
    "code": "char\t*type = \"tt\";\t\t// T",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 342,
    "end_line": 347,
    "code": "mm == 8)\n      dpi = 203;\t\t\t// 203.2\n    else if (dpmm == 12)\n      dpi = 300;\t\t\t// Technically should be 304.8...\n    else\n      dpi = 600;\t\t\t// ",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 344,
    "end_line": 347,
    "code": "f (dpmm == 12)\n      dpi = 300;\t\t\t// Technically should be 304.8...\n    else\n      dpi = 600;\t\t\t// ",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 344,
    "end_line": 347,
    "code": "mm == 12)\n      dpi = 300;\t\t\t// Technically should be 304.8...\n    else\n      dpi = 600;\t\t\t// ",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "preprocessor",
    "start_line": 360,
    "end_line": 410,
    "code": "L_COMPRESSION\n//\n// 'lprint_zpl_compress()' - Output a RLE run...\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_compress(\n    pappl_device_t *device,\t\t// I - Output device\n    unsigned char  ch,\t\t\t// I - Repeat character\n    unsigned       count)\t\t// I - Repeat count\n{\n  unsigned char\tbuffer[8192],\t\t// Output buffer\n\t\t*bufptr = buffer;\t// Pointer into buffer\n\n\n  if (count > 1)\n  {\n    // Print as many z's as possible - they are the largest denomination\n    // representing 400 characters (zC stands for 400 adjacent C's)\n    while (count >= 400)\n    {\n      count -= 400;\n      *bufptr++ = 'z';\n\n      if (bufptr >= (buffer + sizeof(buffer)))\n      {\n        if (papplDeviceWrite(device, buffer, sizeof(buffer)) < 0)\n          return (0);\n\n\tbufptr = buffer;\n      }\n    }\n\n    // Then print 'g' through 'y' as multiples of 20 characters...\n    if (count >= 20)\n    {\n      *bufptr++ = 'f' + count / 20;\n      count %= 20;\n    }\n\n    // Finally, print 'G' through 'Y' as 1 through 19 characters...\n    if (count > 0)\n      *bufptr++ = 'F' + count;\n  }\n\n  // Then the character to be repeated...\n  *bufptr++ = ch;\n\n  return (papplDeviceWrite(device, buffer, bufptr - buffer) > 0);\n}\n#endif // ZP",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 360,
    "end_line": 410,
    "code": "L_COMPRESSION\n//\n// 'lprint_zpl_compress()' - Output a RLE run...\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_compress(\n    pappl_device_t *device,\t\t// I - Output device\n    unsigned char  ch,\t\t\t// I - Repeat character\n    unsigned       count)\t\t// I - Repeat count\n{\n  unsigned char\tbuffer[8192],\t\t// Output buffer\n\t\t*bufptr = buffer;\t// Pointer into buffer\n\n\n  if (count > 1)\n  {\n    // Print as many z's as possible - they are the largest denomination\n    // representing 400 characters (zC stands for 400 adjacent C's)\n    while (count >= 400)\n    {\n      count -= 400;\n      *bufptr++ = 'z';\n\n      if (bufptr >= (buffer + sizeof(buffer)))\n      {\n        if (papplDeviceWrite(device, buffer, sizeof(buffer)) < 0)\n          return (0);\n\n\tbufptr = buffer;\n      }\n    }\n\n    // Then print 'g' through 'y' as multiples of 20 characters...\n    if (count >= 20)\n    {\n      *bufptr++ = 'f' + count / 20;\n      count %= 20;\n    }\n\n    // Finally, print 'G' through 'Y' as 1 through 19 characters...\n    if (count > 0)\n      *bufptr++ = 'F' + count;\n  }\n\n  // Then the character to be repeated...\n  *bufptr++ = ch;\n\n  return (papplDeviceWrite(device, buffer, bufptr - buffer) > 0);\n}\n#endif // ZP",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function",
    "start_line": 365,
    "end_line": 409,
    "name": "lprint_zpl_compress",
    "parent": null,
    "hierarchy": "lprint_zpl_compress",
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_compress(\n    pappl_device_t *device,\t\t// I - Output device\n    unsigned char  ch,\t\t\t// I - Repeat character\n    unsigned       count)\t\t// I - Repeat count\n{\n  unsigned char\tbuffer[8192],\t\t// Output buffer\n\t\t*bufptr = buffer;\t// Pointer into buffer\n\n\n  if (count > 1)\n  {\n    // Print as many z's as possible - they are the largest denomination\n    // representing 400 characters (zC stands for 400 adjacent C's)\n    while (count >= 400)\n    {\n      count -= 400;\n      *bufptr++ = 'z';\n\n      if (bufptr >= (buffer + sizeof(buffer)))\n      {\n        if (papplDeviceWrite(device, buffer, sizeof(buffer)) < 0)\n          return (0);\n\n\tbufptr = buffer;\n      }\n    }\n\n    // Then print 'g' through 'y' as multiples of 20 characters...\n    if (count >= 20)\n    {\n      *bufptr++ = 'f' + count / 20;\n      count %= 20;\n    }\n\n    // Finally, print 'G' through 'Y' as 1 through 19 characters...\n    if (count > 0)\n      *bufptr++ = 'F' + count;\n  }\n\n  // Then the character to be repeated...\n  *bufptr++ = ch;\n\n  return (papplDeviceWrite(device, buffer, bufptr - buffer) > 0);\n}\n#endi",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 365,
    "end_line": 409,
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_compress(\n    pappl_device_t *device,\t\t// I - Output device\n    unsigned char  ch,\t\t\t// I - Repeat character\n    unsigned       count)\t\t// I - Repeat count\n{\n  unsigned char\tbuffer[8192],\t\t// Output buffer\n\t\t*bufptr = buffer;\t// Pointer into buffer\n\n\n  if (count > 1)\n  {\n    // Print as many z's as possible - they are the largest denomination\n    // representing 400 characters (zC stands for 400 adjacent C's)\n    while (count >= 400)\n    {\n      count -= 400;\n      *bufptr++ = 'z';\n\n      if (bufptr >= (buffer + sizeof(buffer)))\n      {\n        if (papplDeviceWrite(device, buffer, sizeof(buffer)) < 0)\n          return (0);\n\n\tbufptr = buffer;\n      }\n    }\n\n    // Then print 'g' through 'y' as multiples of 20 characters...\n    if (count >= 20)\n    {\n      *bufptr++ = 'f' + count / 20;\n      count %= 20;\n    }\n\n    // Finally, print 'G' through 'Y' as 1 through 19 characters...\n    if (count > 0)\n      *bufptr++ = 'F' + count;\n  }\n\n  // Then the character to be repeated...\n  *bufptr++ = ch;\n\n  return (papplDeviceWrite(device, buffer, bufptr - buffer) > 0);\n}\n#endi",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 370,
    "end_line": 409,
    "code": "signed char\tbuffer[8192],\t\t// Output buffer\n\t\t*bufptr = buffer;\t// Pointer into buffer\n\n\n  if (count > 1)\n  {\n    // Print as many z's as possible - they are the largest denomination\n    // representing 400 characters (zC stands for 400 adjacent C's)\n    while (count >= 400)\n    {\n      count -= 400;\n      *bufptr++ = 'z';\n\n      if (bufptr >= (buffer + sizeof(buffer)))\n      {\n        if (papplDeviceWrite(device, buffer, sizeof(buffer)) < 0)\n          return (0);\n\n\tbufptr = buffer;\n      }\n    }\n\n    // Then print 'g' through 'y' as multiples of 20 characters...\n    if (count >= 20)\n    {\n      *bufptr++ = 'f' + count / 20;\n      count %= 20;\n    }\n\n    // Finally, print 'G' through 'Y' as 1 through 19 characters...\n    if (count > 0)\n      *bufptr++ = 'F' + count;\n  }\n\n  // Then the character to be repeated...\n  *bufptr++ = ch;\n\n  return (papplDeviceWrite(device, buffer, bufptr - buffer) > 0);\n}\n#endi",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "global_variable",
    "start_line": 371,
    "end_line": 372,
    "code": "ed char\tbuffer[8192],\t\t// Output buffer\n\t\t*bufptr = buffer;\t// Po",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 375,
    "end_line": 403,
    "code": "unt > 1)\n  {\n    // Print as many z's as possible - they are the largest denomination\n    // representing 400 characters (zC stands for 400 adjacent C's)\n    while (count >= 400)\n    {\n      count -= 400;\n      *bufptr++ = 'z';\n\n      if (bufptr >= (buffer + sizeof(buffer)))\n      {\n        if (papplDeviceWrite(device, buffer, sizeof(buffer)) < 0)\n          return (0);\n\n\tbufptr = buffer;\n      }\n    }\n\n    // Then print 'g' through 'y' as multiples of 20 characters...\n    if (count >= 20)\n    {\n      *bufptr++ = 'f' + count / 20;\n      count %= 20;\n    }\n\n    // Finally, print 'G' through 'Y' as 1 through 19 characters...\n    if (count > 0)\n      *bufptr++ = 'F' + count;\n  }\n\n  //",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 376,
    "end_line": 403,
    "code": "// Print as many z's as possible - they are the largest denomination\n    // representing 400 characters (zC stands for 400 adjacent C's)\n    while (count >= 400)\n    {\n      count -= 400;\n      *bufptr++ = 'z';\n\n      if (bufptr >= (buffer + sizeof(buffer)))\n      {\n        if (papplDeviceWrite(device, buffer, sizeof(buffer)) < 0)\n          return (0);\n\n\tbufptr = buffer;\n      }\n    }\n\n    // Then print 'g' through 'y' as multiples of 20 characters...\n    if (count >= 20)\n    {\n      *bufptr++ = 'f' + count / 20;\n      count %= 20;\n    }\n\n    // Finally, print 'G' through 'Y' as 1 through 19 characters...\n    if (count > 0)\n      *bufptr++ = 'F' + count;\n  }\n\n  //",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function",
    "start_line": 417,
    "end_line": 458,
    "name": "lprint_zpl_printfile",
    "parent": null,
    "hierarchy": "lprint_zpl_printfile",
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_printfile(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device)\t\t// I - Output device\n{\n  int\t\tfd;\t\t\t// Input file\n  ssize_t\tbytes;\t\t\t// Bytes read/written\n  char\t\tbuffer[65536];\t\t// Read/write buffer\n\n\n  // Copy the raw file...\n  papplJobSetImpressions(job, 1);\n\n  if ((fd  = open(papplJobGetFilename(job), O_RDONLY)) < 0)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to open print file '%s': %s\", papplJobGetFilename(job), strerror(errno));\n    return (false);\n  }\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Copy print data...\n  while ((bytes = read(fd, buffer, sizeof(buffer))) > 0)\n  {\n    if (papplDeviceWrite(device, buffer, (size_t)bytes) < 0)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to send %d bytes to printer.\", (int)bytes);\n      close(fd);\n      return (false);\n    }\n  }\n  close(fd);\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 417,
    "end_line": 458,
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_printfile(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device)\t\t// I - Output device\n{\n  int\t\tfd;\t\t\t// Input file\n  ssize_t\tbytes;\t\t\t// Bytes read/written\n  char\t\tbuffer[65536];\t\t// Read/write buffer\n\n\n  // Copy the raw file...\n  papplJobSetImpressions(job, 1);\n\n  if ((fd  = open(papplJobGetFilename(job), O_RDONLY)) < 0)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to open print file '%s': %s\", papplJobGetFilename(job), strerror(errno));\n    return (false);\n  }\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Copy print data...\n  while ((bytes = read(fd, buffer, sizeof(buffer))) > 0)\n  {\n    if (papplDeviceWrite(device, buffer, (size_t)bytes) < 0)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to send %d bytes to printer.\", (int)bytes);\n      close(fd);\n      return (false);\n    }\n  }\n  close(fd);\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 422,
    "end_line": 458,
    "code": "t\t\tfd;\t\t\t// Input file\n  ssize_t\tbytes;\t\t\t// Bytes read/written\n  char\t\tbuffer[65536];\t\t// Read/write buffer\n\n\n  // Copy the raw file...\n  papplJobSetImpressions(job, 1);\n\n  if ((fd  = open(papplJobGetFilename(job), O_RDONLY)) < 0)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to open print file '%s': %s\", papplJobGetFilename(job), strerror(errno));\n    return (false);\n  }\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Copy print data...\n  while ((bytes = read(fd, buffer, sizeof(buffer))) > 0)\n  {\n    if (papplDeviceWrite(device, buffer, (size_t)bytes) < 0)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to send %d bytes to printer.\", (int)bytes);\n      close(fd);\n      return (false);\n    }\n  }\n  close(fd);\n\n  papplJobSetImpressionsCompleted(job, 1);\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 441,
    "end_line": 449,
    "code": "((bytes = read(fd, buffer, sizeof(buffer))) > 0)\n  {\n    if (papplDeviceWrite(device, buffer, (size_t)bytes) < 0)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to send %d bytes to printer.\", (int)bytes);\n      close(fd);\n      return (false);\n    }\n  }\n  clo",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 442,
    "end_line": 449,
    "code": "if (papplDeviceWrite(device, buffer, (size_t)bytes) < 0)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to send %d bytes to printer.\", (int)bytes);\n      close(fd);\n      return (false);\n    }\n  }\n  clo",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 443,
    "end_line": 448,
    "code": "pplDeviceWrite(device, buffer, (size_t)bytes) < 0)\n    {\n      papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to send %d bytes to printer.\", (int)bytes);\n      close(fd);\n      return (false);\n    }\n  }\n ",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function",
    "start_line": 465,
    "end_line": 481,
    "name": "lprint_zpl_rendjob",
    "parent": null,
    "hierarchy": "lprint_zpl_rendjob",
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rendjob(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device)\t\t// I - Output device\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n\n\n  (void)options;\n\n  free(zpl);\n  papplJobSetData(job, NULL);\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "global_variable",
    "start_line": 471,
    "end_line": 471,
    "code": "_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function",
    "start_line": 488,
    "end_line": 543,
    "name": "lprint_zpl_rendpage",
    "parent": null,
    "hierarchy": "lprint_zpl_rendpage",
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rendpage(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device,\t\t// I - Output device\n    unsigned           page)\t\t// I - Page number\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n\n\n  (void)page;\n\n  lprint_zpl_rwriteline(job, options, device, options->header.cupsHeight, NULL);\n\n  papplDevicePrintf(device, \"^XA\\n^POI\\n^PW%u\\n^LH0,0\\n^LT%d\\n\", options->header.cupsWidth, options->media.top_offset * options->printer_resolution[1] / 2540);\n\n  if (options->media.type[0] && strcmp(options->media.type, \"labels\"))\n  {\n    // Continuous media, so always set tracking to continuous...\n    options->media.tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS;\n  }\n\n  if (options->media.tracking)\n  {\n    if (options->media.tracking == PAPPL_MEDIA_TRACKING_CONTINUOUS)\n      papplDevicePrintf(device, \"^LL%u\\n^MNN\\n\", options->header.cupsHeight);\n    else if (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n  if (strstr(papplPrinterGetDriverName(papplJobGetPrinter(job)), \"-tt\"))\n    papplDevicePuts(device, \"^MTT\\n\");\t// Thermal transfer\n  else\n    papplDevicePuts(device, \"^MTD\\n\");\t// Direct thermal\n\n  papplDevicePrintf(device, \"^PQ1, 0, 0, N\\n\");\n  papplDevicePuts(device, \"^FO0,0^XGR:LPRINT.GRF,1,1^FS\\n^XZ\\n\");\n  papplDevicePuts(device, \"^XA\\n^IDR:LPRINT.GRF^FS\\n^XZ\\n\");\n\n  if (options->finishings & PAPPL_FINISHINGS_TRIM)\n    papplDevicePuts(device, \"^CN1\\n\");\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Free memory and return...\n  lprintDitherFree(&zpl->dither);\n\n  free(zpl->comp_buffer);\n  free(zpl->last_buffer);\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 488,
    "end_line": 543,
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rendpage(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device,\t\t// I - Output device\n    unsigned           page)\t\t// I - Page number\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n\n\n  (void)page;\n\n  lprint_zpl_rwriteline(job, options, device, options->header.cupsHeight, NULL);\n\n  papplDevicePrintf(device, \"^XA\\n^POI\\n^PW%u\\n^LH0,0\\n^LT%d\\n\", options->header.cupsWidth, options->media.top_offset * options->printer_resolution[1] / 2540);\n\n  if (options->media.type[0] && strcmp(options->media.type, \"labels\"))\n  {\n    // Continuous media, so always set tracking to continuous...\n    options->media.tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS;\n  }\n\n  if (options->media.tracking)\n  {\n    if (options->media.tracking == PAPPL_MEDIA_TRACKING_CONTINUOUS)\n      papplDevicePrintf(device, \"^LL%u\\n^MNN\\n\", options->header.cupsHeight);\n    else if (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n  if (strstr(papplPrinterGetDriverName(papplJobGetPrinter(job)), \"-tt\"))\n    papplDevicePuts(device, \"^MTT\\n\");\t// Thermal transfer\n  else\n    papplDevicePuts(device, \"^MTD\\n\");\t// Direct thermal\n\n  papplDevicePrintf(device, \"^PQ1, 0, 0, N\\n\");\n  papplDevicePuts(device, \"^FO0,0^XGR:LPRINT.GRF,1,1^FS\\n^XZ\\n\");\n  papplDevicePuts(device, \"^XA\\n^IDR:LPRINT.GRF^FS\\n^XZ\\n\");\n\n  if (options->finishings & PAPPL_FINISHINGS_TRIM)\n    papplDevicePuts(device, \"^CN1\\n\");\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Free memory and return...\n  lprintDitherFree(&zpl->dither);\n\n  free(zpl->comp_buffer);\n  free(zpl->last_buffer);\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 488,
    "end_line": 543,
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rendpage(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device,\t\t// I - Output device\n    unsigned           page)\t\t// I - Page number\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n\n\n  (void)page;\n\n  lprint_zpl_rwriteline(job, options, device, options->header.cupsHeight, NULL);\n\n  papplDevicePrintf(device, \"^XA\\n^POI\\n^PW%u\\n^LH0,0\\n^LT%d\\n\", options->header.cupsWidth, options->media.top_offset * options->printer_resolution[1] / 2540);\n\n  if (options->media.type[0] && strcmp(options->media.type, \"labels\"))\n  {\n    // Continuous media, so always set tracking to continuous...\n    options->media.tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS;\n  }\n\n  if (options->media.tracking)\n  {\n    if (options->media.tracking == PAPPL_MEDIA_TRACKING_CONTINUOUS)\n      papplDevicePrintf(device, \"^LL%u\\n^MNN\\n\", options->header.cupsHeight);\n    else if (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n  if (strstr(papplPrinterGetDriverName(papplJobGetPrinter(job)), \"-tt\"))\n    papplDevicePuts(device, \"^MTT\\n\");\t// Thermal transfer\n  else\n    papplDevicePuts(device, \"^MTD\\n\");\t// Direct thermal\n\n  papplDevicePrintf(device, \"^PQ1, 0, 0, N\\n\");\n  papplDevicePuts(device, \"^FO0,0^XGR:LPRINT.GRF,1,1^FS\\n^XZ\\n\");\n  papplDevicePuts(device, \"^XA\\n^IDR:LPRINT.GRF^FS\\n^XZ\\n\");\n\n  if (options->finishings & PAPPL_FINISHINGS_TRIM)\n    papplDevicePuts(device, \"^CN1\\n\");\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Free memory and return...\n  lprintDitherFree(&zpl->dither);\n\n  free(zpl->comp_buffer);\n  free(zpl->last_buffer);\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 494,
    "end_line": 543,
    "code": "rint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n\n\n  (void)page;\n\n  lprint_zpl_rwriteline(job, options, device, options->header.cupsHeight, NULL);\n\n  papplDevicePrintf(device, \"^XA\\n^POI\\n^PW%u\\n^LH0,0\\n^LT%d\\n\", options->header.cupsWidth, options->media.top_offset * options->printer_resolution[1] / 2540);\n\n  if (options->media.type[0] && strcmp(options->media.type, \"labels\"))\n  {\n    // Continuous media, so always set tracking to continuous...\n    options->media.tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS;\n  }\n\n  if (options->media.tracking)\n  {\n    if (options->media.tracking == PAPPL_MEDIA_TRACKING_CONTINUOUS)\n      papplDevicePrintf(device, \"^LL%u\\n^MNN\\n\", options->header.cupsHeight);\n    else if (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n  if (strstr(papplPrinterGetDriverName(papplJobGetPrinter(job)), \"-tt\"))\n    papplDevicePuts(device, \"^MTT\\n\");\t// Thermal transfer\n  else\n    papplDevicePuts(device, \"^MTD\\n\");\t// Direct thermal\n\n  papplDevicePrintf(device, \"^PQ1, 0, 0, N\\n\");\n  papplDevicePuts(device, \"^FO0,0^XGR:LPRINT.GRF,1,1^FS\\n^XZ\\n\");\n  papplDevicePuts(device, \"^XA\\n^IDR:LPRINT.GRF^FS\\n^XZ\\n\");\n\n  if (options->finishings & PAPPL_FINISHINGS_TRIM)\n    papplDevicePuts(device, \"^CN1\\n\");\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Free memory and return...\n  lprintDitherFree(&zpl->dither);\n\n  free(zpl->comp_buffer);\n  free(zpl->last_buffer);\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 494,
    "end_line": 543,
    "code": "rint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n\n\n  (void)page;\n\n  lprint_zpl_rwriteline(job, options, device, options->header.cupsHeight, NULL);\n\n  papplDevicePrintf(device, \"^XA\\n^POI\\n^PW%u\\n^LH0,0\\n^LT%d\\n\", options->header.cupsWidth, options->media.top_offset * options->printer_resolution[1] / 2540);\n\n  if (options->media.type[0] && strcmp(options->media.type, \"labels\"))\n  {\n    // Continuous media, so always set tracking to continuous...\n    options->media.tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS;\n  }\n\n  if (options->media.tracking)\n  {\n    if (options->media.tracking == PAPPL_MEDIA_TRACKING_CONTINUOUS)\n      papplDevicePrintf(device, \"^LL%u\\n^MNN\\n\", options->header.cupsHeight);\n    else if (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n  if (strstr(papplPrinterGetDriverName(papplJobGetPrinter(job)), \"-tt\"))\n    papplDevicePuts(device, \"^MTT\\n\");\t// Thermal transfer\n  else\n    papplDevicePuts(device, \"^MTD\\n\");\t// Direct thermal\n\n  papplDevicePrintf(device, \"^PQ1, 0, 0, N\\n\");\n  papplDevicePuts(device, \"^FO0,0^XGR:LPRINT.GRF,1,1^FS\\n^XZ\\n\");\n  papplDevicePuts(device, \"^XA\\n^IDR:LPRINT.GRF^FS\\n^XZ\\n\");\n\n  if (options->finishings & PAPPL_FINISHINGS_TRIM)\n    papplDevicePuts(device, \"^CN1\\n\");\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Free memory and return...\n  lprintDitherFree(&zpl->dither);\n\n  free(zpl->comp_buffer);\n  free(zpl->last_buffer);\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "global_variable",
    "start_line": 495,
    "end_line": 495,
    "code": "_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 505,
    "end_line": 509,
    "code": "tions->media.type[0] && strcmp(options->media.type, \"labels\"))\n  {\n    // Continuous media, so always set tracking to continuous...\n    options->media.tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS;\n  }\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 505,
    "end_line": 509,
    "code": "tions->media.type[0] && strcmp(options->media.type, \"labels\"))\n  {\n    // Continuous media, so always set tracking to continuous...\n    options->media.tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS;\n  }\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 506,
    "end_line": 509,
    "code": "// Continuous media, so always set tracking to continuous...\n    options->media.tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS;\n  }\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 508,
    "end_line": 508,
    "code": "s->media.tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS;\n  }\n\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 508,
    "end_line": 508,
    "code": "s->media.tracking = PAPPL_MEDIA_TRACKING_CONTINUOUS;\n  }\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 511,
    "end_line": 519,
    "code": "tions->media.tracking)\n  {\n    if (options->media.tracking == PAPPL_MEDIA_TRACKING_CONTINUOUS)\n      papplDevicePrintf(device, \"^LL%u\\n^MNN\\n\", options->header.cupsHeight);\n    else if (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 511,
    "end_line": 519,
    "code": "tions->media.tracking)\n  {\n    if (options->media.tracking == PAPPL_MEDIA_TRACKING_CONTINUOUS)\n      papplDevicePrintf(device, \"^LL%u\\n^MNN\\n\", options->header.cupsHeight);\n    else if (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 512,
    "end_line": 519,
    "code": "if (options->media.tracking == PAPPL_MEDIA_TRACKING_CONTINUOUS)\n      papplDevicePrintf(device, \"^LL%u\\n^MNN\\n\", options->header.cupsHeight);\n    else if (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 512,
    "end_line": 519,
    "code": "if (options->media.tracking == PAPPL_MEDIA_TRACKING_CONTINUOUS)\n      papplDevicePrintf(device, \"^LL%u\\n^MNN\\n\", options->header.cupsHeight);\n    else if (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 513,
    "end_line": 518,
    "code": "tions->media.tracking == PAPPL_MEDIA_TRACKING_CONTINUOUS)\n      papplDevicePrintf(device, \"^LL%u\\n^MNN\\n\", options->header.cupsHeight);\n    else if (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 513,
    "end_line": 518,
    "code": "tions->media.tracking == PAPPL_MEDIA_TRACKING_CONTINUOUS)\n      papplDevicePrintf(device, \"^LL%u\\n^MNN\\n\", options->header.cupsHeight);\n    else if (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 515,
    "end_line": 518,
    "code": "f (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 515,
    "end_line": 518,
    "code": "f (options->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 515,
    "end_line": 518,
    "code": "tions->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 515,
    "end_line": 518,
    "code": "tions->media.tracking == PAPPL_MEDIA_TRACKING_WEB)\n      papplDevicePuts(device, \"^MNY\\n\");\n    else\n      papplDevicePuts(device, \"^MNM\\n\");\n  }\n\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function",
    "start_line": 550,
    "end_line": 615,
    "name": "lprint_zpl_rstartjob",
    "parent": null,
    "hierarchy": "lprint_zpl_rstartjob",
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rstartjob(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device)\t\t// I - Output device\n{\n  pappl_pr_driver_data_t data;\t\t// Driver data\n  int\t\t\tdarkness;\t// Composite darkness value\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)calloc(1, sizeof(lprint_zpl_t));\n\t\t\t\t\t// ZPL driver data\n\n\n  // Initialize driver data...\n  papplJobSetData(job, zpl);\n\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  // label-mode-configured\n  switch (data.mode_configured)\n  {\n    case PAPPL_LABEL_MODE_APPLICATOR :\n        papplDevicePuts(device, \"^MMA,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER :\n        papplDevicePuts(device, \"^MMC,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER_DELAYED :\n        papplDevicePuts(device, \"^MMD,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_KIOSK :\n        papplDevicePuts(device, \"^MMK,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF :\n        papplDevicePuts(device, \"^MMP,N\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL :\n        papplDevicePuts(device, \"^MMP,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_REWIND :\n        papplDevicePuts(device, \"^MMR,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_RFID :\n        papplDevicePuts(device, \"^MMF,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_TEAR_OFF :\n    default :\n        papplDevicePuts(device, \"^MMT,Y\\n\");\n        break;\n  }\n\n  // label-tear-offset-configured\n  if (data.tear_offset_configured < 0)\n    papplDevicePrintf(device, \"~TA%04d\\n\", data.tear_offset_configured);\n  else if (data.tear_offset_configured > 0)\n    papplDevicePrintf(device, \"~TA%03d\\n\", data.tear_offset_configured);\n\n  // print-darkness / printer-darkness-configured\n  if ((darkness = options->print_darkness + options->darkness_configured) < 0)\n    darkness = 0;\n  else if (darkness > 100)\n    darkness = 100;\n\n  papplDevicePrintf(device, \"~SD%02u\\n\", 30 * darkness / 100);\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 550,
    "end_line": 615,
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rstartjob(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device)\t\t// I - Output device\n{\n  pappl_pr_driver_data_t data;\t\t// Driver data\n  int\t\t\tdarkness;\t// Composite darkness value\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)calloc(1, sizeof(lprint_zpl_t));\n\t\t\t\t\t// ZPL driver data\n\n\n  // Initialize driver data...\n  papplJobSetData(job, zpl);\n\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  // label-mode-configured\n  switch (data.mode_configured)\n  {\n    case PAPPL_LABEL_MODE_APPLICATOR :\n        papplDevicePuts(device, \"^MMA,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER :\n        papplDevicePuts(device, \"^MMC,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER_DELAYED :\n        papplDevicePuts(device, \"^MMD,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_KIOSK :\n        papplDevicePuts(device, \"^MMK,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF :\n        papplDevicePuts(device, \"^MMP,N\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL :\n        papplDevicePuts(device, \"^MMP,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_REWIND :\n        papplDevicePuts(device, \"^MMR,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_RFID :\n        papplDevicePuts(device, \"^MMF,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_TEAR_OFF :\n    default :\n        papplDevicePuts(device, \"^MMT,Y\\n\");\n        break;\n  }\n\n  // label-tear-offset-configured\n  if (data.tear_offset_configured < 0)\n    papplDevicePrintf(device, \"~TA%04d\\n\", data.tear_offset_configured);\n  else if (data.tear_offset_configured > 0)\n    papplDevicePrintf(device, \"~TA%03d\\n\", data.tear_offset_configured);\n\n  // print-darkness / printer-darkness-configured\n  if ((darkness = options->print_darkness + options->darkness_configured) < 0)\n    darkness = 0;\n  else if (darkness > 100)\n    darkness = 100;\n\n  papplDevicePrintf(device, \"~SD%02u\\n\", 30 * darkness / 100);\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 550,
    "end_line": 615,
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rstartjob(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device)\t\t// I - Output device\n{\n  pappl_pr_driver_data_t data;\t\t// Driver data\n  int\t\t\tdarkness;\t// Composite darkness value\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)calloc(1, sizeof(lprint_zpl_t));\n\t\t\t\t\t// ZPL driver data\n\n\n  // Initialize driver data...\n  papplJobSetData(job, zpl);\n\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  // label-mode-configured\n  switch (data.mode_configured)\n  {\n    case PAPPL_LABEL_MODE_APPLICATOR :\n        papplDevicePuts(device, \"^MMA,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER :\n        papplDevicePuts(device, \"^MMC,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER_DELAYED :\n        papplDevicePuts(device, \"^MMD,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_KIOSK :\n        papplDevicePuts(device, \"^MMK,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF :\n        papplDevicePuts(device, \"^MMP,N\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL :\n        papplDevicePuts(device, \"^MMP,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_REWIND :\n        papplDevicePuts(device, \"^MMR,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_RFID :\n        papplDevicePuts(device, \"^MMF,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_TEAR_OFF :\n    default :\n        papplDevicePuts(device, \"^MMT,Y\\n\");\n        break;\n  }\n\n  // label-tear-offset-configured\n  if (data.tear_offset_configured < 0)\n    papplDevicePrintf(device, \"~TA%04d\\n\", data.tear_offset_configured);\n  else if (data.tear_offset_configured > 0)\n    papplDevicePrintf(device, \"~TA%03d\\n\", data.tear_offset_configured);\n\n  // print-darkness / printer-darkness-configured\n  if ((darkness = options->print_darkness + options->darkness_configured) < 0)\n    darkness = 0;\n  else if (darkness > 100)\n    darkness = 100;\n\n  papplDevicePrintf(device, \"~SD%02u\\n\", 30 * darkness / 100);\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 555,
    "end_line": 615,
    "code": "ppl_pr_driver_data_t data;\t\t// Driver data\n  int\t\t\tdarkness;\t// Composite darkness value\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)calloc(1, sizeof(lprint_zpl_t));\n\t\t\t\t\t// ZPL driver data\n\n\n  // Initialize driver data...\n  papplJobSetData(job, zpl);\n\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  // label-mode-configured\n  switch (data.mode_configured)\n  {\n    case PAPPL_LABEL_MODE_APPLICATOR :\n        papplDevicePuts(device, \"^MMA,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER :\n        papplDevicePuts(device, \"^MMC,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER_DELAYED :\n        papplDevicePuts(device, \"^MMD,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_KIOSK :\n        papplDevicePuts(device, \"^MMK,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF :\n        papplDevicePuts(device, \"^MMP,N\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL :\n        papplDevicePuts(device, \"^MMP,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_REWIND :\n        papplDevicePuts(device, \"^MMR,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_RFID :\n        papplDevicePuts(device, \"^MMF,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_TEAR_OFF :\n    default :\n        papplDevicePuts(device, \"^MMT,Y\\n\");\n        break;\n  }\n\n  // label-tear-offset-configured\n  if (data.tear_offset_configured < 0)\n    papplDevicePrintf(device, \"~TA%04d\\n\", data.tear_offset_configured);\n  else if (data.tear_offset_configured > 0)\n    papplDevicePrintf(device, \"~TA%03d\\n\", data.tear_offset_configured);\n\n  // print-darkness / printer-darkness-configured\n  if ((darkness = options->print_darkness + options->darkness_configured) < 0)\n    darkness = 0;\n  else if (darkness > 100)\n    darkness = 100;\n\n  papplDevicePrintf(device, \"~SD%02u\\n\", 30 * darkness / 100);\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 555,
    "end_line": 615,
    "code": "ppl_pr_driver_data_t data;\t\t// Driver data\n  int\t\t\tdarkness;\t// Composite darkness value\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)calloc(1, sizeof(lprint_zpl_t));\n\t\t\t\t\t// ZPL driver data\n\n\n  // Initialize driver data...\n  papplJobSetData(job, zpl);\n\n  papplPrinterGetDriverData(papplJobGetPrinter(job), &data);\n\n  // label-mode-configured\n  switch (data.mode_configured)\n  {\n    case PAPPL_LABEL_MODE_APPLICATOR :\n        papplDevicePuts(device, \"^MMA,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER :\n        papplDevicePuts(device, \"^MMC,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER_DELAYED :\n        papplDevicePuts(device, \"^MMD,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_KIOSK :\n        papplDevicePuts(device, \"^MMK,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF :\n        papplDevicePuts(device, \"^MMP,N\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL :\n        papplDevicePuts(device, \"^MMP,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_REWIND :\n        papplDevicePuts(device, \"^MMR,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_RFID :\n        papplDevicePuts(device, \"^MMF,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_TEAR_OFF :\n    default :\n        papplDevicePuts(device, \"^MMT,Y\\n\");\n        break;\n  }\n\n  // label-tear-offset-configured\n  if (data.tear_offset_configured < 0)\n    papplDevicePrintf(device, \"~TA%04d\\n\", data.tear_offset_configured);\n  else if (data.tear_offset_configured > 0)\n    papplDevicePrintf(device, \"~TA%03d\\n\", data.tear_offset_configured);\n\n  // print-darkness / printer-darkness-configured\n  if ((darkness = options->print_darkness + options->darkness_configured) < 0)\n    darkness = 0;\n  else if (darkness > 100)\n    darkness = 100;\n\n  papplDevicePrintf(device, \"~SD%02u\\n\", 30 * darkness / 100);\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "global_variable",
    "start_line": 558,
    "end_line": 558,
    "code": "_zpl_t\t*zpl = (lprint_zpl_t *)calloc(1, sizeof(lprint_zpl_t));\n\t\t\t\t\t",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 568,
    "end_line": 598,
    "code": " (data.mode_configured)\n  {\n    case PAPPL_LABEL_MODE_APPLICATOR :\n        papplDevicePuts(device, \"^MMA,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER :\n        papplDevicePuts(device, \"^MMC,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_CUTTER_DELAYED :\n        papplDevicePuts(device, \"^MMD,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_KIOSK :\n        papplDevicePuts(device, \"^MMK,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF :\n        papplDevicePuts(device, \"^MMP,N\\n\");\n        break;\n    case PAPPL_LABEL_MODE_PEEL_OFF_PREPEEL :\n        papplDevicePuts(device, \"^MMP,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_REWIND :\n        papplDevicePuts(device, \"^MMR,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_RFID :\n        papplDevicePuts(device, \"^MMF,Y\\n\");\n        break;\n    case PAPPL_LABEL_MODE_TEAR_OFF :\n    default :\n        papplDevicePuts(device, \"^MMT,Y\\n\");\n        break;\n  }\n\n  //",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 607,
    "end_line": 610,
    "code": "arkness = options->print_darkness + options->darkness_configured) < 0)\n    darkness = 0;\n  else if (darkness > 100)\n    darkness = 100;\n\n  pa",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 607,
    "end_line": 610,
    "code": "arkness = options->print_darkness + options->darkness_configured) < 0)\n    darkness = 0;\n  else if (darkness > 100)\n    darkness = 100;\n\n  pa",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function",
    "start_line": 622,
    "end_line": 668,
    "name": "lprint_zpl_rstartpage",
    "parent": null,
    "hierarchy": "lprint_zpl_rstartpage",
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rstartpage(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device,\t\t// I - Output device\n    unsigned           page)\t\t// I - Page number\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  int\t\tips;\t\t\t// Inches per second\n  double\tout_gamma = 1.0;\t// Output gamma correction\n\n\n  (void)page;\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Setup dither buffer...\n  if (options->header.HWResolution[0] == 300)\n    out_gamma = 1.2;\n  else if (options->header.HWResolution[0] == 600)\n    out_gamma = 1.44;\n\n  if (!lprintDitherAlloc(&zpl->dither, job, options, CUPS_CSPACE_K, out_gamma))\n    return (false);\n\n  // print-speed\n  if ((ips = options->print_speed / 2540) > 0)\n    papplDevicePrintf(device, \"^PR%d,%d,%d\\n\", ips, ips, ips);\n\n  // Download bitmap...\n  papplDevicePrintf(device, \"~DGR:LPRINT.GRF,%u,%u,\\n\", zpl->dither.in_height * zpl->dither.out_width, zpl->dither.out_width);\n\n  // Allocate memory for writing the bitmap...\n  zpl->comp_buffer     = malloc(2 * zpl->dither.out_width + 1);\n  zpl->last_buffer     = malloc(zpl->dither.out_width);\n  zpl->last_buffer_set = 0;\n\n  if (!zpl->comp_buffer || !zpl->last_buffer)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate compression buffers.\");\n    return (false);\n  }\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 622,
    "end_line": 668,
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rstartpage(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device,\t\t// I - Output device\n    unsigned           page)\t\t// I - Page number\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  int\t\tips;\t\t\t// Inches per second\n  double\tout_gamma = 1.0;\t// Output gamma correction\n\n\n  (void)page;\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Setup dither buffer...\n  if (options->header.HWResolution[0] == 300)\n    out_gamma = 1.2;\n  else if (options->header.HWResolution[0] == 600)\n    out_gamma = 1.44;\n\n  if (!lprintDitherAlloc(&zpl->dither, job, options, CUPS_CSPACE_K, out_gamma))\n    return (false);\n\n  // print-speed\n  if ((ips = options->print_speed / 2540) > 0)\n    papplDevicePrintf(device, \"^PR%d,%d,%d\\n\", ips, ips, ips);\n\n  // Download bitmap...\n  papplDevicePrintf(device, \"~DGR:LPRINT.GRF,%u,%u,\\n\", zpl->dither.in_height * zpl->dither.out_width, zpl->dither.out_width);\n\n  // Allocate memory for writing the bitmap...\n  zpl->comp_buffer     = malloc(2 * zpl->dither.out_width + 1);\n  zpl->last_buffer     = malloc(zpl->dither.out_width);\n  zpl->last_buffer_set = 0;\n\n  if (!zpl->comp_buffer || !zpl->last_buffer)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate compression buffers.\");\n    return (false);\n  }\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 622,
    "end_line": 668,
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rstartpage(\n    pappl_job_t        *job,\t\t// I - Job\n    pappl_pr_options_t *options,\t// I - Job options\n    pappl_device_t     *device,\t\t// I - Output device\n    unsigned           page)\t\t// I - Page number\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  int\t\tips;\t\t\t// Inches per second\n  double\tout_gamma = 1.0;\t// Output gamma correction\n\n\n  (void)page;\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Setup dither buffer...\n  if (options->header.HWResolution[0] == 300)\n    out_gamma = 1.2;\n  else if (options->header.HWResolution[0] == 600)\n    out_gamma = 1.44;\n\n  if (!lprintDitherAlloc(&zpl->dither, job, options, CUPS_CSPACE_K, out_gamma))\n    return (false);\n\n  // print-speed\n  if ((ips = options->print_speed / 2540) > 0)\n    papplDevicePrintf(device, \"^PR%d,%d,%d\\n\", ips, ips, ips);\n\n  // Download bitmap...\n  papplDevicePrintf(device, \"~DGR:LPRINT.GRF,%u,%u,\\n\", zpl->dither.in_height * zpl->dither.out_width, zpl->dither.out_width);\n\n  // Allocate memory for writing the bitmap...\n  zpl->comp_buffer     = malloc(2 * zpl->dither.out_width + 1);\n  zpl->last_buffer     = malloc(zpl->dither.out_width);\n  zpl->last_buffer_set = 0;\n\n  if (!zpl->comp_buffer || !zpl->last_buffer)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate compression buffers.\");\n    return (false);\n  }\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 628,
    "end_line": 668,
    "code": "rint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  int\t\tips;\t\t\t// Inches per second\n  double\tout_gamma = 1.0;\t// Output gamma correction\n\n\n  (void)page;\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Setup dither buffer...\n  if (options->header.HWResolution[0] == 300)\n    out_gamma = 1.2;\n  else if (options->header.HWResolution[0] == 600)\n    out_gamma = 1.44;\n\n  if (!lprintDitherAlloc(&zpl->dither, job, options, CUPS_CSPACE_K, out_gamma))\n    return (false);\n\n  // print-speed\n  if ((ips = options->print_speed / 2540) > 0)\n    papplDevicePrintf(device, \"^PR%d,%d,%d\\n\", ips, ips, ips);\n\n  // Download bitmap...\n  papplDevicePrintf(device, \"~DGR:LPRINT.GRF,%u,%u,\\n\", zpl->dither.in_height * zpl->dither.out_width, zpl->dither.out_width);\n\n  // Allocate memory for writing the bitmap...\n  zpl->comp_buffer     = malloc(2 * zpl->dither.out_width + 1);\n  zpl->last_buffer     = malloc(zpl->dither.out_width);\n  zpl->last_buffer_set = 0;\n\n  if (!zpl->comp_buffer || !zpl->last_buffer)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate compression buffers.\");\n    return (false);\n  }\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 628,
    "end_line": 668,
    "code": "rint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  int\t\tips;\t\t\t// Inches per second\n  double\tout_gamma = 1.0;\t// Output gamma correction\n\n\n  (void)page;\n\n  // Update status...\n  lprint_zpl_update_reasons(papplJobGetPrinter(job), job, device);\n\n  // Setup dither buffer...\n  if (options->header.HWResolution[0] == 300)\n    out_gamma = 1.2;\n  else if (options->header.HWResolution[0] == 600)\n    out_gamma = 1.44;\n\n  if (!lprintDitherAlloc(&zpl->dither, job, options, CUPS_CSPACE_K, out_gamma))\n    return (false);\n\n  // print-speed\n  if ((ips = options->print_speed / 2540) > 0)\n    papplDevicePrintf(device, \"^PR%d,%d,%d\\n\", ips, ips, ips);\n\n  // Download bitmap...\n  papplDevicePrintf(device, \"~DGR:LPRINT.GRF,%u,%u,\\n\", zpl->dither.in_height * zpl->dither.out_width, zpl->dither.out_width);\n\n  // Allocate memory for writing the bitmap...\n  zpl->comp_buffer     = malloc(2 * zpl->dither.out_width + 1);\n  zpl->last_buffer     = malloc(zpl->dither.out_width);\n  zpl->last_buffer_set = 0;\n\n  if (!zpl->comp_buffer || !zpl->last_buffer)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate compression buffers.\");\n    return (false);\n  }\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "global_variable",
    "start_line": 629,
    "end_line": 629,
    "code": "_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "global_variable",
    "start_line": 632,
    "end_line": 632,
    "code": "\tout_gamma = 1.0;\t// Ou",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 632,
    "end_line": 632,
    "code": "\tout_gamma = 1.0;\t// Ou",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 632,
    "end_line": 632,
    "code": "mma = 1.0;\t// O",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 641,
    "end_line": 644,
    "code": "tions->header.HWResolution[0] == 300)\n    out_gamma = 1.2;\n  else if (options->header.HWResolution[0] == 600)\n    out_gamma = 1.44;\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 641,
    "end_line": 644,
    "code": "tions->header.HWResolution[0] == 300)\n    out_gamma = 1.2;\n  else if (options->header.HWResolution[0] == 600)\n    out_gamma = 1.44;\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 642,
    "end_line": 642,
    "code": "mma = 1.2;\n  els",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 642,
    "end_line": 642,
    "code": "mma = 1.2;\n  el",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 643,
    "end_line": 644,
    "code": "f (options->header.HWResolution[0] == 600)\n    out_gamma = 1.44;\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 643,
    "end_line": 644,
    "code": "f (options->header.HWResolution[0] == 600)\n    out_gamma = 1.44;\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 643,
    "end_line": 644,
    "code": "tions->header.HWResolution[0] == 600)\n    out_gamma = 1.44;\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 644,
    "end_line": 644,
    "code": "mma = 1.44;\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 644,
    "end_line": 644,
    "code": "mma = 1.44;\n\n  i",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 650,
    "end_line": 651,
    "code": "ps = options->print_speed / 2540) > 0)\n    papplDevicePrintf(device, \"^PR%d,%d,%d\\n\", ips, ips, ips);\n\n  //",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 650,
    "end_line": 651,
    "code": "ps = options->print_speed / 2540) > 0)\n    papplDevicePrintf(device, \"^PR%d,%d,%d\\n\", ips, ips, ips);\n\n  //",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 657,
    "end_line": 657,
    "code": "omp_buffer     = malloc(2 * zpl->dither.out_width + 1);\n  zpl",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 657,
    "end_line": 657,
    "code": "omp_buffer     = malloc(2 * zpl->dither.out_width + 1);\n  zpl",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 657,
    "end_line": 657,
    "code": "omp_buffer     = malloc(2 * zpl->dither.out_width + 1);\n  zp",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 657,
    "end_line": 657,
    "code": "omp_buffer     = malloc(2 * zpl->dither.out_width + 1);\n  zp",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 658,
    "end_line": 658,
    "code": "ast_buffer     = malloc(zpl->dither.out_width);\n  zpl",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 658,
    "end_line": 658,
    "code": "ast_buffer     = malloc(zpl->dither.out_width);\n  zpl",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 658,
    "end_line": 658,
    "code": "ast_buffer     = malloc(zpl->dither.out_width);\n  zp",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 658,
    "end_line": 658,
    "code": "ast_buffer     = malloc(zpl->dither.out_width);\n  zp",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 661,
    "end_line": 665,
    "code": "pl->comp_buffer || !zpl->last_buffer)\n  {\n    papplLogJob(job, PAPPL_LOGLEVEL_ERROR, \"Unable to allocate compression buffers.\");\n    return (false);\n  }\n\n  re",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function",
    "start_line": 675,
    "end_line": 758,
    "name": "lprint_zpl_rwriteline",
    "parent": null,
    "hierarchy": "lprint_zpl_rwriteline",
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rwriteline(\n    pappl_job_t         *job,\t\t// I - Job\n    pappl_pr_options_t  *options,\t// I - Job options\n    pappl_device_t      *device,\t// I - Output device\n    unsigned            y,\t\t// I - Line number\n    const unsigned char *line)\t\t// I - Line\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  unsigned\t\ti;\t\t// Looping var\n  const unsigned char\t*ptr;\t\t// Pointer into buffer\n  unsigned char\t\t*compptr;\t// Pointer into compression buffer\n#if ZPL_COMPRESSION\n  unsigned char\t\trepeat_char;\t// Repeated character\n  unsigned\t\trepeat_count;\t// Number of repeated characters\n#endif // ZPL_COMPRESSION\n  static const unsigned char *hex = (const unsigned char *)\"0123456789ABCDEF\";\n\t\t\t\t\t// Hex digits\n\n\n  if (!lprintDitherLine(&zpl->dither, y, line))\n    return (true);\n\n  // Determine whether this row is the same as the previous line.\n  // If so, output a ':' and return...\n  if (zpl->last_buffer_set && !memcmp(zpl->dither.output, zpl->last_buffer, zpl->dither.out_width))\n  {\n    papplDeviceWrite(device, \":\", 1);\n    return (true);\n  }\n\n  // Convert the line to hex digits...\n  for (ptr = zpl->dither.output, compptr = zpl->comp_buffer, i = zpl->dither.out_width; i > 0; i --, ptr ++)\n  {\n    *compptr++ = hex[*ptr >> 4];\n    *compptr++ = hex[*ptr & 15];\n  }\n\n#if ZPL_COMPRESSION\n  // Send run-length compressed HEX data...\n  *compptr = '\\0';\n\n  // Run-length compress the graphics...\n  for (compptr = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *compptr; compptr ++)\n  {\n    if (*compptr == repeat_char)\n    {\n      repeat_count ++;\n    }\n    else\n    {\n      lprint_zpl_compress(device, repeat_char, repeat_count);\n      repeat_char  = *compptr;\n      repeat_count = 1;\n    }\n  }\n\n  if (repeat_char == '0')\n  {\n    // Handle 0's on the end of the line...\n    if (repeat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    if (repeat_count > 0)\n      papplDevicePuts(device, \",\");\n  }\n  else\n    lprint_zpl_compress(device, repeat_char, repeat_count);\n\n#else\n  // Send uncompressed HEX data...\n  papplDeviceWrite(device, zpl->comp_buffer, compptr - zpl->comp_buffer);\n#endif // ZPL_COMPRESSION\n\n  // Save this line for the next round...\n  memcpy(zpl->last_buffer, zpl->dither.output, zpl->dither.out_width);\n  zpl->last_buffer_set = 1;\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 675,
    "end_line": 758,
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rwriteline(\n    pappl_job_t         *job,\t\t// I - Job\n    pappl_pr_options_t  *options,\t// I - Job options\n    pappl_device_t      *device,\t// I - Output device\n    unsigned            y,\t\t// I - Line number\n    const unsigned char *line)\t\t// I - Line\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  unsigned\t\ti;\t\t// Looping var\n  const unsigned char\t*ptr;\t\t// Pointer into buffer\n  unsigned char\t\t*compptr;\t// Pointer into compression buffer\n#if ZPL_COMPRESSION\n  unsigned char\t\trepeat_char;\t// Repeated character\n  unsigned\t\trepeat_count;\t// Number of repeated characters\n#endif // ZPL_COMPRESSION\n  static const unsigned char *hex = (const unsigned char *)\"0123456789ABCDEF\";\n\t\t\t\t\t// Hex digits\n\n\n  if (!lprintDitherLine(&zpl->dither, y, line))\n    return (true);\n\n  // Determine whether this row is the same as the previous line.\n  // If so, output a ':' and return...\n  if (zpl->last_buffer_set && !memcmp(zpl->dither.output, zpl->last_buffer, zpl->dither.out_width))\n  {\n    papplDeviceWrite(device, \":\", 1);\n    return (true);\n  }\n\n  // Convert the line to hex digits...\n  for (ptr = zpl->dither.output, compptr = zpl->comp_buffer, i = zpl->dither.out_width; i > 0; i --, ptr ++)\n  {\n    *compptr++ = hex[*ptr >> 4];\n    *compptr++ = hex[*ptr & 15];\n  }\n\n#if ZPL_COMPRESSION\n  // Send run-length compressed HEX data...\n  *compptr = '\\0';\n\n  // Run-length compress the graphics...\n  for (compptr = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *compptr; compptr ++)\n  {\n    if (*compptr == repeat_char)\n    {\n      repeat_count ++;\n    }\n    else\n    {\n      lprint_zpl_compress(device, repeat_char, repeat_count);\n      repeat_char  = *compptr;\n      repeat_count = 1;\n    }\n  }\n\n  if (repeat_char == '0')\n  {\n    // Handle 0's on the end of the line...\n    if (repeat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    if (repeat_count > 0)\n      papplDevicePuts(device, \",\");\n  }\n  else\n    lprint_zpl_compress(device, repeat_char, repeat_count);\n\n#else\n  // Send uncompressed HEX data...\n  papplDeviceWrite(device, zpl->comp_buffer, compptr - zpl->comp_buffer);\n#endif // ZPL_COMPRESSION\n\n  // Save this line for the next round...\n  memcpy(zpl->last_buffer, zpl->dither.output, zpl->dither.out_width);\n  zpl->last_buffer_set = 1;\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 675,
    "end_line": 758,
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rwriteline(\n    pappl_job_t         *job,\t\t// I - Job\n    pappl_pr_options_t  *options,\t// I - Job options\n    pappl_device_t      *device,\t// I - Output device\n    unsigned            y,\t\t// I - Line number\n    const unsigned char *line)\t\t// I - Line\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  unsigned\t\ti;\t\t// Looping var\n  const unsigned char\t*ptr;\t\t// Pointer into buffer\n  unsigned char\t\t*compptr;\t// Pointer into compression buffer\n#if ZPL_COMPRESSION\n  unsigned char\t\trepeat_char;\t// Repeated character\n  unsigned\t\trepeat_count;\t// Number of repeated characters\n#endif // ZPL_COMPRESSION\n  static const unsigned char *hex = (const unsigned char *)\"0123456789ABCDEF\";\n\t\t\t\t\t// Hex digits\n\n\n  if (!lprintDitherLine(&zpl->dither, y, line))\n    return (true);\n\n  // Determine whether this row is the same as the previous line.\n  // If so, output a ':' and return...\n  if (zpl->last_buffer_set && !memcmp(zpl->dither.output, zpl->last_buffer, zpl->dither.out_width))\n  {\n    papplDeviceWrite(device, \":\", 1);\n    return (true);\n  }\n\n  // Convert the line to hex digits...\n  for (ptr = zpl->dither.output, compptr = zpl->comp_buffer, i = zpl->dither.out_width; i > 0; i --, ptr ++)\n  {\n    *compptr++ = hex[*ptr >> 4];\n    *compptr++ = hex[*ptr & 15];\n  }\n\n#if ZPL_COMPRESSION\n  // Send run-length compressed HEX data...\n  *compptr = '\\0';\n\n  // Run-length compress the graphics...\n  for (compptr = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *compptr; compptr ++)\n  {\n    if (*compptr == repeat_char)\n    {\n      repeat_count ++;\n    }\n    else\n    {\n      lprint_zpl_compress(device, repeat_char, repeat_count);\n      repeat_char  = *compptr;\n      repeat_count = 1;\n    }\n  }\n\n  if (repeat_char == '0')\n  {\n    // Handle 0's on the end of the line...\n    if (repeat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    if (repeat_count > 0)\n      papplDevicePuts(device, \",\");\n  }\n  else\n    lprint_zpl_compress(device, repeat_char, repeat_count);\n\n#else\n  // Send uncompressed HEX data...\n  papplDeviceWrite(device, zpl->comp_buffer, compptr - zpl->comp_buffer);\n#endif // ZPL_COMPRESSION\n\n  // Save this line for the next round...\n  memcpy(zpl->last_buffer, zpl->dither.output, zpl->dither.out_width);\n  zpl->last_buffer_set = 1;\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 675,
    "end_line": 758,
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_rwriteline(\n    pappl_job_t         *job,\t\t// I - Job\n    pappl_pr_options_t  *options,\t// I - Job options\n    pappl_device_t      *device,\t// I - Output device\n    unsigned            y,\t\t// I - Line number\n    const unsigned char *line)\t\t// I - Line\n{\n  lprint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  unsigned\t\ti;\t\t// Looping var\n  const unsigned char\t*ptr;\t\t// Pointer into buffer\n  unsigned char\t\t*compptr;\t// Pointer into compression buffer\n#if ZPL_COMPRESSION\n  unsigned char\t\trepeat_char;\t// Repeated character\n  unsigned\t\trepeat_count;\t// Number of repeated characters\n#endif // ZPL_COMPRESSION\n  static const unsigned char *hex = (const unsigned char *)\"0123456789ABCDEF\";\n\t\t\t\t\t// Hex digits\n\n\n  if (!lprintDitherLine(&zpl->dither, y, line))\n    return (true);\n\n  // Determine whether this row is the same as the previous line.\n  // If so, output a ':' and return...\n  if (zpl->last_buffer_set && !memcmp(zpl->dither.output, zpl->last_buffer, zpl->dither.out_width))\n  {\n    papplDeviceWrite(device, \":\", 1);\n    return (true);\n  }\n\n  // Convert the line to hex digits...\n  for (ptr = zpl->dither.output, compptr = zpl->comp_buffer, i = zpl->dither.out_width; i > 0; i --, ptr ++)\n  {\n    *compptr++ = hex[*ptr >> 4];\n    *compptr++ = hex[*ptr & 15];\n  }\n\n#if ZPL_COMPRESSION\n  // Send run-length compressed HEX data...\n  *compptr = '\\0';\n\n  // Run-length compress the graphics...\n  for (compptr = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *compptr; compptr ++)\n  {\n    if (*compptr == repeat_char)\n    {\n      repeat_count ++;\n    }\n    else\n    {\n      lprint_zpl_compress(device, repeat_char, repeat_count);\n      repeat_char  = *compptr;\n      repeat_count = 1;\n    }\n  }\n\n  if (repeat_char == '0')\n  {\n    // Handle 0's on the end of the line...\n    if (repeat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    if (repeat_count > 0)\n      papplDevicePuts(device, \",\");\n  }\n  else\n    lprint_zpl_compress(device, repeat_char, repeat_count);\n\n#else\n  // Send uncompressed HEX data...\n  papplDeviceWrite(device, zpl->comp_buffer, compptr - zpl->comp_buffer);\n#endif // ZPL_COMPRESSION\n\n  // Save this line for the next round...\n  memcpy(zpl->last_buffer, zpl->dither.output, zpl->dither.out_width);\n  zpl->last_buffer_set = 1;\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 682,
    "end_line": 758,
    "code": "rint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  unsigned\t\ti;\t\t// Looping var\n  const unsigned char\t*ptr;\t\t// Pointer into buffer\n  unsigned char\t\t*compptr;\t// Pointer into compression buffer\n#if ZPL_COMPRESSION\n  unsigned char\t\trepeat_char;\t// Repeated character\n  unsigned\t\trepeat_count;\t// Number of repeated characters\n#endif // ZPL_COMPRESSION\n  static const unsigned char *hex = (const unsigned char *)\"0123456789ABCDEF\";\n\t\t\t\t\t// Hex digits\n\n\n  if (!lprintDitherLine(&zpl->dither, y, line))\n    return (true);\n\n  // Determine whether this row is the same as the previous line.\n  // If so, output a ':' and return...\n  if (zpl->last_buffer_set && !memcmp(zpl->dither.output, zpl->last_buffer, zpl->dither.out_width))\n  {\n    papplDeviceWrite(device, \":\", 1);\n    return (true);\n  }\n\n  // Convert the line to hex digits...\n  for (ptr = zpl->dither.output, compptr = zpl->comp_buffer, i = zpl->dither.out_width; i > 0; i --, ptr ++)\n  {\n    *compptr++ = hex[*ptr >> 4];\n    *compptr++ = hex[*ptr & 15];\n  }\n\n#if ZPL_COMPRESSION\n  // Send run-length compressed HEX data...\n  *compptr = '\\0';\n\n  // Run-length compress the graphics...\n  for (compptr = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *compptr; compptr ++)\n  {\n    if (*compptr == repeat_char)\n    {\n      repeat_count ++;\n    }\n    else\n    {\n      lprint_zpl_compress(device, repeat_char, repeat_count);\n      repeat_char  = *compptr;\n      repeat_count = 1;\n    }\n  }\n\n  if (repeat_char == '0')\n  {\n    // Handle 0's on the end of the line...\n    if (repeat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    if (repeat_count > 0)\n      papplDevicePuts(device, \",\");\n  }\n  else\n    lprint_zpl_compress(device, repeat_char, repeat_count);\n\n#else\n  // Send uncompressed HEX data...\n  papplDeviceWrite(device, zpl->comp_buffer, compptr - zpl->comp_buffer);\n#endif // ZPL_COMPRESSION\n\n  // Save this line for the next round...\n  memcpy(zpl->last_buffer, zpl->dither.output, zpl->dither.out_width);\n  zpl->last_buffer_set = 1;\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 682,
    "end_line": 758,
    "code": "rint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  unsigned\t\ti;\t\t// Looping var\n  const unsigned char\t*ptr;\t\t// Pointer into buffer\n  unsigned char\t\t*compptr;\t// Pointer into compression buffer\n#if ZPL_COMPRESSION\n  unsigned char\t\trepeat_char;\t// Repeated character\n  unsigned\t\trepeat_count;\t// Number of repeated characters\n#endif // ZPL_COMPRESSION\n  static const unsigned char *hex = (const unsigned char *)\"0123456789ABCDEF\";\n\t\t\t\t\t// Hex digits\n\n\n  if (!lprintDitherLine(&zpl->dither, y, line))\n    return (true);\n\n  // Determine whether this row is the same as the previous line.\n  // If so, output a ':' and return...\n  if (zpl->last_buffer_set && !memcmp(zpl->dither.output, zpl->last_buffer, zpl->dither.out_width))\n  {\n    papplDeviceWrite(device, \":\", 1);\n    return (true);\n  }\n\n  // Convert the line to hex digits...\n  for (ptr = zpl->dither.output, compptr = zpl->comp_buffer, i = zpl->dither.out_width; i > 0; i --, ptr ++)\n  {\n    *compptr++ = hex[*ptr >> 4];\n    *compptr++ = hex[*ptr & 15];\n  }\n\n#if ZPL_COMPRESSION\n  // Send run-length compressed HEX data...\n  *compptr = '\\0';\n\n  // Run-length compress the graphics...\n  for (compptr = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *compptr; compptr ++)\n  {\n    if (*compptr == repeat_char)\n    {\n      repeat_count ++;\n    }\n    else\n    {\n      lprint_zpl_compress(device, repeat_char, repeat_count);\n      repeat_char  = *compptr;\n      repeat_count = 1;\n    }\n  }\n\n  if (repeat_char == '0')\n  {\n    // Handle 0's on the end of the line...\n    if (repeat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    if (repeat_count > 0)\n      papplDevicePuts(device, \",\");\n  }\n  else\n    lprint_zpl_compress(device, repeat_char, repeat_count);\n\n#else\n  // Send uncompressed HEX data...\n  papplDeviceWrite(device, zpl->comp_buffer, compptr - zpl->comp_buffer);\n#endif // ZPL_COMPRESSION\n\n  // Save this line for the next round...\n  memcpy(zpl->last_buffer, zpl->dither.output, zpl->dither.out_width);\n  zpl->last_buffer_set = 1;\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 682,
    "end_line": 758,
    "code": "rint_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t// ZPL driver data\n  unsigned\t\ti;\t\t// Looping var\n  const unsigned char\t*ptr;\t\t// Pointer into buffer\n  unsigned char\t\t*compptr;\t// Pointer into compression buffer\n#if ZPL_COMPRESSION\n  unsigned char\t\trepeat_char;\t// Repeated character\n  unsigned\t\trepeat_count;\t// Number of repeated characters\n#endif // ZPL_COMPRESSION\n  static const unsigned char *hex = (const unsigned char *)\"0123456789ABCDEF\";\n\t\t\t\t\t// Hex digits\n\n\n  if (!lprintDitherLine(&zpl->dither, y, line))\n    return (true);\n\n  // Determine whether this row is the same as the previous line.\n  // If so, output a ':' and return...\n  if (zpl->last_buffer_set && !memcmp(zpl->dither.output, zpl->last_buffer, zpl->dither.out_width))\n  {\n    papplDeviceWrite(device, \":\", 1);\n    return (true);\n  }\n\n  // Convert the line to hex digits...\n  for (ptr = zpl->dither.output, compptr = zpl->comp_buffer, i = zpl->dither.out_width; i > 0; i --, ptr ++)\n  {\n    *compptr++ = hex[*ptr >> 4];\n    *compptr++ = hex[*ptr & 15];\n  }\n\n#if ZPL_COMPRESSION\n  // Send run-length compressed HEX data...\n  *compptr = '\\0';\n\n  // Run-length compress the graphics...\n  for (compptr = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *compptr; compptr ++)\n  {\n    if (*compptr == repeat_char)\n    {\n      repeat_count ++;\n    }\n    else\n    {\n      lprint_zpl_compress(device, repeat_char, repeat_count);\n      repeat_char  = *compptr;\n      repeat_count = 1;\n    }\n  }\n\n  if (repeat_char == '0')\n  {\n    // Handle 0's on the end of the line...\n    if (repeat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    if (repeat_count > 0)\n      papplDevicePuts(device, \",\");\n  }\n  else\n    lprint_zpl_compress(device, repeat_char, repeat_count);\n\n#else\n  // Send uncompressed HEX data...\n  papplDeviceWrite(device, zpl->comp_buffer, compptr - zpl->comp_buffer);\n#endif // ZPL_COMPRESSION\n\n  // Save this line for the next round...\n  memcpy(zpl->last_buffer, zpl->dither.output, zpl->dither.out_width);\n  zpl->last_buffer_set = 1;\n\n  return (true);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "global_variable",
    "start_line": 683,
    "end_line": 683,
    "code": "_zpl_t\t*zpl = (lprint_zpl_t *)papplJobGetData(job);\n\t\t\t\t\t",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "preprocessor",
    "start_line": 688,
    "end_line": 691,
    "code": "L_COMPRESSION\n  unsigned char\t\trepeat_char;\t// Repeated character\n  unsigned\t\trepeat_count;\t// Number of repeated characters\n#endif // ZP",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "global_variable",
    "start_line": 692,
    "end_line": 692,
    "code": " const unsigned char *hex = (const unsigned char *)\"0123456789ABCDEF\";\n\t\t\t\t\t",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 701,
    "end_line": 705,
    "code": "l->last_buffer_set && !memcmp(zpl->dither.output, zpl->last_buffer, zpl->dither.out_width))\n  {\n    papplDeviceWrite(device, \":\", 1);\n    return (true);\n  }\n\n  //",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 708,
    "end_line": 712,
    "code": "tr = zpl->dither.output, compptr = zpl->comp_buffer, i = zpl->dither.out_width; i > 0; i --, ptr ++)\n  {\n    *compptr++ = hex[*ptr >> 4];\n    *compptr++ = hex[*ptr & 15];\n  }\n\n#if ",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 708,
    "end_line": 708,
    "code": "zpl->dither.output, compptr = zpl->comp_buffer, i = zpl->dither.out_width; i > ",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 708,
    "end_line": 708,
    "code": "r = zpl->comp_buffer, i = zpl->dither.out_width; i > ",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "preprocessor",
    "start_line": 714,
    "end_line": 751,
    "code": "L_COMPRESSION\n  // Send run-length compressed HEX data...\n  *compptr = '\\0';\n\n  // Run-length compress the graphics...\n  for (compptr = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *compptr; compptr ++)\n  {\n    if (*compptr == repeat_char)\n    {\n      repeat_count ++;\n    }\n    else\n    {\n      lprint_zpl_compress(device, repeat_char, repeat_count);\n      repeat_char  = *compptr;\n      repeat_count = 1;\n    }\n  }\n\n  if (repeat_char == '0')\n  {\n    // Handle 0's on the end of the line...\n    if (repeat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    if (repeat_count > 0)\n      papplDevicePuts(device, \",\");\n  }\n  else\n    lprint_zpl_compress(device, repeat_char, repeat_count);\n\n#else\n  // Send uncompressed HEX data...\n  papplDeviceWrite(device, zpl->comp_buffer, compptr - zpl->comp_buffer);\n#endif // ZP",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 714,
    "end_line": 751,
    "code": "L_COMPRESSION\n  // Send run-length compressed HEX data...\n  *compptr = '\\0';\n\n  // Run-length compress the graphics...\n  for (compptr = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *compptr; compptr ++)\n  {\n    if (*compptr == repeat_char)\n    {\n      repeat_count ++;\n    }\n    else\n    {\n      lprint_zpl_compress(device, repeat_char, repeat_count);\n      repeat_char  = *compptr;\n      repeat_count = 1;\n    }\n  }\n\n  if (repeat_char == '0')\n  {\n    // Handle 0's on the end of the line...\n    if (repeat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    if (repeat_count > 0)\n      papplDevicePuts(device, \",\");\n  }\n  else\n    lprint_zpl_compress(device, repeat_char, repeat_count);\n\n#else\n  // Send uncompressed HEX data...\n  papplDeviceWrite(device, zpl->comp_buffer, compptr - zpl->comp_buffer);\n#endif // ZP",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 714,
    "end_line": 751,
    "code": "L_COMPRESSION\n  // Send run-length compressed HEX data...\n  *compptr = '\\0';\n\n  // Run-length compress the graphics...\n  for (compptr = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *compptr; compptr ++)\n  {\n    if (*compptr == repeat_char)\n    {\n      repeat_count ++;\n    }\n    else\n    {\n      lprint_zpl_compress(device, repeat_char, repeat_count);\n      repeat_char  = *compptr;\n      repeat_count = 1;\n    }\n  }\n\n  if (repeat_char == '0')\n  {\n    // Handle 0's on the end of the line...\n    if (repeat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    if (repeat_count > 0)\n      papplDevicePuts(device, \",\");\n  }\n  else\n    lprint_zpl_compress(device, repeat_char, repeat_count);\n\n#else\n  // Send uncompressed HEX data...\n  papplDeviceWrite(device, zpl->comp_buffer, compptr - zpl->comp_buffer);\n#endif // ZP",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 719,
    "end_line": 731,
    "code": "ompptr = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *compptr; compptr ++)\n  {\n    if (*compptr == repeat_char)\n    {\n      repeat_count ++;\n    }\n    else\n    {\n      lprint_zpl_compress(device, repeat_char, repeat_count);\n      repeat_char  = *compptr;\n      repeat_count = 1;\n    }\n  }\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function_assignment",
    "start_line": 719,
    "end_line": 731,
    "code": "ompptr = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *compptr; compptr ++)\n  {\n    if (*compptr == repeat_char)\n    {\n      repeat_count ++;\n    }\n    else\n    {\n      lprint_zpl_compress(device, repeat_char, repeat_count);\n      repeat_char  = *compptr;\n      repeat_count = 1;\n    }\n  }\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 719,
    "end_line": 719,
    "code": "r = zpl->comp_buffer + 1, repeat_char = zpl->comp_buffer[0], repeat_count = 1; *com",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 719,
    "end_line": 719,
    "code": "_char = zpl->comp_buffer[0], repeat_count = 1; *com",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 733,
    "end_line": 746,
    "code": "peat_char == '0')\n  {\n    // Handle 0's on the end of the line...\n    if (repeat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    if (repeat_count > 0)\n      papplDevicePuts(device, \",\");\n  }\n  else\n    lprint_zpl_compress(device, repeat_char, repeat_count);\n\n#els",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 734,
    "end_line": 744,
    "code": "// Handle 0's on the end of the line...\n    if (repeat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    if (repeat_count > 0)\n      papplDevicePuts(device, \",\");\n  }\n  els",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 736,
    "end_line": 740,
    "code": "peat_count & 1)\n    {\n      repeat_count --;\n      papplDevicePuts(device, \"0\");\n    }\n\n    ",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function",
    "start_line": 765,
    "end_line": 829,
    "name": "lprint_zpl_status",
    "parent": null,
    "hierarchy": "lprint_zpl_status",
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_status(\n    pappl_printer_t *printer)\t\t// I - Printer\n{\n  pappl_device_t\t*device;\t// Connection to printer\n  char\t\t\tline[1025];\t// Line from printer\n  ssize_t\t\tbytes;\t\t// Bytes read\n  int\t\t\tlength = 0;\t// Label length\n  bool\t\t\tret = false;\t// Return value\n\n\n  if ((device = papplPrinterOpenDevice(printer)) == NULL)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to open device for status.\");\n    return (false);\n  }\n\n  // Get the printer status...\n  if (!lprint_zpl_update_reasons(printer, NULL, device))\n    goto done;\n\n  // Query host status...\n  if (papplDevicePuts(device, \"~HS\\n\") < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to send HS status command.\");\n    goto done;\n  }\n\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to read HS status response.\");\n    goto done;\n  }\n\n  line[bytes] = '\\0';\n\n  papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"HS returned '%s'.\", line);\n\n  if (sscanf(line + 1, \"%*d,%*d,%*d,%d\", &length) == 1 && length > 11)\n  {\n    // Auto-detect label length for ready media...\n    pappl_pr_driver_data_t\tdata;\t// Driver data\n\n    papplPrinterGetDriverData(printer, &data);\n\n    // Round the length to the nearest dot and snap to the nearest 1/4\"...\n    length = (2540 * length + data.y_resolution[0] / 2) / data.y_resolution[0];\n\n    if ((length % 635) <= 100)\n      length += length % 635;\n    else if ((length % 635) >= 535)\n      length += 635 - (length % 635);\n\n    // Lookup size\n    lprintMediaMatch(printer, 0, 0, length);\n  }\n\n  ret = true;\n\n  done:\n\n  papplPrinterCloseDevice(printer);\n\n  return (ret);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 765,
    "end_line": 829,
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_status(\n    pappl_printer_t *printer)\t\t// I - Printer\n{\n  pappl_device_t\t*device;\t// Connection to printer\n  char\t\t\tline[1025];\t// Line from printer\n  ssize_t\t\tbytes;\t\t// Bytes read\n  int\t\t\tlength = 0;\t// Label length\n  bool\t\t\tret = false;\t// Return value\n\n\n  if ((device = papplPrinterOpenDevice(printer)) == NULL)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to open device for status.\");\n    return (false);\n  }\n\n  // Get the printer status...\n  if (!lprint_zpl_update_reasons(printer, NULL, device))\n    goto done;\n\n  // Query host status...\n  if (papplDevicePuts(device, \"~HS\\n\") < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to send HS status command.\");\n    goto done;\n  }\n\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to read HS status response.\");\n    goto done;\n  }\n\n  line[bytes] = '\\0';\n\n  papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"HS returned '%s'.\", line);\n\n  if (sscanf(line + 1, \"%*d,%*d,%*d,%d\", &length) == 1 && length > 11)\n  {\n    // Auto-detect label length for ready media...\n    pappl_pr_driver_data_t\tdata;\t// Driver data\n\n    papplPrinterGetDriverData(printer, &data);\n\n    // Round the length to the nearest dot and snap to the nearest 1/4\"...\n    length = (2540 * length + data.y_resolution[0] / 2) / data.y_resolution[0];\n\n    if ((length % 635) <= 100)\n      length += length % 635;\n    else if ((length % 635) >= 535)\n      length += 635 - (length % 635);\n\n    // Lookup size\n    lprintMediaMatch(printer, 0, 0, length);\n  }\n\n  ret = true;\n\n  done:\n\n  papplPrinterCloseDevice(printer);\n\n  return (ret);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 768,
    "end_line": 829,
    "code": "ppl_device_t\t*device;\t// Connection to printer\n  char\t\t\tline[1025];\t// Line from printer\n  ssize_t\t\tbytes;\t\t// Bytes read\n  int\t\t\tlength = 0;\t// Label length\n  bool\t\t\tret = false;\t// Return value\n\n\n  if ((device = papplPrinterOpenDevice(printer)) == NULL)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to open device for status.\");\n    return (false);\n  }\n\n  // Get the printer status...\n  if (!lprint_zpl_update_reasons(printer, NULL, device))\n    goto done;\n\n  // Query host status...\n  if (papplDevicePuts(device, \"~HS\\n\") < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to send HS status command.\");\n    goto done;\n  }\n\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to read HS status response.\");\n    goto done;\n  }\n\n  line[bytes] = '\\0';\n\n  papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"HS returned '%s'.\", line);\n\n  if (sscanf(line + 1, \"%*d,%*d,%*d,%d\", &length) == 1 && length > 11)\n  {\n    // Auto-detect label length for ready media...\n    pappl_pr_driver_data_t\tdata;\t// Driver data\n\n    papplPrinterGetDriverData(printer, &data);\n\n    // Round the length to the nearest dot and snap to the nearest 1/4\"...\n    length = (2540 * length + data.y_resolution[0] / 2) / data.y_resolution[0];\n\n    if ((length % 635) <= 100)\n      length += length % 635;\n    else if ((length % 635) >= 535)\n      length += 635 - (length % 635);\n\n    // Lookup size\n    lprintMediaMatch(printer, 0, 0, length);\n  }\n\n  ret = true;\n\n  done:\n\n  papplPrinterCloseDevice(printer);\n\n  return (ret);\n}\n\n\n//\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "global_variable",
    "start_line": 772,
    "end_line": 772,
    "code": "length = 0;\t// La",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "global_variable",
    "start_line": 773,
    "end_line": 773,
    "code": "\tret = false;\t// Re",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 776,
    "end_line": 780,
    "code": "evice = papplPrinterOpenDevice(printer)) == NULL)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to open device for status.\");\n    return (false);\n  }\n\n  //",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 787,
    "end_line": 791,
    "code": "pplDevicePuts(device, \"~HS\\n\") < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to send HS status command.\");\n    goto done;\n  }\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 793,
    "end_line": 797,
    "code": "ytes = papplDeviceRead(device, line, sizeof(line) - 1)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to read HS status response.\");\n    goto done;\n  }\n\n  li",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 803,
    "end_line": 820,
    "code": "canf(line + 1, \"%*d,%*d,%*d,%d\", &length) == 1 && length > 11)\n  {\n    // Auto-detect label length for ready media...\n    pappl_pr_driver_data_t\tdata;\t// Driver data\n\n    papplPrinterGetDriverData(printer, &data);\n\n    // Round the length to the nearest dot and snap to the nearest 1/4\"...\n    length = (2540 * length + data.y_resolution[0] / 2) / data.y_resolution[0];\n\n    if ((length % 635) <= 100)\n      length += length % 635;\n    else if ((length % 635) >= 535)\n      length += 635 - (length % 635);\n\n    // Lookup size\n    lprintMediaMatch(printer, 0, 0, length);\n  }\n\n  re",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 804,
    "end_line": 820,
    "code": "// Auto-detect label length for ready media...\n    pappl_pr_driver_data_t\tdata;\t// Driver data\n\n    papplPrinterGetDriverData(printer, &data);\n\n    // Round the length to the nearest dot and snap to the nearest 1/4\"...\n    length = (2540 * length + data.y_resolution[0] / 2) / data.y_resolution[0];\n\n    if ((length % 635) <= 100)\n      length += length % 635;\n    else if ((length % 635) >= 535)\n      length += 635 - (length % 635);\n\n    // Lookup size\n    lprintMediaMatch(printer, 0, 0, length);\n  }\n\n  re",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 811,
    "end_line": 811,
    "code": " = (2540 * length + data.y_resolution[0] / 2) / data.y_resolution[0];\n\n    ",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 811,
    "end_line": 811,
    "code": " = (2540 * length + data.y_resolution[0] / 2) / data.y_resolution[0];\n\n   ",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "function",
    "start_line": 836,
    "end_line": 962,
    "name": "lprint_zpl_update_reasons",
    "parent": null,
    "hierarchy": "lprint_zpl_update_reasons",
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_update_reasons(\n    pappl_printer_t *printer,\t\t// I - Printer\n    pappl_job_t     *job,\t\t// I - Current job or `NULL` if none\n    pappl_device_t  *device)\t\t// I - Connection to device\n{\n  char\t\t\tline[1025],\t// Line from printer\n\t\t\t*lineptr;\t// Pointer into line\n  ssize_t\t\tbytes;\t\t// Bytes read\n  unsigned\t\terrors = 0,\t// Detected errors\n\t\t\twarnings = 0;\t// Detected warnings\n  pappl_preason_t\treasons;\t// \"printer-state-reasons\" values\n\n\n  // Get the printer status...\n  if (papplDevicePuts(device, \"~HQES\\n\") < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to send HQES status command.\");\n    return (false);\n  }\n\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to read HQES status response.\");\n    return (false);\n  }\n\n  line[bytes] = '\\0';\n\n  papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"HQES returned '%s'.\", line);\n\n  if ((lineptr = strstr(line, \"ERRORS:\")) != NULL)\n  {\n    if (sscanf(lineptr + 7, \"%*d%*x%x\", &errors) != 1)\n      errors = 0;\n  }\n\n  if ((lineptr = strstr(line, \"WARNINGS:\")) != NULL)\n  {\n    if (sscanf(lineptr + 9, \"%*d%*x%x\", &warnings) != 1)\n      warnings = 0;\n  }\n\n  reasons = PAPPL_PREASON_NONE;\n\n  if (errors & ZPL_ERROR_MEDIA_OUT)\n    reasons |= PAPPL_PREASON_MEDIA_EMPTY;\n\n  if (errors & ZPL_ERROR_PAPER_JAM)\n    reasons |= PAPPL_PREASON_MEDIA_JAM;\n\n  if (errors & ZPL_ERROR_PAUSED)\n    reasons |= PAPPL_PREASON_OFFLINE;\n\n  if (errors & ZPL_ERROR_RIBBON_OUT)\n    reasons |= PAPPL_PREASON_MARKER_SUPPLY_EMPTY;\n\n  if (errors & ~(ZPL_ERROR_MEDIA_OUT | ZPL_ERROR_PAPER_JAM | ZPL_ERROR_PAUSED))\n  {\n    reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_ERROR_HEAD_OPEN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Print head open.\");\n    if (errors & ZPL_ERROR_CUTTER_FAULT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Cutter fault.\");\n    if (errors & ZPL_ERROR_CLEAR_PP_FAILED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Clear paper path failed.\");\n    if (errors & ZPL_ERROR_PAPER_FEED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Paper feed error.\");\n    if (errors & ZPL_ERROR_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Presenter error.\");\n    if (errors & ZPL_ERROR_MARK_NOT_FOUND)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark not found.\");\n    if (errors & ZPL_ERROR_MARK_CALIBRATE)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark calibration error.\");\n    if (errors & ZPL_ERROR_RETRACT_TIMEOUT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Retraction timeout.\");\n  }\n\n  if (warnings & ZPL_WARNING_PAPER_ALMOST_OUT)\n    reasons |= PAPPL_PREASON_MEDIA_LOW;\n\n  if (warnings & ~ZPL_WARNING_PAPER_ALMOST_OUT)\n  {\n    reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_WARNING_REPLACE_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Replace print head.\");\n\n    if (errors & ZPL_WARNING_CLEAN_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Clean print head.\");\n\n    if (errors & ZPL_WARNING_CALIBRATE_MEDIA)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Calibrate media.\");\n\n    if (errors & ZPL_WARNING_PAPER_BEFORE_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper before head.\");\n\n    if (errors & ZPL_WARNING_BLACK_MARK)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Black mark.\");\n\n    if (errors & ZPL_WARNING_PAPER_AFTER_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper after head.\");\n\n    if (errors & ZPL_WARNING_LOOP_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Loop ready.\");\n\n    if (errors & ZPL_WARNING_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Presenter.\");\n\n    if (errors & ZPL_WARNING_RETRACT_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Retract ready.\");\n\n    if (errors & ZPL_WARNING_IN_RETRACT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"In retract.\");\n\n    if (errors & ZPL_WARNING_AT_BIN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"At bin.\");\n  }\n\n  if (job && (reasons & PAPPL_PREASON_MEDIA_EMPTY))\n    reasons |= PAPPL_PREASON_MEDIA_NEEDED;\n\n  papplPrinterSetReasons(printer, reasons, ~reasons);\n\n  return (true);\n}\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 836,
    "end_line": 962,
    "code": " bool\t\t\t\t// O - `true` on success, `false` on failure\nlprint_zpl_update_reasons(\n    pappl_printer_t *printer,\t\t// I - Printer\n    pappl_job_t     *job,\t\t// I - Current job or `NULL` if none\n    pappl_device_t  *device)\t\t// I - Connection to device\n{\n  char\t\t\tline[1025],\t// Line from printer\n\t\t\t*lineptr;\t// Pointer into line\n  ssize_t\t\tbytes;\t\t// Bytes read\n  unsigned\t\terrors = 0,\t// Detected errors\n\t\t\twarnings = 0;\t// Detected warnings\n  pappl_preason_t\treasons;\t// \"printer-state-reasons\" values\n\n\n  // Get the printer status...\n  if (papplDevicePuts(device, \"~HQES\\n\") < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to send HQES status command.\");\n    return (false);\n  }\n\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to read HQES status response.\");\n    return (false);\n  }\n\n  line[bytes] = '\\0';\n\n  papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"HQES returned '%s'.\", line);\n\n  if ((lineptr = strstr(line, \"ERRORS:\")) != NULL)\n  {\n    if (sscanf(lineptr + 7, \"%*d%*x%x\", &errors) != 1)\n      errors = 0;\n  }\n\n  if ((lineptr = strstr(line, \"WARNINGS:\")) != NULL)\n  {\n    if (sscanf(lineptr + 9, \"%*d%*x%x\", &warnings) != 1)\n      warnings = 0;\n  }\n\n  reasons = PAPPL_PREASON_NONE;\n\n  if (errors & ZPL_ERROR_MEDIA_OUT)\n    reasons |= PAPPL_PREASON_MEDIA_EMPTY;\n\n  if (errors & ZPL_ERROR_PAPER_JAM)\n    reasons |= PAPPL_PREASON_MEDIA_JAM;\n\n  if (errors & ZPL_ERROR_PAUSED)\n    reasons |= PAPPL_PREASON_OFFLINE;\n\n  if (errors & ZPL_ERROR_RIBBON_OUT)\n    reasons |= PAPPL_PREASON_MARKER_SUPPLY_EMPTY;\n\n  if (errors & ~(ZPL_ERROR_MEDIA_OUT | ZPL_ERROR_PAPER_JAM | ZPL_ERROR_PAUSED))\n  {\n    reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_ERROR_HEAD_OPEN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Print head open.\");\n    if (errors & ZPL_ERROR_CUTTER_FAULT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Cutter fault.\");\n    if (errors & ZPL_ERROR_CLEAR_PP_FAILED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Clear paper path failed.\");\n    if (errors & ZPL_ERROR_PAPER_FEED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Paper feed error.\");\n    if (errors & ZPL_ERROR_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Presenter error.\");\n    if (errors & ZPL_ERROR_MARK_NOT_FOUND)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark not found.\");\n    if (errors & ZPL_ERROR_MARK_CALIBRATE)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark calibration error.\");\n    if (errors & ZPL_ERROR_RETRACT_TIMEOUT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Retraction timeout.\");\n  }\n\n  if (warnings & ZPL_WARNING_PAPER_ALMOST_OUT)\n    reasons |= PAPPL_PREASON_MEDIA_LOW;\n\n  if (warnings & ~ZPL_WARNING_PAPER_ALMOST_OUT)\n  {\n    reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_WARNING_REPLACE_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Replace print head.\");\n\n    if (errors & ZPL_WARNING_CLEAN_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Clean print head.\");\n\n    if (errors & ZPL_WARNING_CALIBRATE_MEDIA)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Calibrate media.\");\n\n    if (errors & ZPL_WARNING_PAPER_BEFORE_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper before head.\");\n\n    if (errors & ZPL_WARNING_BLACK_MARK)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Black mark.\");\n\n    if (errors & ZPL_WARNING_PAPER_AFTER_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper after head.\");\n\n    if (errors & ZPL_WARNING_LOOP_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Loop ready.\");\n\n    if (errors & ZPL_WARNING_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Presenter.\");\n\n    if (errors & ZPL_WARNING_RETRACT_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Retract ready.\");\n\n    if (errors & ZPL_WARNING_IN_RETRACT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"In retract.\");\n\n    if (errors & ZPL_WARNING_AT_BIN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"At bin.\");\n  }\n\n  if (job && (reasons & PAPPL_PREASON_MEDIA_EMPTY))\n    reasons |= PAPPL_PREASON_MEDIA_NEEDED;\n\n  papplPrinterSetReasons(printer, reasons, ~reasons);\n\n  return (true);\n}\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 841,
    "end_line": 962,
    "code": "ar\t\t\tline[1025],\t// Line from printer\n\t\t\t*lineptr;\t// Pointer into line\n  ssize_t\t\tbytes;\t\t// Bytes read\n  unsigned\t\terrors = 0,\t// Detected errors\n\t\t\twarnings = 0;\t// Detected warnings\n  pappl_preason_t\treasons;\t// \"printer-state-reasons\" values\n\n\n  // Get the printer status...\n  if (papplDevicePuts(device, \"~HQES\\n\") < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to send HQES status command.\");\n    return (false);\n  }\n\n  if ((bytes = papplDeviceRead(device, line, sizeof(line) - 1)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to read HQES status response.\");\n    return (false);\n  }\n\n  line[bytes] = '\\0';\n\n  papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"HQES returned '%s'.\", line);\n\n  if ((lineptr = strstr(line, \"ERRORS:\")) != NULL)\n  {\n    if (sscanf(lineptr + 7, \"%*d%*x%x\", &errors) != 1)\n      errors = 0;\n  }\n\n  if ((lineptr = strstr(line, \"WARNINGS:\")) != NULL)\n  {\n    if (sscanf(lineptr + 9, \"%*d%*x%x\", &warnings) != 1)\n      warnings = 0;\n  }\n\n  reasons = PAPPL_PREASON_NONE;\n\n  if (errors & ZPL_ERROR_MEDIA_OUT)\n    reasons |= PAPPL_PREASON_MEDIA_EMPTY;\n\n  if (errors & ZPL_ERROR_PAPER_JAM)\n    reasons |= PAPPL_PREASON_MEDIA_JAM;\n\n  if (errors & ZPL_ERROR_PAUSED)\n    reasons |= PAPPL_PREASON_OFFLINE;\n\n  if (errors & ZPL_ERROR_RIBBON_OUT)\n    reasons |= PAPPL_PREASON_MARKER_SUPPLY_EMPTY;\n\n  if (errors & ~(ZPL_ERROR_MEDIA_OUT | ZPL_ERROR_PAPER_JAM | ZPL_ERROR_PAUSED))\n  {\n    reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_ERROR_HEAD_OPEN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Print head open.\");\n    if (errors & ZPL_ERROR_CUTTER_FAULT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Cutter fault.\");\n    if (errors & ZPL_ERROR_CLEAR_PP_FAILED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Clear paper path failed.\");\n    if (errors & ZPL_ERROR_PAPER_FEED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Paper feed error.\");\n    if (errors & ZPL_ERROR_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Presenter error.\");\n    if (errors & ZPL_ERROR_MARK_NOT_FOUND)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark not found.\");\n    if (errors & ZPL_ERROR_MARK_CALIBRATE)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark calibration error.\");\n    if (errors & ZPL_ERROR_RETRACT_TIMEOUT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Retraction timeout.\");\n  }\n\n  if (warnings & ZPL_WARNING_PAPER_ALMOST_OUT)\n    reasons |= PAPPL_PREASON_MEDIA_LOW;\n\n  if (warnings & ~ZPL_WARNING_PAPER_ALMOST_OUT)\n  {\n    reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_WARNING_REPLACE_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Replace print head.\");\n\n    if (errors & ZPL_WARNING_CLEAN_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Clean print head.\");\n\n    if (errors & ZPL_WARNING_CALIBRATE_MEDIA)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Calibrate media.\");\n\n    if (errors & ZPL_WARNING_PAPER_BEFORE_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper before head.\");\n\n    if (errors & ZPL_WARNING_BLACK_MARK)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Black mark.\");\n\n    if (errors & ZPL_WARNING_PAPER_AFTER_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper after head.\");\n\n    if (errors & ZPL_WARNING_LOOP_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Loop ready.\");\n\n    if (errors & ZPL_WARNING_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Presenter.\");\n\n    if (errors & ZPL_WARNING_RETRACT_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Retract ready.\");\n\n    if (errors & ZPL_WARNING_IN_RETRACT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"In retract.\");\n\n    if (errors & ZPL_WARNING_AT_BIN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"At bin.\");\n  }\n\n  if (job && (reasons & PAPPL_PREASON_MEDIA_EMPTY))\n    reasons |= PAPPL_PREASON_MEDIA_NEEDED;\n\n  papplPrinterSetReasons(printer, reasons, ~reasons);\n\n  return (true);\n}\n",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "global_variable",
    "start_line": 845,
    "end_line": 846,
    "code": "ed\t\terrors = 0,\t// Detected errors\n\t\t\twarnings = 0;\t// De",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 851,
    "end_line": 855,
    "code": "pplDevicePuts(device, \"~HQES\\n\") < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to send HQES status command.\");\n    return (false);\n  }\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 857,
    "end_line": 861,
    "code": "ytes = papplDeviceRead(device, line, sizeof(line) - 1)) < 0)\n  {\n    papplLogPrinter(printer, PAPPL_LOGLEVEL_DEBUG, \"Unable to read HQES status response.\");\n    return (false);\n  }\n\n  li",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 893,
    "end_line": 913,
    "code": "rors & ~(ZPL_ERROR_MEDIA_OUT | ZPL_ERROR_PAPER_JAM | ZPL_ERROR_PAUSED))\n  {\n    reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_ERROR_HEAD_OPEN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Print head open.\");\n    if (errors & ZPL_ERROR_CUTTER_FAULT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Cutter fault.\");\n    if (errors & ZPL_ERROR_CLEAR_PP_FAILED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Clear paper path failed.\");\n    if (errors & ZPL_ERROR_PAPER_FEED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Paper feed error.\");\n    if (errors & ZPL_ERROR_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Presenter error.\");\n    if (errors & ZPL_ERROR_MARK_NOT_FOUND)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark not found.\");\n    if (errors & ZPL_ERROR_MARK_CALIBRATE)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark calibration error.\");\n    if (errors & ZPL_ERROR_RETRACT_TIMEOUT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Retraction timeout.\");\n  }\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 894,
    "end_line": 913,
    "code": "reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_ERROR_HEAD_OPEN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Print head open.\");\n    if (errors & ZPL_ERROR_CUTTER_FAULT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Cutter fault.\");\n    if (errors & ZPL_ERROR_CLEAR_PP_FAILED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Clear paper path failed.\");\n    if (errors & ZPL_ERROR_PAPER_FEED)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Paper feed error.\");\n    if (errors & ZPL_ERROR_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Presenter error.\");\n    if (errors & ZPL_ERROR_MARK_NOT_FOUND)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark not found.\");\n    if (errors & ZPL_ERROR_MARK_CALIBRATE)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Mark calibration error.\");\n    if (errors & ZPL_ERROR_RETRACT_TIMEOUT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_ERROR, \"Retraction timeout.\");\n  }\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 918,
    "end_line": 954,
    "code": "rnings & ~ZPL_WARNING_PAPER_ALMOST_OUT)\n  {\n    reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_WARNING_REPLACE_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Replace print head.\");\n\n    if (errors & ZPL_WARNING_CLEAN_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Clean print head.\");\n\n    if (errors & ZPL_WARNING_CALIBRATE_MEDIA)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Calibrate media.\");\n\n    if (errors & ZPL_WARNING_PAPER_BEFORE_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper before head.\");\n\n    if (errors & ZPL_WARNING_BLACK_MARK)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Black mark.\");\n\n    if (errors & ZPL_WARNING_PAPER_AFTER_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper after head.\");\n\n    if (errors & ZPL_WARNING_LOOP_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Loop ready.\");\n\n    if (errors & ZPL_WARNING_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Presenter.\");\n\n    if (errors & ZPL_WARNING_RETRACT_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Retract ready.\");\n\n    if (errors & ZPL_WARNING_IN_RETRACT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"In retract.\");\n\n    if (errors & ZPL_WARNING_AT_BIN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"At bin.\");\n  }\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 919,
    "end_line": 954,
    "code": "reasons |= PAPPL_PREASON_OTHER;\n\n    if (errors & ZPL_WARNING_REPLACE_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Replace print head.\");\n\n    if (errors & ZPL_WARNING_CLEAN_PRINTHEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Clean print head.\");\n\n    if (errors & ZPL_WARNING_CALIBRATE_MEDIA)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Calibrate media.\");\n\n    if (errors & ZPL_WARNING_PAPER_BEFORE_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper before head.\");\n\n    if (errors & ZPL_WARNING_BLACK_MARK)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Black mark.\");\n\n    if (errors & ZPL_WARNING_PAPER_AFTER_HEAD)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Paper after head.\");\n\n    if (errors & ZPL_WARNING_LOOP_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Loop ready.\");\n\n    if (errors & ZPL_WARNING_PRESENTER)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Presenter.\");\n\n    if (errors & ZPL_WARNING_RETRACT_READY)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"Retract ready.\");\n\n    if (errors & ZPL_WARNING_IN_RETRACT)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"In retract.\");\n\n    if (errors & ZPL_WARNING_AT_BIN)\n      papplLogPrinter(printer, PAPPL_LOGLEVEL_WARN, \"At bin.\");\n  }\n\n  if",
    "file": "data/codebase/lprint/lprint-zpl.c"
  }
]