[
  {
    "type": "struct_assignment",
    "start_line": 1,
    "end_line": 368,
    "code": "//\n// PackBits unit test program\n//\n// Usage:\n//\n//   ./testpackbits [COUNT]\n//\n// Copyright \u00a9 2024 by Michael R Sweet\n//\n\n#include \"lprint.h\"\n#include \"test.h\"\n\n\n//\n// Local types\n//\n\ntypedef struct testdata_s\n{\n  size_t\tinlen;\t\t\t// Length of input data\n  const char\t*input;\t\t\t// Input data\n  size_t\toutlen;\t\t\t// Length of output data\n  const char\t*output;\t\t// Output data\n} testdata_t;\n\n\n//\n// Local functions...\n//\n\nstatic unsigned get_rand(void);\nstatic size_t\tuncompress_packbits(unsigned char *dst, size_t dstsize, const unsigned char *src, size_t srclen);\n\n\n//\n// 'main()' - Main entry for test program.\n//\n\nint\t\t\t\t\t// O - Exit status\nmain(int  argc,\t\t\t\t// I - Number of command-line arguments\n     char *argv[])\t\t\t// I - Command-line arguments\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tnum_tests;\t\t// Number of tests to run\n  size_t\toffset,\t\t\t// Offset in source buffer\n\t\tcount,\t\t\t// Looping var\n\t\tlen;\t\t\t// Length of sequence\n  unsigned char\tsrc[1024],\t\t// Source buffer\n\t\tcheck[2048];\t\t// Check buffer\n  size_t\tchecklen;\t\t// Check data length\n  unsigned char\t*dst;\t\t\t// Destination buffer\n  size_t\tdstlen,\t\t\t// Number of destination bytes\n\t\tdstmax;\t\t\t// Maximum number of destination bytes\n  static testdata_t cases[] =\t\t// Test cases\n  {\n    {\n      1, \"a\", 2, \"\\000a\"\n    },\n    {\n      2, \"ab\", 3, \"\\001ab\"\n    },\n    {\n      3, \"abb\", 4, \"\\002abb\"\n    },\n    {\n      4, \"abbc\", 5, \"\\003abbc\"\n    },\n    {\n      5, \"abbcc\", 6, \"\\004abbcc\"\n    },\n    {\n      7, \"abbccdd\", 8, \"\\007abbccdd\"\n    },\n    {\n      9, \"abbbcccdd\", 8, \"\\000a\\376b\\376c\\377d\"\n    },\n    {\n     130, \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"ab\", 5, \"\\201a\\001ab\"\n    }\n  };\n\n\n  // See if the number of tests is on the command-line...\n  if (argc == 1)\n  {\n    num_tests = 1000000;\n  }\n  else if (argc > 2 || (num_tests = atoi(argv[1])) < 1)\n  {\n    fputs(\"Usage: ./testpackbits [COUNT]\\n\", stderr);\n    return (1);\n  }\n\n  // Maximum expansion as defined by the PackBits algorithm...\n  dstmax = sizeof(src) + sizeof(src) / 128;\n\n  // Allocate PackBits buffer\n  testBegin(\"lprintPackBitsAlloc(%u)\", (unsigned)(2 * sizeof(src)));\n  if ((dst = lprintPackBitsAlloc(2 * sizeof(src))) != NULL)\n    testEnd(true);\n  else\n    testEndMessage(false, \"%s\", strerror(errno));\n\n  // Test specific values\n  for (i = 0; i < (int)(sizeof(cases) / sizeof(cases[0])); i ++)\n  {\n    testBegin(\"lprintPackBitsCompress(\\\"%s\\\")\", cases[i].input);\n    if ((dstlen = lprintPackBitsCompress(dst, (unsigned char *)cases[i].input, cases[i].inlen)) == cases[i].outlen)\n    {\n      if (!memcmp(dst, cases[i].output, cases[i].outlen))\n        testEnd(true);\n      else\n\ttestEndMessage(true, \"alternate bytes OK\");\n    }\n    else\n    {\n      testEndMessage(false, \"got %u bytes, expected %u bytes\", (unsigned)dstlen, (unsigned)cases[i].outlen);\n      testError(\"\\nSource Buffer:\");\n      testHexDump((unsigned char *)cases[i].input, cases[i].inlen);\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      testError(\"\\nExpected Buffer:\");\n      testHexDump((unsigned char *)cases[i].output, cases[i].outlen);\n    }\n  }\n\n  // Loop many times with random changes to the source buffer to test different\n  // source values...\n  memset(src, 0, sizeof(src));\n\n  testBegin(\"lprintPackBitsCompress(%d times)\", num_tests);\n\n  for (i = 0; i < num_tests; i ++)\n  {\n    // Show progress...\n    testProgress();\n\n    // Make a random change to the source buffer...\n    len    = (get_rand() % (sizeof(src) / 4)) + 1;\n    offset = get_rand() % (sizeof(src) - len);\n\n    if (get_rand() & 1)\n    {\n      // Add random bytes\n      for (count = 0; count < len; count ++)\n        src[offset + count] = get_rand();\n    }\n    else\n    {\n      // Add constant bytes\n      memset(src + offset, get_rand(), len);\n    }\n\n    // Compress the result\n    if ((dstlen = lprintPackBitsCompress(dst, src, sizeof(src))) == 0 || dstlen > dstmax)\n    {\n      testEndMessage(false, \"%u > %u\", (unsigned)dstlen, (unsigned)dstmax);\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      break;\n    }\n\n    // Verify compressed result...\n    if ((checklen = uncompress_packbits(check, sizeof(check), dst, dstlen)) != sizeof(src) || memcmp(check, src, sizeof(src)))\n    {\n      testEndMessage(false, \"Decompression Failure\");\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer (%u bytes):\", (unsigned)dstlen);\n      testHexDump(dst, dstlen);\n      testError(\"\\nCheck Buffer (%u bytes):\", (unsigned)checklen);\n      testHexDump(check, checklen);\n      break;\n    }\n  }\n\n  if (i >= num_tests)\n    testEnd(true);\n\n  return (testsPassed ? 0 : 1);\n}\n\n\n//\n// 'get_rand()' - Return a 32-bit pseudo-random number.\n//\n// This function returns a 32-bit pseudo-random number suitable for use as\n// one-time identifiers or nonces.  The random numbers are generated/seeded\n// using system entropy.\n//\n\nstatic unsigned\t\t\t\t// O - Random number\nget_rand(void)\n{\n#if _WIN32\n  // rand_s uses real entropy...\n  unsigned v;\t\t\t\t// Random number\n\n\n  rand_s(&v);\n\n  return (v);\n\n#elif defined(__APPLE__)\n  // macOS/iOS arc4random() uses real entropy automatically...\n  return (arc4random());\n\n#else\n  // Use a Mersenne twister random number generator seeded from /dev/urandom...\n  unsigned\ti,\t\t\t// Looping var\n\t\ttemp;\t\t\t// Temporary value\n  static bool\tfirst_time = true;\t// First time we ran?\n  static unsigned mt_state[624],\t// Mersenne twister state\n\t\tmt_index;\t\t// Mersenne twister index\n\n\n  if (first_time)\n  {\n    int\t\tfd;\t\t\t// \"/dev/urandom\" file\n    struct timeval curtime;\t\t// Current time\n\n    // Seed the random number state...\n    if ((fd = open(\"/dev/urandom\", O_RDONLY)) >= 0)\n    {\n      // Read random entropy from the system...\n      if (read(fd, mt_state, sizeof(mt_state[0])) < sizeof(mt_state[0]))\n        mt_state[0] = 0;\t\t// Force fallback...\n\n      close(fd);\n    }\n    else\n      mt_state[0] = 0;\n\n    if (!mt_state[0])\n    {\n      // Fallback to using the current time in microseconds...\n      gettimeofday(&curtime, NULL);\n      mt_state[0] = (unsigned)(curtime.tv_sec + curtime.tv_usec);\n    }\n\n    mt_index = 0;\n\n    for (i = 1; i < 624; i ++)\n      mt_state[i] = (unsigned)((1812433253 * (mt_state[i - 1] ^ (mt_state[i - 1] >> 30))) + i);\n\n    first_time = false;\n  }\n\n  if (mt_index == 0)\n  {\n    // Generate a sequence of random numbers...\n    unsigned i1 = 1, i397 = 397;\t// Looping vars\n\n    for (i = 0; i < 624; i ++)\n    {\n      temp        = (mt_state[i] & 0x80000000) + (mt_state[i1] & 0x7fffffff);\n      mt_state[i] = mt_state[i397] ^ (temp >> 1);\n\n      if (temp & 1)\n\tmt_state[i] ^= 2567483615u;\n\n      i1 ++;\n      i397 ++;\n\n      if (i1 == 624)\n\ti1 = 0;\n\n      if (i397 == 624)\n\ti397 = 0;\n    }\n  }\n\n  // Pull 32-bits of random data...\n  temp = mt_state[mt_index ++];\n  temp ^= temp >> 11;\n  temp ^= (temp << 7) & 2636928640u;\n  temp ^= (temp << 15) & 4022730752u;\n  temp ^= temp >> 18;\n\n  if (mt_index == 624)\n    mt_index = 0;\n\n  return (temp);\n#endif // _WIN32\n}\n\n\n//\n// 'uncompress_packbits()' - Uncompress PackBits data.\n//\n\nstatic size_t\t\t\t\t// O - Number of uncompressed bytes\nuncompress_packbits(\n    unsigned char       *dst,\t\t// I - Output buffer\n    size_t              dstsize,\t// I - Size of output buffer\n    const unsigned char *src,\t\t// I - Input buffer\n    size_t              srclen)\t\t// I - Length of input buffer\n{\n  const unsigned char\t*srcptr,\t// Pointer into input buffer\n\t\t\t*srcend;\t// End of input buffer\n  unsigned char\t\t*dstptr,\t// Pointer into output buffer\n\t\t\t*dstend;\t// End of output buffer\n  unsigned\t\tcount;\t\t// Literal/repeat count\n\n\n  // Loop through the input buffer and decompress...\n  dstptr = dst;\n  dstend = dst + dstsize;\n  srcptr = src;\n  srcend = src + srclen;\n\n  while (srcptr < srcend)\n  {\n    if (*srcptr < 0x80)\n    {\n      // N literal bytes\n      count = *srcptr + 1;\n      srcptr ++;\n      if ((srcptr + count) > srcend)\n      {\n        testError(\"Literal count %u but only %ld input bytes remaining.\", count, srcend - srcptr);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Literal count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memcpy(dstptr, srcptr, count);\n      dstptr += count;\n      srcptr += count;\n    }\n    else if (*srcptr == 0x80)\n    {\n      testError(\"Undefined pack value 0x80 seen.\");\n    }\n    else\n    {\n      count = 257 - *srcptr;\n      srcptr ++;\n\n      if (srcptr >= srcend)\n      {\n        testError(\"Repeat count %u but no input bytes remaining.\", count);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Repeat count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memset(dstptr, *srcptr, count);\n      dstptr += count;\n      srcptr ++;\n    }\n  }\n\n  return ((size_t)(dstptr - dst));\n}",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 1,
    "end_line": 368,
    "code": "//\n// PackBits unit test program\n//\n// Usage:\n//\n//   ./testpackbits [COUNT]\n//\n// Copyright \u00a9 2024 by Michael R Sweet\n//\n\n#include \"lprint.h\"\n#include \"test.h\"\n\n\n//\n// Local types\n//\n\ntypedef struct testdata_s\n{\n  size_t\tinlen;\t\t\t// Length of input data\n  const char\t*input;\t\t\t// Input data\n  size_t\toutlen;\t\t\t// Length of output data\n  const char\t*output;\t\t// Output data\n} testdata_t;\n\n\n//\n// Local functions...\n//\n\nstatic unsigned get_rand(void);\nstatic size_t\tuncompress_packbits(unsigned char *dst, size_t dstsize, const unsigned char *src, size_t srclen);\n\n\n//\n// 'main()' - Main entry for test program.\n//\n\nint\t\t\t\t\t// O - Exit status\nmain(int  argc,\t\t\t\t// I - Number of command-line arguments\n     char *argv[])\t\t\t// I - Command-line arguments\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tnum_tests;\t\t// Number of tests to run\n  size_t\toffset,\t\t\t// Offset in source buffer\n\t\tcount,\t\t\t// Looping var\n\t\tlen;\t\t\t// Length of sequence\n  unsigned char\tsrc[1024],\t\t// Source buffer\n\t\tcheck[2048];\t\t// Check buffer\n  size_t\tchecklen;\t\t// Check data length\n  unsigned char\t*dst;\t\t\t// Destination buffer\n  size_t\tdstlen,\t\t\t// Number of destination bytes\n\t\tdstmax;\t\t\t// Maximum number of destination bytes\n  static testdata_t cases[] =\t\t// Test cases\n  {\n    {\n      1, \"a\", 2, \"\\000a\"\n    },\n    {\n      2, \"ab\", 3, \"\\001ab\"\n    },\n    {\n      3, \"abb\", 4, \"\\002abb\"\n    },\n    {\n      4, \"abbc\", 5, \"\\003abbc\"\n    },\n    {\n      5, \"abbcc\", 6, \"\\004abbcc\"\n    },\n    {\n      7, \"abbccdd\", 8, \"\\007abbccdd\"\n    },\n    {\n      9, \"abbbcccdd\", 8, \"\\000a\\376b\\376c\\377d\"\n    },\n    {\n     130, \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"ab\", 5, \"\\201a\\001ab\"\n    }\n  };\n\n\n  // See if the number of tests is on the command-line...\n  if (argc == 1)\n  {\n    num_tests = 1000000;\n  }\n  else if (argc > 2 || (num_tests = atoi(argv[1])) < 1)\n  {\n    fputs(\"Usage: ./testpackbits [COUNT]\\n\", stderr);\n    return (1);\n  }\n\n  // Maximum expansion as defined by the PackBits algorithm...\n  dstmax = sizeof(src) + sizeof(src) / 128;\n\n  // Allocate PackBits buffer\n  testBegin(\"lprintPackBitsAlloc(%u)\", (unsigned)(2 * sizeof(src)));\n  if ((dst = lprintPackBitsAlloc(2 * sizeof(src))) != NULL)\n    testEnd(true);\n  else\n    testEndMessage(false, \"%s\", strerror(errno));\n\n  // Test specific values\n  for (i = 0; i < (int)(sizeof(cases) / sizeof(cases[0])); i ++)\n  {\n    testBegin(\"lprintPackBitsCompress(\\\"%s\\\")\", cases[i].input);\n    if ((dstlen = lprintPackBitsCompress(dst, (unsigned char *)cases[i].input, cases[i].inlen)) == cases[i].outlen)\n    {\n      if (!memcmp(dst, cases[i].output, cases[i].outlen))\n        testEnd(true);\n      else\n\ttestEndMessage(true, \"alternate bytes OK\");\n    }\n    else\n    {\n      testEndMessage(false, \"got %u bytes, expected %u bytes\", (unsigned)dstlen, (unsigned)cases[i].outlen);\n      testError(\"\\nSource Buffer:\");\n      testHexDump((unsigned char *)cases[i].input, cases[i].inlen);\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      testError(\"\\nExpected Buffer:\");\n      testHexDump((unsigned char *)cases[i].output, cases[i].outlen);\n    }\n  }\n\n  // Loop many times with random changes to the source buffer to test different\n  // source values...\n  memset(src, 0, sizeof(src));\n\n  testBegin(\"lprintPackBitsCompress(%d times)\", num_tests);\n\n  for (i = 0; i < num_tests; i ++)\n  {\n    // Show progress...\n    testProgress();\n\n    // Make a random change to the source buffer...\n    len    = (get_rand() % (sizeof(src) / 4)) + 1;\n    offset = get_rand() % (sizeof(src) - len);\n\n    if (get_rand() & 1)\n    {\n      // Add random bytes\n      for (count = 0; count < len; count ++)\n        src[offset + count] = get_rand();\n    }\n    else\n    {\n      // Add constant bytes\n      memset(src + offset, get_rand(), len);\n    }\n\n    // Compress the result\n    if ((dstlen = lprintPackBitsCompress(dst, src, sizeof(src))) == 0 || dstlen > dstmax)\n    {\n      testEndMessage(false, \"%u > %u\", (unsigned)dstlen, (unsigned)dstmax);\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      break;\n    }\n\n    // Verify compressed result...\n    if ((checklen = uncompress_packbits(check, sizeof(check), dst, dstlen)) != sizeof(src) || memcmp(check, src, sizeof(src)))\n    {\n      testEndMessage(false, \"Decompression Failure\");\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer (%u bytes):\", (unsigned)dstlen);\n      testHexDump(dst, dstlen);\n      testError(\"\\nCheck Buffer (%u bytes):\", (unsigned)checklen);\n      testHexDump(check, checklen);\n      break;\n    }\n  }\n\n  if (i >= num_tests)\n    testEnd(true);\n\n  return (testsPassed ? 0 : 1);\n}\n\n\n//\n// 'get_rand()' - Return a 32-bit pseudo-random number.\n//\n// This function returns a 32-bit pseudo-random number suitable for use as\n// one-time identifiers or nonces.  The random numbers are generated/seeded\n// using system entropy.\n//\n\nstatic unsigned\t\t\t\t// O - Random number\nget_rand(void)\n{\n#if _WIN32\n  // rand_s uses real entropy...\n  unsigned v;\t\t\t\t// Random number\n\n\n  rand_s(&v);\n\n  return (v);\n\n#elif defined(__APPLE__)\n  // macOS/iOS arc4random() uses real entropy automatically...\n  return (arc4random());\n\n#else\n  // Use a Mersenne twister random number generator seeded from /dev/urandom...\n  unsigned\ti,\t\t\t// Looping var\n\t\ttemp;\t\t\t// Temporary value\n  static bool\tfirst_time = true;\t// First time we ran?\n  static unsigned mt_state[624],\t// Mersenne twister state\n\t\tmt_index;\t\t// Mersenne twister index\n\n\n  if (first_time)\n  {\n    int\t\tfd;\t\t\t// \"/dev/urandom\" file\n    struct timeval curtime;\t\t// Current time\n\n    // Seed the random number state...\n    if ((fd = open(\"/dev/urandom\", O_RDONLY)) >= 0)\n    {\n      // Read random entropy from the system...\n      if (read(fd, mt_state, sizeof(mt_state[0])) < sizeof(mt_state[0]))\n        mt_state[0] = 0;\t\t// Force fallback...\n\n      close(fd);\n    }\n    else\n      mt_state[0] = 0;\n\n    if (!mt_state[0])\n    {\n      // Fallback to using the current time in microseconds...\n      gettimeofday(&curtime, NULL);\n      mt_state[0] = (unsigned)(curtime.tv_sec + curtime.tv_usec);\n    }\n\n    mt_index = 0;\n\n    for (i = 1; i < 624; i ++)\n      mt_state[i] = (unsigned)((1812433253 * (mt_state[i - 1] ^ (mt_state[i - 1] >> 30))) + i);\n\n    first_time = false;\n  }\n\n  if (mt_index == 0)\n  {\n    // Generate a sequence of random numbers...\n    unsigned i1 = 1, i397 = 397;\t// Looping vars\n\n    for (i = 0; i < 624; i ++)\n    {\n      temp        = (mt_state[i] & 0x80000000) + (mt_state[i1] & 0x7fffffff);\n      mt_state[i] = mt_state[i397] ^ (temp >> 1);\n\n      if (temp & 1)\n\tmt_state[i] ^= 2567483615u;\n\n      i1 ++;\n      i397 ++;\n\n      if (i1 == 624)\n\ti1 = 0;\n\n      if (i397 == 624)\n\ti397 = 0;\n    }\n  }\n\n  // Pull 32-bits of random data...\n  temp = mt_state[mt_index ++];\n  temp ^= temp >> 11;\n  temp ^= (temp << 7) & 2636928640u;\n  temp ^= (temp << 15) & 4022730752u;\n  temp ^= temp >> 18;\n\n  if (mt_index == 624)\n    mt_index = 0;\n\n  return (temp);\n#endif // _WIN32\n}\n\n\n//\n// 'uncompress_packbits()' - Uncompress PackBits data.\n//\n\nstatic size_t\t\t\t\t// O - Number of uncompressed bytes\nuncompress_packbits(\n    unsigned char       *dst,\t\t// I - Output buffer\n    size_t              dstsize,\t// I - Size of output buffer\n    const unsigned char *src,\t\t// I - Input buffer\n    size_t              srclen)\t\t// I - Length of input buffer\n{\n  const unsigned char\t*srcptr,\t// Pointer into input buffer\n\t\t\t*srcend;\t// End of input buffer\n  unsigned char\t\t*dstptr,\t// Pointer into output buffer\n\t\t\t*dstend;\t// End of output buffer\n  unsigned\t\tcount;\t\t// Literal/repeat count\n\n\n  // Loop through the input buffer and decompress...\n  dstptr = dst;\n  dstend = dst + dstsize;\n  srcptr = src;\n  srcend = src + srclen;\n\n  while (srcptr < srcend)\n  {\n    if (*srcptr < 0x80)\n    {\n      // N literal bytes\n      count = *srcptr + 1;\n      srcptr ++;\n      if ((srcptr + count) > srcend)\n      {\n        testError(\"Literal count %u but only %ld input bytes remaining.\", count, srcend - srcptr);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Literal count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memcpy(dstptr, srcptr, count);\n      dstptr += count;\n      srcptr += count;\n    }\n    else if (*srcptr == 0x80)\n    {\n      testError(\"Undefined pack value 0x80 seen.\");\n    }\n    else\n    {\n      count = 257 - *srcptr;\n      srcptr ++;\n\n      if (srcptr >= srcend)\n      {\n        testError(\"Repeat count %u but no input bytes remaining.\", count);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Repeat count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memset(dstptr, *srcptr, count);\n      dstptr += count;\n      srcptr ++;\n    }\n  }\n\n  return ((size_t)(dstptr - dst));\n}",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "include",
    "start_line": 11,
    "end_line": 12,
    "code": "include \"lprint.h\"\n#",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "include",
    "start_line": 12,
    "end_line": 13,
    "code": "include \"test.h\"\n\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "typedef",
    "start_line": 19,
    "end_line": 25,
    "code": "ypedef struct testdata_s\n{\n  size_t\tinlen;\t\t\t// Length of input data\n  const char\t*input;\t\t\t// Input data\n  size_t\toutlen;\t\t\t// Length of output data\n  const char\t*output;\t\t// Output data\n} testdata_t;\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct",
    "name": "testdata_s",
    "hierarchy": "testdata_s",
    "start_line": 19,
    "end_line": 25,
    "code": "truct testdata_s\n{\n  size_t\tinlen;\t\t\t// Length of input data\n  const char\t*input;\t\t\t// Input data\n  size_t\toutlen;\t\t\t// Length of output data\n  const char\t*output;\t\t// Output data\n} ",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "function_prototype",
    "start_line": 32,
    "end_line": 32,
    "code": "et_rand(void);",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "function_prototype",
    "start_line": 33,
    "end_line": 33,
    "code": "ncompress_packbits(unsigned char *dst, size_t dstsize, const unsigned char *src, size_t srclen);",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "function",
    "start_line": 40,
    "end_line": 186,
    "name": "main",
    "parent": null,
    "hierarchy": "main",
    "code": "nt\t\t\t\t\t// O - Exit status\nmain(int  argc,\t\t\t\t// I - Number of command-line arguments\n     char *argv[])\t\t\t// I - Command-line arguments\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tnum_tests;\t\t// Number of tests to run\n  size_t\toffset,\t\t\t// Offset in source buffer\n\t\tcount,\t\t\t// Looping var\n\t\tlen;\t\t\t// Length of sequence\n  unsigned char\tsrc[1024],\t\t// Source buffer\n\t\tcheck[2048];\t\t// Check buffer\n  size_t\tchecklen;\t\t// Check data length\n  unsigned char\t*dst;\t\t\t// Destination buffer\n  size_t\tdstlen,\t\t\t// Number of destination bytes\n\t\tdstmax;\t\t\t// Maximum number of destination bytes\n  static testdata_t cases[] =\t\t// Test cases\n  {\n    {\n      1, \"a\", 2, \"\\000a\"\n    },\n    {\n      2, \"ab\", 3, \"\\001ab\"\n    },\n    {\n      3, \"abb\", 4, \"\\002abb\"\n    },\n    {\n      4, \"abbc\", 5, \"\\003abbc\"\n    },\n    {\n      5, \"abbcc\", 6, \"\\004abbcc\"\n    },\n    {\n      7, \"abbccdd\", 8, \"\\007abbccdd\"\n    },\n    {\n      9, \"abbbcccdd\", 8, \"\\000a\\376b\\376c\\377d\"\n    },\n    {\n     130, \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"ab\", 5, \"\\201a\\001ab\"\n    }\n  };\n\n\n  // See if the number of tests is on the command-line...\n  if (argc == 1)\n  {\n    num_tests = 1000000;\n  }\n  else if (argc > 2 || (num_tests = atoi(argv[1])) < 1)\n  {\n    fputs(\"Usage: ./testpackbits [COUNT]\\n\", stderr);\n    return (1);\n  }\n\n  // Maximum expansion as defined by the PackBits algorithm...\n  dstmax = sizeof(src) + sizeof(src) / 128;\n\n  // Allocate PackBits buffer\n  testBegin(\"lprintPackBitsAlloc(%u)\", (unsigned)(2 * sizeof(src)));\n  if ((dst = lprintPackBitsAlloc(2 * sizeof(src))) != NULL)\n    testEnd(true);\n  else\n    testEndMessage(false, \"%s\", strerror(errno));\n\n  // Test specific values\n  for (i = 0; i < (int)(sizeof(cases) / sizeof(cases[0])); i ++)\n  {\n    testBegin(\"lprintPackBitsCompress(\\\"%s\\\")\", cases[i].input);\n    if ((dstlen = lprintPackBitsCompress(dst, (unsigned char *)cases[i].input, cases[i].inlen)) == cases[i].outlen)\n    {\n      if (!memcmp(dst, cases[i].output, cases[i].outlen))\n        testEnd(true);\n      else\n\ttestEndMessage(true, \"alternate bytes OK\");\n    }\n    else\n    {\n      testEndMessage(false, \"got %u bytes, expected %u bytes\", (unsigned)dstlen, (unsigned)cases[i].outlen);\n      testError(\"\\nSource Buffer:\");\n      testHexDump((unsigned char *)cases[i].input, cases[i].inlen);\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      testError(\"\\nExpected Buffer:\");\n      testHexDump((unsigned char *)cases[i].output, cases[i].outlen);\n    }\n  }\n\n  // Loop many times with random changes to the source buffer to test different\n  // source values...\n  memset(src, 0, sizeof(src));\n\n  testBegin(\"lprintPackBitsCompress(%d times)\", num_tests);\n\n  for (i = 0; i < num_tests; i ++)\n  {\n    // Show progress...\n    testProgress();\n\n    // Make a random change to the source buffer...\n    len    = (get_rand() % (sizeof(src) / 4)) + 1;\n    offset = get_rand() % (sizeof(src) - len);\n\n    if (get_rand() & 1)\n    {\n      // Add random bytes\n      for (count = 0; count < len; count ++)\n        src[offset + count] = get_rand();\n    }\n    else\n    {\n      // Add constant bytes\n      memset(src + offset, get_rand(), len);\n    }\n\n    // Compress the result\n    if ((dstlen = lprintPackBitsCompress(dst, src, sizeof(src))) == 0 || dstlen > dstmax)\n    {\n      testEndMessage(false, \"%u > %u\", (unsigned)dstlen, (unsigned)dstmax);\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      break;\n    }\n\n    // Verify compressed result...\n    if ((checklen = uncompress_packbits(check, sizeof(check), dst, dstlen)) != sizeof(src) || memcmp(check, src, sizeof(src)))\n    {\n      testEndMessage(false, \"Decompression Failure\");\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer (%u bytes):\", (unsigned)dstlen);\n      testHexDump(dst, dstlen);\n      testError(\"\\nCheck Buffer (%u bytes):\", (unsigned)checklen);\n      testHexDump(check, checklen);\n      break;\n    }\n  }\n\n  if (i >= num_tests)\n    testEnd(true);\n\n  return (testsPassed ? 0 : 1);\n}\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 40,
    "end_line": 186,
    "code": "nt\t\t\t\t\t// O - Exit status\nmain(int  argc,\t\t\t\t// I - Number of command-line arguments\n     char *argv[])\t\t\t// I - Command-line arguments\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tnum_tests;\t\t// Number of tests to run\n  size_t\toffset,\t\t\t// Offset in source buffer\n\t\tcount,\t\t\t// Looping var\n\t\tlen;\t\t\t// Length of sequence\n  unsigned char\tsrc[1024],\t\t// Source buffer\n\t\tcheck[2048];\t\t// Check buffer\n  size_t\tchecklen;\t\t// Check data length\n  unsigned char\t*dst;\t\t\t// Destination buffer\n  size_t\tdstlen,\t\t\t// Number of destination bytes\n\t\tdstmax;\t\t\t// Maximum number of destination bytes\n  static testdata_t cases[] =\t\t// Test cases\n  {\n    {\n      1, \"a\", 2, \"\\000a\"\n    },\n    {\n      2, \"ab\", 3, \"\\001ab\"\n    },\n    {\n      3, \"abb\", 4, \"\\002abb\"\n    },\n    {\n      4, \"abbc\", 5, \"\\003abbc\"\n    },\n    {\n      5, \"abbcc\", 6, \"\\004abbcc\"\n    },\n    {\n      7, \"abbccdd\", 8, \"\\007abbccdd\"\n    },\n    {\n      9, \"abbbcccdd\", 8, \"\\000a\\376b\\376c\\377d\"\n    },\n    {\n     130, \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"ab\", 5, \"\\201a\\001ab\"\n    }\n  };\n\n\n  // See if the number of tests is on the command-line...\n  if (argc == 1)\n  {\n    num_tests = 1000000;\n  }\n  else if (argc > 2 || (num_tests = atoi(argv[1])) < 1)\n  {\n    fputs(\"Usage: ./testpackbits [COUNT]\\n\", stderr);\n    return (1);\n  }\n\n  // Maximum expansion as defined by the PackBits algorithm...\n  dstmax = sizeof(src) + sizeof(src) / 128;\n\n  // Allocate PackBits buffer\n  testBegin(\"lprintPackBitsAlloc(%u)\", (unsigned)(2 * sizeof(src)));\n  if ((dst = lprintPackBitsAlloc(2 * sizeof(src))) != NULL)\n    testEnd(true);\n  else\n    testEndMessage(false, \"%s\", strerror(errno));\n\n  // Test specific values\n  for (i = 0; i < (int)(sizeof(cases) / sizeof(cases[0])); i ++)\n  {\n    testBegin(\"lprintPackBitsCompress(\\\"%s\\\")\", cases[i].input);\n    if ((dstlen = lprintPackBitsCompress(dst, (unsigned char *)cases[i].input, cases[i].inlen)) == cases[i].outlen)\n    {\n      if (!memcmp(dst, cases[i].output, cases[i].outlen))\n        testEnd(true);\n      else\n\ttestEndMessage(true, \"alternate bytes OK\");\n    }\n    else\n    {\n      testEndMessage(false, \"got %u bytes, expected %u bytes\", (unsigned)dstlen, (unsigned)cases[i].outlen);\n      testError(\"\\nSource Buffer:\");\n      testHexDump((unsigned char *)cases[i].input, cases[i].inlen);\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      testError(\"\\nExpected Buffer:\");\n      testHexDump((unsigned char *)cases[i].output, cases[i].outlen);\n    }\n  }\n\n  // Loop many times with random changes to the source buffer to test different\n  // source values...\n  memset(src, 0, sizeof(src));\n\n  testBegin(\"lprintPackBitsCompress(%d times)\", num_tests);\n\n  for (i = 0; i < num_tests; i ++)\n  {\n    // Show progress...\n    testProgress();\n\n    // Make a random change to the source buffer...\n    len    = (get_rand() % (sizeof(src) / 4)) + 1;\n    offset = get_rand() % (sizeof(src) - len);\n\n    if (get_rand() & 1)\n    {\n      // Add random bytes\n      for (count = 0; count < len; count ++)\n        src[offset + count] = get_rand();\n    }\n    else\n    {\n      // Add constant bytes\n      memset(src + offset, get_rand(), len);\n    }\n\n    // Compress the result\n    if ((dstlen = lprintPackBitsCompress(dst, src, sizeof(src))) == 0 || dstlen > dstmax)\n    {\n      testEndMessage(false, \"%u > %u\", (unsigned)dstlen, (unsigned)dstmax);\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      break;\n    }\n\n    // Verify compressed result...\n    if ((checklen = uncompress_packbits(check, sizeof(check), dst, dstlen)) != sizeof(src) || memcmp(check, src, sizeof(src)))\n    {\n      testEndMessage(false, \"Decompression Failure\");\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer (%u bytes):\", (unsigned)dstlen);\n      testHexDump(dst, dstlen);\n      testError(\"\\nCheck Buffer (%u bytes):\", (unsigned)checklen);\n      testHexDump(check, checklen);\n      break;\n    }\n  }\n\n  if (i >= num_tests)\n    testEnd(true);\n\n  return (testsPassed ? 0 : 1);\n}\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 40,
    "end_line": 186,
    "code": "nt\t\t\t\t\t// O - Exit status\nmain(int  argc,\t\t\t\t// I - Number of command-line arguments\n     char *argv[])\t\t\t// I - Command-line arguments\n{\n  int\t\ti,\t\t\t// Looping var\n\t\tnum_tests;\t\t// Number of tests to run\n  size_t\toffset,\t\t\t// Offset in source buffer\n\t\tcount,\t\t\t// Looping var\n\t\tlen;\t\t\t// Length of sequence\n  unsigned char\tsrc[1024],\t\t// Source buffer\n\t\tcheck[2048];\t\t// Check buffer\n  size_t\tchecklen;\t\t// Check data length\n  unsigned char\t*dst;\t\t\t// Destination buffer\n  size_t\tdstlen,\t\t\t// Number of destination bytes\n\t\tdstmax;\t\t\t// Maximum number of destination bytes\n  static testdata_t cases[] =\t\t// Test cases\n  {\n    {\n      1, \"a\", 2, \"\\000a\"\n    },\n    {\n      2, \"ab\", 3, \"\\001ab\"\n    },\n    {\n      3, \"abb\", 4, \"\\002abb\"\n    },\n    {\n      4, \"abbc\", 5, \"\\003abbc\"\n    },\n    {\n      5, \"abbcc\", 6, \"\\004abbcc\"\n    },\n    {\n      7, \"abbccdd\", 8, \"\\007abbccdd\"\n    },\n    {\n      9, \"abbbcccdd\", 8, \"\\000a\\376b\\376c\\377d\"\n    },\n    {\n     130, \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"ab\", 5, \"\\201a\\001ab\"\n    }\n  };\n\n\n  // See if the number of tests is on the command-line...\n  if (argc == 1)\n  {\n    num_tests = 1000000;\n  }\n  else if (argc > 2 || (num_tests = atoi(argv[1])) < 1)\n  {\n    fputs(\"Usage: ./testpackbits [COUNT]\\n\", stderr);\n    return (1);\n  }\n\n  // Maximum expansion as defined by the PackBits algorithm...\n  dstmax = sizeof(src) + sizeof(src) / 128;\n\n  // Allocate PackBits buffer\n  testBegin(\"lprintPackBitsAlloc(%u)\", (unsigned)(2 * sizeof(src)));\n  if ((dst = lprintPackBitsAlloc(2 * sizeof(src))) != NULL)\n    testEnd(true);\n  else\n    testEndMessage(false, \"%s\", strerror(errno));\n\n  // Test specific values\n  for (i = 0; i < (int)(sizeof(cases) / sizeof(cases[0])); i ++)\n  {\n    testBegin(\"lprintPackBitsCompress(\\\"%s\\\")\", cases[i].input);\n    if ((dstlen = lprintPackBitsCompress(dst, (unsigned char *)cases[i].input, cases[i].inlen)) == cases[i].outlen)\n    {\n      if (!memcmp(dst, cases[i].output, cases[i].outlen))\n        testEnd(true);\n      else\n\ttestEndMessage(true, \"alternate bytes OK\");\n    }\n    else\n    {\n      testEndMessage(false, \"got %u bytes, expected %u bytes\", (unsigned)dstlen, (unsigned)cases[i].outlen);\n      testError(\"\\nSource Buffer:\");\n      testHexDump((unsigned char *)cases[i].input, cases[i].inlen);\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      testError(\"\\nExpected Buffer:\");\n      testHexDump((unsigned char *)cases[i].output, cases[i].outlen);\n    }\n  }\n\n  // Loop many times with random changes to the source buffer to test different\n  // source values...\n  memset(src, 0, sizeof(src));\n\n  testBegin(\"lprintPackBitsCompress(%d times)\", num_tests);\n\n  for (i = 0; i < num_tests; i ++)\n  {\n    // Show progress...\n    testProgress();\n\n    // Make a random change to the source buffer...\n    len    = (get_rand() % (sizeof(src) / 4)) + 1;\n    offset = get_rand() % (sizeof(src) - len);\n\n    if (get_rand() & 1)\n    {\n      // Add random bytes\n      for (count = 0; count < len; count ++)\n        src[offset + count] = get_rand();\n    }\n    else\n    {\n      // Add constant bytes\n      memset(src + offset, get_rand(), len);\n    }\n\n    // Compress the result\n    if ((dstlen = lprintPackBitsCompress(dst, src, sizeof(src))) == 0 || dstlen > dstmax)\n    {\n      testEndMessage(false, \"%u > %u\", (unsigned)dstlen, (unsigned)dstmax);\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      break;\n    }\n\n    // Verify compressed result...\n    if ((checklen = uncompress_packbits(check, sizeof(check), dst, dstlen)) != sizeof(src) || memcmp(check, src, sizeof(src)))\n    {\n      testEndMessage(false, \"Decompression Failure\");\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer (%u bytes):\", (unsigned)dstlen);\n      testHexDump(dst, dstlen);\n      testError(\"\\nCheck Buffer (%u bytes):\", (unsigned)checklen);\n      testHexDump(check, checklen);\n      break;\n    }\n  }\n\n  if (i >= num_tests)\n    testEnd(true);\n\n  return (testsPassed ? 0 : 1);\n}\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 43,
    "end_line": 186,
    "code": "\n  int\t\ti,\t\t\t// Looping var\n\t\tnum_tests;\t\t// Number of tests to run\n  size_t\toffset,\t\t\t// Offset in source buffer\n\t\tcount,\t\t\t// Looping var\n\t\tlen;\t\t\t// Length of sequence\n  unsigned char\tsrc[1024],\t\t// Source buffer\n\t\tcheck[2048];\t\t// Check buffer\n  size_t\tchecklen;\t\t// Check data length\n  unsigned char\t*dst;\t\t\t// Destination buffer\n  size_t\tdstlen,\t\t\t// Number of destination bytes\n\t\tdstmax;\t\t\t// Maximum number of destination bytes\n  static testdata_t cases[] =\t\t// Test cases\n  {\n    {\n      1, \"a\", 2, \"\\000a\"\n    },\n    {\n      2, \"ab\", 3, \"\\001ab\"\n    },\n    {\n      3, \"abb\", 4, \"\\002abb\"\n    },\n    {\n      4, \"abbc\", 5, \"\\003abbc\"\n    },\n    {\n      5, \"abbcc\", 6, \"\\004abbcc\"\n    },\n    {\n      7, \"abbccdd\", 8, \"\\007abbccdd\"\n    },\n    {\n      9, \"abbbcccdd\", 8, \"\\000a\\376b\\376c\\377d\"\n    },\n    {\n     130, \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"ab\", 5, \"\\201a\\001ab\"\n    }\n  };\n\n\n  // See if the number of tests is on the command-line...\n  if (argc == 1)\n  {\n    num_tests = 1000000;\n  }\n  else if (argc > 2 || (num_tests = atoi(argv[1])) < 1)\n  {\n    fputs(\"Usage: ./testpackbits [COUNT]\\n\", stderr);\n    return (1);\n  }\n\n  // Maximum expansion as defined by the PackBits algorithm...\n  dstmax = sizeof(src) + sizeof(src) / 128;\n\n  // Allocate PackBits buffer\n  testBegin(\"lprintPackBitsAlloc(%u)\", (unsigned)(2 * sizeof(src)));\n  if ((dst = lprintPackBitsAlloc(2 * sizeof(src))) != NULL)\n    testEnd(true);\n  else\n    testEndMessage(false, \"%s\", strerror(errno));\n\n  // Test specific values\n  for (i = 0; i < (int)(sizeof(cases) / sizeof(cases[0])); i ++)\n  {\n    testBegin(\"lprintPackBitsCompress(\\\"%s\\\")\", cases[i].input);\n    if ((dstlen = lprintPackBitsCompress(dst, (unsigned char *)cases[i].input, cases[i].inlen)) == cases[i].outlen)\n    {\n      if (!memcmp(dst, cases[i].output, cases[i].outlen))\n        testEnd(true);\n      else\n\ttestEndMessage(true, \"alternate bytes OK\");\n    }\n    else\n    {\n      testEndMessage(false, \"got %u bytes, expected %u bytes\", (unsigned)dstlen, (unsigned)cases[i].outlen);\n      testError(\"\\nSource Buffer:\");\n      testHexDump((unsigned char *)cases[i].input, cases[i].inlen);\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      testError(\"\\nExpected Buffer:\");\n      testHexDump((unsigned char *)cases[i].output, cases[i].outlen);\n    }\n  }\n\n  // Loop many times with random changes to the source buffer to test different\n  // source values...\n  memset(src, 0, sizeof(src));\n\n  testBegin(\"lprintPackBitsCompress(%d times)\", num_tests);\n\n  for (i = 0; i < num_tests; i ++)\n  {\n    // Show progress...\n    testProgress();\n\n    // Make a random change to the source buffer...\n    len    = (get_rand() % (sizeof(src) / 4)) + 1;\n    offset = get_rand() % (sizeof(src) - len);\n\n    if (get_rand() & 1)\n    {\n      // Add random bytes\n      for (count = 0; count < len; count ++)\n        src[offset + count] = get_rand();\n    }\n    else\n    {\n      // Add constant bytes\n      memset(src + offset, get_rand(), len);\n    }\n\n    // Compress the result\n    if ((dstlen = lprintPackBitsCompress(dst, src, sizeof(src))) == 0 || dstlen > dstmax)\n    {\n      testEndMessage(false, \"%u > %u\", (unsigned)dstlen, (unsigned)dstmax);\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      break;\n    }\n\n    // Verify compressed result...\n    if ((checklen = uncompress_packbits(check, sizeof(check), dst, dstlen)) != sizeof(src) || memcmp(check, src, sizeof(src)))\n    {\n      testEndMessage(false, \"Decompression Failure\");\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer (%u bytes):\", (unsigned)dstlen);\n      testHexDump(dst, dstlen);\n      testError(\"\\nCheck Buffer (%u bytes):\", (unsigned)checklen);\n      testHexDump(check, checklen);\n      break;\n    }\n  }\n\n  if (i >= num_tests)\n    testEnd(true);\n\n  return (testsPassed ? 0 : 1);\n}\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "static_const_char_pointer_array",
    "start_line": 43,
    "end_line": 186,
    "code": "\n  int\t\ti,\t\t\t// Looping var\n\t\tnum_tests;\t\t// Number of tests to run\n  size_t\toffset,\t\t\t// Offset in source buffer\n\t\tcount,\t\t\t// Looping var\n\t\tlen;\t\t\t// Length of sequence\n  unsigned char\tsrc[1024],\t\t// Source buffer\n\t\tcheck[2048];\t\t// Check buffer\n  size_t\tchecklen;\t\t// Check data length\n  unsigned char\t*dst;\t\t\t// Destination buffer\n  size_t\tdstlen,\t\t\t// Number of destination bytes\n\t\tdstmax;\t\t\t// Maximum number of destination bytes\n  static testdata_t cases[] =\t\t// Test cases\n  {\n    {\n      1, \"a\", 2, \"\\000a\"\n    },\n    {\n      2, \"ab\", 3, \"\\001ab\"\n    },\n    {\n      3, \"abb\", 4, \"\\002abb\"\n    },\n    {\n      4, \"abbc\", 5, \"\\003abbc\"\n    },\n    {\n      5, \"abbcc\", 6, \"\\004abbcc\"\n    },\n    {\n      7, \"abbccdd\", 8, \"\\007abbccdd\"\n    },\n    {\n      9, \"abbbcccdd\", 8, \"\\000a\\376b\\376c\\377d\"\n    },\n    {\n     130, \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"ab\", 5, \"\\201a\\001ab\"\n    }\n  };\n\n\n  // See if the number of tests is on the command-line...\n  if (argc == 1)\n  {\n    num_tests = 1000000;\n  }\n  else if (argc > 2 || (num_tests = atoi(argv[1])) < 1)\n  {\n    fputs(\"Usage: ./testpackbits [COUNT]\\n\", stderr);\n    return (1);\n  }\n\n  // Maximum expansion as defined by the PackBits algorithm...\n  dstmax = sizeof(src) + sizeof(src) / 128;\n\n  // Allocate PackBits buffer\n  testBegin(\"lprintPackBitsAlloc(%u)\", (unsigned)(2 * sizeof(src)));\n  if ((dst = lprintPackBitsAlloc(2 * sizeof(src))) != NULL)\n    testEnd(true);\n  else\n    testEndMessage(false, \"%s\", strerror(errno));\n\n  // Test specific values\n  for (i = 0; i < (int)(sizeof(cases) / sizeof(cases[0])); i ++)\n  {\n    testBegin(\"lprintPackBitsCompress(\\\"%s\\\")\", cases[i].input);\n    if ((dstlen = lprintPackBitsCompress(dst, (unsigned char *)cases[i].input, cases[i].inlen)) == cases[i].outlen)\n    {\n      if (!memcmp(dst, cases[i].output, cases[i].outlen))\n        testEnd(true);\n      else\n\ttestEndMessage(true, \"alternate bytes OK\");\n    }\n    else\n    {\n      testEndMessage(false, \"got %u bytes, expected %u bytes\", (unsigned)dstlen, (unsigned)cases[i].outlen);\n      testError(\"\\nSource Buffer:\");\n      testHexDump((unsigned char *)cases[i].input, cases[i].inlen);\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      testError(\"\\nExpected Buffer:\");\n      testHexDump((unsigned char *)cases[i].output, cases[i].outlen);\n    }\n  }\n\n  // Loop many times with random changes to the source buffer to test different\n  // source values...\n  memset(src, 0, sizeof(src));\n\n  testBegin(\"lprintPackBitsCompress(%d times)\", num_tests);\n\n  for (i = 0; i < num_tests; i ++)\n  {\n    // Show progress...\n    testProgress();\n\n    // Make a random change to the source buffer...\n    len    = (get_rand() % (sizeof(src) / 4)) + 1;\n    offset = get_rand() % (sizeof(src) - len);\n\n    if (get_rand() & 1)\n    {\n      // Add random bytes\n      for (count = 0; count < len; count ++)\n        src[offset + count] = get_rand();\n    }\n    else\n    {\n      // Add constant bytes\n      memset(src + offset, get_rand(), len);\n    }\n\n    // Compress the result\n    if ((dstlen = lprintPackBitsCompress(dst, src, sizeof(src))) == 0 || dstlen > dstmax)\n    {\n      testEndMessage(false, \"%u > %u\", (unsigned)dstlen, (unsigned)dstmax);\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      break;\n    }\n\n    // Verify compressed result...\n    if ((checklen = uncompress_packbits(check, sizeof(check), dst, dstlen)) != sizeof(src) || memcmp(check, src, sizeof(src)))\n    {\n      testEndMessage(false, \"Decompression Failure\");\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer (%u bytes):\", (unsigned)dstlen);\n      testHexDump(dst, dstlen);\n      testError(\"\\nCheck Buffer (%u bytes):\", (unsigned)checklen);\n      testHexDump(check, checklen);\n      break;\n    }\n  }\n\n  if (i >= num_tests)\n    testEnd(true);\n\n  return (testsPassed ? 0 : 1);\n}\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "global_variable",
    "start_line": 55,
    "end_line": 83,
    "code": "tatic testdata_t cases[] =\t\t// Test cases\n  {\n    {\n      1, \"a\", 2, \"\\000a\"\n    },\n    {\n      2, \"ab\", 3, \"\\001ab\"\n    },\n    {\n      3, \"abb\", 4, \"\\002abb\"\n    },\n    {\n      4, \"abbc\", 5, \"\\003abbc\"\n    },\n    {\n      5, \"abbcc\", 6, \"\\004abbcc\"\n    },\n    {\n      7, \"abbccdd\", 8, \"\\007abbccdd\"\n    },\n    {\n      9, \"abbbcccdd\", 8, \"\\000a\\376b\\376c\\377d\"\n    },\n    {\n     130, \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"ab\", 5, \"\\201a\\001ab\"\n    }\n  };\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 56,
    "end_line": 83,
    "code": "\n    {\n      1, \"a\", 2, \"\\000a\"\n    },\n    {\n      2, \"ab\", 3, \"\\001ab\"\n    },\n    {\n      3, \"abb\", 4, \"\\002abb\"\n    },\n    {\n      4, \"abbc\", 5, \"\\003abbc\"\n    },\n    {\n      5, \"abbcc\", 6, \"\\004abbcc\"\n    },\n    {\n      7, \"abbccdd\", 8, \"\\007abbccdd\"\n    },\n    {\n      9, \"abbbcccdd\", 8, \"\\000a\\376b\\376c\\377d\"\n    },\n    {\n     130, \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"ab\", 5, \"\\201a\\001ab\"\n    }\n  };",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 87,
    "end_line": 95,
    "code": "f (argc == 1)\n  {\n    num_tests = 1000000;\n  }\n  else if (argc > 2 || (num_tests = atoi(argv[1])) < 1)\n  {\n    fputs(\"Usage: ./testpackbits [COUNT]\\n\", stderr);\n    return (1);\n  }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 91,
    "end_line": 95,
    "code": "lse if (argc > 2 || (num_tests = atoi(argv[1])) < 1)\n  {\n    fputs(\"Usage: ./testpackbits [COUNT]\\n\", stderr);\n    return (1);\n  }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 91,
    "end_line": 95,
    "code": "f (argc > 2 || (num_tests = atoi(argv[1])) < 1)\n  {\n    fputs(\"Usage: ./testpackbits [COUNT]\\n\", stderr);\n    return (1);\n  }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 108,
    "end_line": 128,
    "code": "or (i = 0; i < (int)(sizeof(cases) / sizeof(cases[0])); i ++)\n  {\n    testBegin(\"lprintPackBitsCompress(\\\"%s\\\")\", cases[i].input);\n    if ((dstlen = lprintPackBitsCompress(dst, (unsigned char *)cases[i].input, cases[i].inlen)) == cases[i].outlen)\n    {\n      if (!memcmp(dst, cases[i].output, cases[i].outlen))\n        testEnd(true);\n      else\n\ttestEndMessage(true, \"alternate bytes OK\");\n    }\n    else\n    {\n      testEndMessage(false, \"got %u bytes, expected %u bytes\", (unsigned)dstlen, (unsigned)cases[i].outlen);\n      testError(\"\\nSource Buffer:\");\n      testHexDump((unsigned char *)cases[i].input, cases[i].inlen);\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      testError(\"\\nExpected Buffer:\");\n      testHexDump((unsigned char *)cases[i].output, cases[i].outlen);\n    }\n  }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 109,
    "end_line": 128,
    "code": "\n    testBegin(\"lprintPackBitsCompress(\\\"%s\\\")\", cases[i].input);\n    if ((dstlen = lprintPackBitsCompress(dst, (unsigned char *)cases[i].input, cases[i].inlen)) == cases[i].outlen)\n    {\n      if (!memcmp(dst, cases[i].output, cases[i].outlen))\n        testEnd(true);\n      else\n\ttestEndMessage(true, \"alternate bytes OK\");\n    }\n    else\n    {\n      testEndMessage(false, \"got %u bytes, expected %u bytes\", (unsigned)dstlen, (unsigned)cases[i].outlen);\n      testError(\"\\nSource Buffer:\");\n      testHexDump((unsigned char *)cases[i].input, cases[i].inlen);\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      testError(\"\\nExpected Buffer:\");\n      testHexDump((unsigned char *)cases[i].output, cases[i].outlen);\n    }\n  }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 111,
    "end_line": 127,
    "code": "f ((dstlen = lprintPackBitsCompress(dst, (unsigned char *)cases[i].input, cases[i].inlen)) == cases[i].outlen)\n    {\n      if (!memcmp(dst, cases[i].output, cases[i].outlen))\n        testEnd(true);\n      else\n\ttestEndMessage(true, \"alternate bytes OK\");\n    }\n    else\n    {\n      testEndMessage(false, \"got %u bytes, expected %u bytes\", (unsigned)dstlen, (unsigned)cases[i].outlen);\n      testError(\"\\nSource Buffer:\");\n      testHexDump((unsigned char *)cases[i].input, cases[i].inlen);\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      testError(\"\\nExpected Buffer:\");\n      testHexDump((unsigned char *)cases[i].output, cases[i].outlen);\n    }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 118,
    "end_line": 127,
    "code": "lse\n    {\n      testEndMessage(false, \"got %u bytes, expected %u bytes\", (unsigned)dstlen, (unsigned)cases[i].outlen);\n      testError(\"\\nSource Buffer:\");\n      testHexDump((unsigned char *)cases[i].input, cases[i].inlen);\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      testError(\"\\nExpected Buffer:\");\n      testHexDump((unsigned char *)cases[i].output, cases[i].outlen);\n    }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 136,
    "end_line": 180,
    "code": "or (i = 0; i < num_tests; i ++)\n  {\n    // Show progress...\n    testProgress();\n\n    // Make a random change to the source buffer...\n    len    = (get_rand() % (sizeof(src) / 4)) + 1;\n    offset = get_rand() % (sizeof(src) - len);\n\n    if (get_rand() & 1)\n    {\n      // Add random bytes\n      for (count = 0; count < len; count ++)\n        src[offset + count] = get_rand();\n    }\n    else\n    {\n      // Add constant bytes\n      memset(src + offset, get_rand(), len);\n    }\n\n    // Compress the result\n    if ((dstlen = lprintPackBitsCompress(dst, src, sizeof(src))) == 0 || dstlen > dstmax)\n    {\n      testEndMessage(false, \"%u > %u\", (unsigned)dstlen, (unsigned)dstmax);\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      break;\n    }\n\n    // Verify compressed result...\n    if ((checklen = uncompress_packbits(check, sizeof(check), dst, dstlen)) != sizeof(src) || memcmp(check, src, sizeof(src)))\n    {\n      testEndMessage(false, \"Decompression Failure\");\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer (%u bytes):\", (unsigned)dstlen);\n      testHexDump(dst, dstlen);\n      testError(\"\\nCheck Buffer (%u bytes):\", (unsigned)checklen);\n      testHexDump(check, checklen);\n      break;\n    }\n  }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 137,
    "end_line": 180,
    "code": "\n    // Show progress...\n    testProgress();\n\n    // Make a random change to the source buffer...\n    len    = (get_rand() % (sizeof(src) / 4)) + 1;\n    offset = get_rand() % (sizeof(src) - len);\n\n    if (get_rand() & 1)\n    {\n      // Add random bytes\n      for (count = 0; count < len; count ++)\n        src[offset + count] = get_rand();\n    }\n    else\n    {\n      // Add constant bytes\n      memset(src + offset, get_rand(), len);\n    }\n\n    // Compress the result\n    if ((dstlen = lprintPackBitsCompress(dst, src, sizeof(src))) == 0 || dstlen > dstmax)\n    {\n      testEndMessage(false, \"%u > %u\", (unsigned)dstlen, (unsigned)dstmax);\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer:\");\n      testHexDump(dst, dstlen);\n      break;\n    }\n\n    // Verify compressed result...\n    if ((checklen = uncompress_packbits(check, sizeof(check), dst, dstlen)) != sizeof(src) || memcmp(check, src, sizeof(src)))\n    {\n      testEndMessage(false, \"Decompression Failure\");\n      testError(\"\\nSource Buffer:\");\n      testHexDump(src, sizeof(src));\n      testError(\"\\nDestination Buffer (%u bytes):\", (unsigned)dstlen);\n      testHexDump(dst, dstlen);\n      testError(\"\\nCheck Buffer (%u bytes):\", (unsigned)checklen);\n      testHexDump(check, checklen);\n      break;\n    }\n  }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "function",
    "start_line": 197,
    "end_line": 290,
    "name": "get_rand",
    "parent": null,
    "hierarchy": "get_rand",
    "code": "tatic unsigned\t\t\t\t// O - Random number\nget_rand(void)\n{\n#if _WIN32\n  // rand_s uses real entropy...\n  unsigned v;\t\t\t\t// Random number\n\n\n  rand_s(&v);\n\n  return (v);\n\n#elif defined(__APPLE__)\n  // macOS/iOS arc4random() uses real entropy automatically...\n  return (arc4random());\n\n#else\n  // Use a Mersenne twister random number generator seeded from /dev/urandom...\n  unsigned\ti,\t\t\t// Looping var\n\t\ttemp;\t\t\t// Temporary value\n  static bool\tfirst_time = true;\t// First time we ran?\n  static unsigned mt_state[624],\t// Mersenne twister state\n\t\tmt_index;\t\t// Mersenne twister index\n\n\n  if (first_time)\n  {\n    int\t\tfd;\t\t\t// \"/dev/urandom\" file\n    struct timeval curtime;\t\t// Current time\n\n    // Seed the random number state...\n    if ((fd = open(\"/dev/urandom\", O_RDONLY)) >= 0)\n    {\n      // Read random entropy from the system...\n      if (read(fd, mt_state, sizeof(mt_state[0])) < sizeof(mt_state[0]))\n        mt_state[0] = 0;\t\t// Force fallback...\n\n      close(fd);\n    }\n    else\n      mt_state[0] = 0;\n\n    if (!mt_state[0])\n    {\n      // Fallback to using the current time in microseconds...\n      gettimeofday(&curtime, NULL);\n      mt_state[0] = (unsigned)(curtime.tv_sec + curtime.tv_usec);\n    }\n\n    mt_index = 0;\n\n    for (i = 1; i < 624; i ++)\n      mt_state[i] = (unsigned)((1812433253 * (mt_state[i - 1] ^ (mt_state[i - 1] >> 30))) + i);\n\n    first_time = false;\n  }\n\n  if (mt_index == 0)\n  {\n    // Generate a sequence of random numbers...\n    unsigned i1 = 1, i397 = 397;\t// Looping vars\n\n    for (i = 0; i < 624; i ++)\n    {\n      temp        = (mt_state[i] & 0x80000000) + (mt_state[i1] & 0x7fffffff);\n      mt_state[i] = mt_state[i397] ^ (temp >> 1);\n\n      if (temp & 1)\n\tmt_state[i] ^= 2567483615u;\n\n      i1 ++;\n      i397 ++;\n\n      if (i1 == 624)\n\ti1 = 0;\n\n      if (i397 == 624)\n\ti397 = 0;\n    }\n  }\n\n  // Pull 32-bits of random data...\n  temp = mt_state[mt_index ++];\n  temp ^= temp >> 11;\n  temp ^= (temp << 7) & 2636928640u;\n  temp ^= (temp << 15) & 4022730752u;\n  temp ^= temp >> 18;\n\n  if (mt_index == 624)\n    mt_index = 0;\n\n  return (temp);\n#endif // _WIN32\n}\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 197,
    "end_line": 290,
    "code": "tatic unsigned\t\t\t\t// O - Random number\nget_rand(void)\n{\n#if _WIN32\n  // rand_s uses real entropy...\n  unsigned v;\t\t\t\t// Random number\n\n\n  rand_s(&v);\n\n  return (v);\n\n#elif defined(__APPLE__)\n  // macOS/iOS arc4random() uses real entropy automatically...\n  return (arc4random());\n\n#else\n  // Use a Mersenne twister random number generator seeded from /dev/urandom...\n  unsigned\ti,\t\t\t// Looping var\n\t\ttemp;\t\t\t// Temporary value\n  static bool\tfirst_time = true;\t// First time we ran?\n  static unsigned mt_state[624],\t// Mersenne twister state\n\t\tmt_index;\t\t// Mersenne twister index\n\n\n  if (first_time)\n  {\n    int\t\tfd;\t\t\t// \"/dev/urandom\" file\n    struct timeval curtime;\t\t// Current time\n\n    // Seed the random number state...\n    if ((fd = open(\"/dev/urandom\", O_RDONLY)) >= 0)\n    {\n      // Read random entropy from the system...\n      if (read(fd, mt_state, sizeof(mt_state[0])) < sizeof(mt_state[0]))\n        mt_state[0] = 0;\t\t// Force fallback...\n\n      close(fd);\n    }\n    else\n      mt_state[0] = 0;\n\n    if (!mt_state[0])\n    {\n      // Fallback to using the current time in microseconds...\n      gettimeofday(&curtime, NULL);\n      mt_state[0] = (unsigned)(curtime.tv_sec + curtime.tv_usec);\n    }\n\n    mt_index = 0;\n\n    for (i = 1; i < 624; i ++)\n      mt_state[i] = (unsigned)((1812433253 * (mt_state[i - 1] ^ (mt_state[i - 1] >> 30))) + i);\n\n    first_time = false;\n  }\n\n  if (mt_index == 0)\n  {\n    // Generate a sequence of random numbers...\n    unsigned i1 = 1, i397 = 397;\t// Looping vars\n\n    for (i = 0; i < 624; i ++)\n    {\n      temp        = (mt_state[i] & 0x80000000) + (mt_state[i1] & 0x7fffffff);\n      mt_state[i] = mt_state[i397] ^ (temp >> 1);\n\n      if (temp & 1)\n\tmt_state[i] ^= 2567483615u;\n\n      i1 ++;\n      i397 ++;\n\n      if (i1 == 624)\n\ti1 = 0;\n\n      if (i397 == 624)\n\ti397 = 0;\n    }\n  }\n\n  // Pull 32-bits of random data...\n  temp = mt_state[mt_index ++];\n  temp ^= temp >> 11;\n  temp ^= (temp << 7) & 2636928640u;\n  temp ^= (temp << 15) & 4022730752u;\n  temp ^= temp >> 18;\n\n  if (mt_index == 624)\n    mt_index = 0;\n\n  return (temp);\n#endif // _WIN32\n}\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 199,
    "end_line": 290,
    "code": "\n#if _WIN32\n  // rand_s uses real entropy...\n  unsigned v;\t\t\t\t// Random number\n\n\n  rand_s(&v);\n\n  return (v);\n\n#elif defined(__APPLE__)\n  // macOS/iOS arc4random() uses real entropy automatically...\n  return (arc4random());\n\n#else\n  // Use a Mersenne twister random number generator seeded from /dev/urandom...\n  unsigned\ti,\t\t\t// Looping var\n\t\ttemp;\t\t\t// Temporary value\n  static bool\tfirst_time = true;\t// First time we ran?\n  static unsigned mt_state[624],\t// Mersenne twister state\n\t\tmt_index;\t\t// Mersenne twister index\n\n\n  if (first_time)\n  {\n    int\t\tfd;\t\t\t// \"/dev/urandom\" file\n    struct timeval curtime;\t\t// Current time\n\n    // Seed the random number state...\n    if ((fd = open(\"/dev/urandom\", O_RDONLY)) >= 0)\n    {\n      // Read random entropy from the system...\n      if (read(fd, mt_state, sizeof(mt_state[0])) < sizeof(mt_state[0]))\n        mt_state[0] = 0;\t\t// Force fallback...\n\n      close(fd);\n    }\n    else\n      mt_state[0] = 0;\n\n    if (!mt_state[0])\n    {\n      // Fallback to using the current time in microseconds...\n      gettimeofday(&curtime, NULL);\n      mt_state[0] = (unsigned)(curtime.tv_sec + curtime.tv_usec);\n    }\n\n    mt_index = 0;\n\n    for (i = 1; i < 624; i ++)\n      mt_state[i] = (unsigned)((1812433253 * (mt_state[i - 1] ^ (mt_state[i - 1] >> 30))) + i);\n\n    first_time = false;\n  }\n\n  if (mt_index == 0)\n  {\n    // Generate a sequence of random numbers...\n    unsigned i1 = 1, i397 = 397;\t// Looping vars\n\n    for (i = 0; i < 624; i ++)\n    {\n      temp        = (mt_state[i] & 0x80000000) + (mt_state[i1] & 0x7fffffff);\n      mt_state[i] = mt_state[i397] ^ (temp >> 1);\n\n      if (temp & 1)\n\tmt_state[i] ^= 2567483615u;\n\n      i1 ++;\n      i397 ++;\n\n      if (i1 == 624)\n\ti1 = 0;\n\n      if (i397 == 624)\n\ti397 = 0;\n    }\n  }\n\n  // Pull 32-bits of random data...\n  temp = mt_state[mt_index ++];\n  temp ^= temp >> 11;\n  temp ^= (temp << 7) & 2636928640u;\n  temp ^= (temp << 15) & 4022730752u;\n  temp ^= temp >> 18;\n\n  if (mt_index == 624)\n    mt_index = 0;\n\n  return (temp);\n#endif // _WIN32\n}\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "preprocessor",
    "start_line": 200,
    "end_line": 289,
    "code": "if _WIN32\n  // rand_s uses real entropy...\n  unsigned v;\t\t\t\t// Random number\n\n\n  rand_s(&v);\n\n  return (v);\n\n#elif defined(__APPLE__)\n  // macOS/iOS arc4random() uses real entropy automatically...\n  return (arc4random());\n\n#else\n  // Use a Mersenne twister random number generator seeded from /dev/urandom...\n  unsigned\ti,\t\t\t// Looping var\n\t\ttemp;\t\t\t// Temporary value\n  static bool\tfirst_time = true;\t// First time we ran?\n  static unsigned mt_state[624],\t// Mersenne twister state\n\t\tmt_index;\t\t// Mersenne twister index\n\n\n  if (first_time)\n  {\n    int\t\tfd;\t\t\t// \"/dev/urandom\" file\n    struct timeval curtime;\t\t// Current time\n\n    // Seed the random number state...\n    if ((fd = open(\"/dev/urandom\", O_RDONLY)) >= 0)\n    {\n      // Read random entropy from the system...\n      if (read(fd, mt_state, sizeof(mt_state[0])) < sizeof(mt_state[0]))\n        mt_state[0] = 0;\t\t// Force fallback...\n\n      close(fd);\n    }\n    else\n      mt_state[0] = 0;\n\n    if (!mt_state[0])\n    {\n      // Fallback to using the current time in microseconds...\n      gettimeofday(&curtime, NULL);\n      mt_state[0] = (unsigned)(curtime.tv_sec + curtime.tv_usec);\n    }\n\n    mt_index = 0;\n\n    for (i = 1; i < 624; i ++)\n      mt_state[i] = (unsigned)((1812433253 * (mt_state[i - 1] ^ (mt_state[i - 1] >> 30))) + i);\n\n    first_time = false;\n  }\n\n  if (mt_index == 0)\n  {\n    // Generate a sequence of random numbers...\n    unsigned i1 = 1, i397 = 397;\t// Looping vars\n\n    for (i = 0; i < 624; i ++)\n    {\n      temp        = (mt_state[i] & 0x80000000) + (mt_state[i1] & 0x7fffffff);\n      mt_state[i] = mt_state[i397] ^ (temp >> 1);\n\n      if (temp & 1)\n\tmt_state[i] ^= 2567483615u;\n\n      i1 ++;\n      i397 ++;\n\n      if (i1 == 624)\n\ti1 = 0;\n\n      if (i397 == 624)\n\ti397 = 0;\n    }\n  }\n\n  // Pull 32-bits of random data...\n  temp = mt_state[mt_index ++];\n  temp ^= temp >> 11;\n  temp ^= (temp << 7) & 2636928640u;\n  temp ^= (temp << 15) & 4022730752u;\n  temp ^= temp >> 18;\n\n  if (mt_index == 624)\n    mt_index = 0;\n\n  return (temp);\n#endif ",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 200,
    "end_line": 289,
    "code": "if _WIN32\n  // rand_s uses real entropy...\n  unsigned v;\t\t\t\t// Random number\n\n\n  rand_s(&v);\n\n  return (v);\n\n#elif defined(__APPLE__)\n  // macOS/iOS arc4random() uses real entropy automatically...\n  return (arc4random());\n\n#else\n  // Use a Mersenne twister random number generator seeded from /dev/urandom...\n  unsigned\ti,\t\t\t// Looping var\n\t\ttemp;\t\t\t// Temporary value\n  static bool\tfirst_time = true;\t// First time we ran?\n  static unsigned mt_state[624],\t// Mersenne twister state\n\t\tmt_index;\t\t// Mersenne twister index\n\n\n  if (first_time)\n  {\n    int\t\tfd;\t\t\t// \"/dev/urandom\" file\n    struct timeval curtime;\t\t// Current time\n\n    // Seed the random number state...\n    if ((fd = open(\"/dev/urandom\", O_RDONLY)) >= 0)\n    {\n      // Read random entropy from the system...\n      if (read(fd, mt_state, sizeof(mt_state[0])) < sizeof(mt_state[0]))\n        mt_state[0] = 0;\t\t// Force fallback...\n\n      close(fd);\n    }\n    else\n      mt_state[0] = 0;\n\n    if (!mt_state[0])\n    {\n      // Fallback to using the current time in microseconds...\n      gettimeofday(&curtime, NULL);\n      mt_state[0] = (unsigned)(curtime.tv_sec + curtime.tv_usec);\n    }\n\n    mt_index = 0;\n\n    for (i = 1; i < 624; i ++)\n      mt_state[i] = (unsigned)((1812433253 * (mt_state[i - 1] ^ (mt_state[i - 1] >> 30))) + i);\n\n    first_time = false;\n  }\n\n  if (mt_index == 0)\n  {\n    // Generate a sequence of random numbers...\n    unsigned i1 = 1, i397 = 397;\t// Looping vars\n\n    for (i = 0; i < 624; i ++)\n    {\n      temp        = (mt_state[i] & 0x80000000) + (mt_state[i1] & 0x7fffffff);\n      mt_state[i] = mt_state[i397] ^ (temp >> 1);\n\n      if (temp & 1)\n\tmt_state[i] ^= 2567483615u;\n\n      i1 ++;\n      i397 ++;\n\n      if (i1 == 624)\n\ti1 = 0;\n\n      if (i397 == 624)\n\ti397 = 0;\n    }\n  }\n\n  // Pull 32-bits of random data...\n  temp = mt_state[mt_index ++];\n  temp ^= temp >> 11;\n  temp ^= (temp << 7) & 2636928640u;\n  temp ^= (temp << 15) & 4022730752u;\n  temp ^= temp >> 18;\n\n  if (mt_index == 624)\n    mt_index = 0;\n\n  return (temp);\n#endif ",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 209,
    "end_line": 288,
    "code": "elif defined(__APPLE__)\n  // macOS/iOS arc4random() uses real entropy automatically...\n  return (arc4random());\n\n#else\n  // Use a Mersenne twister random number generator seeded from /dev/urandom...\n  unsigned\ti,\t\t\t// Looping var\n\t\ttemp;\t\t\t// Temporary value\n  static bool\tfirst_time = true;\t// First time we ran?\n  static unsigned mt_state[624],\t// Mersenne twister state\n\t\tmt_index;\t\t// Mersenne twister index\n\n\n  if (first_time)\n  {\n    int\t\tfd;\t\t\t// \"/dev/urandom\" file\n    struct timeval curtime;\t\t// Current time\n\n    // Seed the random number state...\n    if ((fd = open(\"/dev/urandom\", O_RDONLY)) >= 0)\n    {\n      // Read random entropy from the system...\n      if (read(fd, mt_state, sizeof(mt_state[0])) < sizeof(mt_state[0]))\n        mt_state[0] = 0;\t\t// Force fallback...\n\n      close(fd);\n    }\n    else\n      mt_state[0] = 0;\n\n    if (!mt_state[0])\n    {\n      // Fallback to using the current time in microseconds...\n      gettimeofday(&curtime, NULL);\n      mt_state[0] = (unsigned)(curtime.tv_sec + curtime.tv_usec);\n    }\n\n    mt_index = 0;\n\n    for (i = 1; i < 624; i ++)\n      mt_state[i] = (unsigned)((1812433253 * (mt_state[i - 1] ^ (mt_state[i - 1] >> 30))) + i);\n\n    first_time = false;\n  }\n\n  if (mt_index == 0)\n  {\n    // Generate a sequence of random numbers...\n    unsigned i1 = 1, i397 = 397;\t// Looping vars\n\n    for (i = 0; i < 624; i ++)\n    {\n      temp        = (mt_state[i] & 0x80000000) + (mt_state[i1] & 0x7fffffff);\n      mt_state[i] = mt_state[i397] ^ (temp >> 1);\n\n      if (temp & 1)\n\tmt_state[i] ^= 2567483615u;\n\n      i1 ++;\n      i397 ++;\n\n      if (i1 == 624)\n\ti1 = 0;\n\n      if (i397 == 624)\n\ti397 = 0;\n    }\n  }\n\n  // Pull 32-bits of random data...\n  temp = mt_state[mt_index ++];\n  temp ^= temp >> 11;\n  temp ^= (temp << 7) & 2636928640u;\n  temp ^= (temp << 15) & 4022730752u;\n  temp ^= temp >> 18;\n\n  if (mt_index == 624)\n    mt_index = 0;\n\n  return (temp);\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 213,
    "end_line": 288,
    "code": "else\n  // Use a Mersenne twister random number generator seeded from /dev/urandom...\n  unsigned\ti,\t\t\t// Looping var\n\t\ttemp;\t\t\t// Temporary value\n  static bool\tfirst_time = true;\t// First time we ran?\n  static unsigned mt_state[624],\t// Mersenne twister state\n\t\tmt_index;\t\t// Mersenne twister index\n\n\n  if (first_time)\n  {\n    int\t\tfd;\t\t\t// \"/dev/urandom\" file\n    struct timeval curtime;\t\t// Current time\n\n    // Seed the random number state...\n    if ((fd = open(\"/dev/urandom\", O_RDONLY)) >= 0)\n    {\n      // Read random entropy from the system...\n      if (read(fd, mt_state, sizeof(mt_state[0])) < sizeof(mt_state[0]))\n        mt_state[0] = 0;\t\t// Force fallback...\n\n      close(fd);\n    }\n    else\n      mt_state[0] = 0;\n\n    if (!mt_state[0])\n    {\n      // Fallback to using the current time in microseconds...\n      gettimeofday(&curtime, NULL);\n      mt_state[0] = (unsigned)(curtime.tv_sec + curtime.tv_usec);\n    }\n\n    mt_index = 0;\n\n    for (i = 1; i < 624; i ++)\n      mt_state[i] = (unsigned)((1812433253 * (mt_state[i - 1] ^ (mt_state[i - 1] >> 30))) + i);\n\n    first_time = false;\n  }\n\n  if (mt_index == 0)\n  {\n    // Generate a sequence of random numbers...\n    unsigned i1 = 1, i397 = 397;\t// Looping vars\n\n    for (i = 0; i < 624; i ++)\n    {\n      temp        = (mt_state[i] & 0x80000000) + (mt_state[i1] & 0x7fffffff);\n      mt_state[i] = mt_state[i397] ^ (temp >> 1);\n\n      if (temp & 1)\n\tmt_state[i] ^= 2567483615u;\n\n      i1 ++;\n      i397 ++;\n\n      if (i1 == 624)\n\ti1 = 0;\n\n      if (i397 == 624)\n\ti397 = 0;\n    }\n  }\n\n  // Pull 32-bits of random data...\n  temp = mt_state[mt_index ++];\n  temp ^= temp >> 11;\n  temp ^= (temp << 7) & 2636928640u;\n  temp ^= (temp << 15) & 4022730752u;\n  temp ^= temp >> 18;\n\n  if (mt_index == 624)\n    mt_index = 0;\n\n  return (temp);\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "global_variable",
    "start_line": 217,
    "end_line": 217,
    "code": "tatic bool\tfirst_time = true;\t",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 222,
    "end_line": 252,
    "code": "f (first_time)\n  {\n    int\t\tfd;\t\t\t// \"/dev/urandom\" file\n    struct timeval curtime;\t\t// Current time\n\n    // Seed the random number state...\n    if ((fd = open(\"/dev/urandom\", O_RDONLY)) >= 0)\n    {\n      // Read random entropy from the system...\n      if (read(fd, mt_state, sizeof(mt_state[0])) < sizeof(mt_state[0]))\n        mt_state[0] = 0;\t\t// Force fallback...\n\n      close(fd);\n    }\n    else\n      mt_state[0] = 0;\n\n    if (!mt_state[0])\n    {\n      // Fallback to using the current time in microseconds...\n      gettimeofday(&curtime, NULL);\n      mt_state[0] = (unsigned)(curtime.tv_sec + curtime.tv_usec);\n    }\n\n    mt_index = 0;\n\n    for (i = 1; i < 624; i ++)\n      mt_state[i] = (unsigned)((1812433253 * (mt_state[i - 1] ^ (mt_state[i - 1] >> 30))) + i);\n\n    first_time = false;\n  }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 223,
    "end_line": 252,
    "code": "\n    int\t\tfd;\t\t\t// \"/dev/urandom\" file\n    struct timeval curtime;\t\t// Current time\n\n    // Seed the random number state...\n    if ((fd = open(\"/dev/urandom\", O_RDONLY)) >= 0)\n    {\n      // Read random entropy from the system...\n      if (read(fd, mt_state, sizeof(mt_state[0])) < sizeof(mt_state[0]))\n        mt_state[0] = 0;\t\t// Force fallback...\n\n      close(fd);\n    }\n    else\n      mt_state[0] = 0;\n\n    if (!mt_state[0])\n    {\n      // Fallback to using the current time in microseconds...\n      gettimeofday(&curtime, NULL);\n      mt_state[0] = (unsigned)(curtime.tv_sec + curtime.tv_usec);\n    }\n\n    mt_index = 0;\n\n    for (i = 1; i < 624; i ++)\n      mt_state[i] = (unsigned)((1812433253 * (mt_state[i - 1] ^ (mt_state[i - 1] >> 30))) + i);\n\n    first_time = false;\n  }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct",
    "name": "timeval",
    "hierarchy": "timeval",
    "start_line": 225,
    "end_line": 225,
    "code": "truct timeval ",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 228,
    "end_line": 237,
    "code": "f ((fd = open(\"/dev/urandom\", O_RDONLY)) >= 0)\n    {\n      // Read random entropy from the system...\n      if (read(fd, mt_state, sizeof(mt_state[0])) < sizeof(mt_state[0]))\n        mt_state[0] = 0;\t\t// Force fallback...\n\n      close(fd);\n    }\n    else\n      mt_state[0] = 0;\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 229,
    "end_line": 235,
    "code": "\n      // Read random entropy from the system...\n      if (read(fd, mt_state, sizeof(mt_state[0])) < sizeof(mt_state[0]))\n        mt_state[0] = 0;\t\t// Force fallback...\n\n      close(fd);\n    }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 239,
    "end_line": 244,
    "code": "f (!mt_state[0])\n    {\n      // Fallback to using the current time in microseconds...\n      gettimeofday(&curtime, NULL);\n      mt_state[0] = (unsigned)(curtime.tv_sec + curtime.tv_usec);\n    }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 240,
    "end_line": 244,
    "code": "\n      // Fallback to using the current time in microseconds...\n      gettimeofday(&curtime, NULL);\n      mt_state[0] = (unsigned)(curtime.tv_sec + curtime.tv_usec);\n    }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 243,
    "end_line": 243,
    "code": "t_state[0] = (unsigned)(curtime.tv_sec + curtime.tv_usec);\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 243,
    "end_line": 243,
    "code": "t_state[0] = (unsigned)(curtime.tv_sec + curtime.tv_usec);",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 254,
    "end_line": 276,
    "code": "f (mt_index == 0)\n  {\n    // Generate a sequence of random numbers...\n    unsigned i1 = 1, i397 = 397;\t// Looping vars\n\n    for (i = 0; i < 624; i ++)\n    {\n      temp        = (mt_state[i] & 0x80000000) + (mt_state[i1] & 0x7fffffff);\n      mt_state[i] = mt_state[i397] ^ (temp >> 1);\n\n      if (temp & 1)\n\tmt_state[i] ^= 2567483615u;\n\n      i1 ++;\n      i397 ++;\n\n      if (i1 == 624)\n\ti1 = 0;\n\n      if (i397 == 624)\n\ti397 = 0;\n    }\n  }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 255,
    "end_line": 276,
    "code": "\n    // Generate a sequence of random numbers...\n    unsigned i1 = 1, i397 = 397;\t// Looping vars\n\n    for (i = 0; i < 624; i ++)\n    {\n      temp        = (mt_state[i] & 0x80000000) + (mt_state[i1] & 0x7fffffff);\n      mt_state[i] = mt_state[i397] ^ (temp >> 1);\n\n      if (temp & 1)\n\tmt_state[i] ^= 2567483615u;\n\n      i1 ++;\n      i397 ++;\n\n      if (i1 == 624)\n\ti1 = 0;\n\n      if (i397 == 624)\n\ti397 = 0;\n    }\n  }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "global_variable",
    "start_line": 257,
    "end_line": 257,
    "code": "nsigned i1 = 1, i397 = 397;\t",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "function",
    "start_line": 297,
    "end_line": 368,
    "name": "uncompress_packbits",
    "parent": null,
    "hierarchy": "uncompress_packbits",
    "code": "tatic size_t\t\t\t\t// O - Number of uncompressed bytes\nuncompress_packbits(\n    unsigned char       *dst,\t\t// I - Output buffer\n    size_t              dstsize,\t// I - Size of output buffer\n    const unsigned char *src,\t\t// I - Input buffer\n    size_t              srclen)\t\t// I - Length of input buffer\n{\n  const unsigned char\t*srcptr,\t// Pointer into input buffer\n\t\t\t*srcend;\t// End of input buffer\n  unsigned char\t\t*dstptr,\t// Pointer into output buffer\n\t\t\t*dstend;\t// End of output buffer\n  unsigned\t\tcount;\t\t// Literal/repeat count\n\n\n  // Loop through the input buffer and decompress...\n  dstptr = dst;\n  dstend = dst + dstsize;\n  srcptr = src;\n  srcend = src + srclen;\n\n  while (srcptr < srcend)\n  {\n    if (*srcptr < 0x80)\n    {\n      // N literal bytes\n      count = *srcptr + 1;\n      srcptr ++;\n      if ((srcptr + count) > srcend)\n      {\n        testError(\"Literal count %u but only %ld input bytes remaining.\", count, srcend - srcptr);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Literal count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memcpy(dstptr, srcptr, count);\n      dstptr += count;\n      srcptr += count;\n    }\n    else if (*srcptr == 0x80)\n    {\n      testError(\"Undefined pack value 0x80 seen.\");\n    }\n    else\n    {\n      count = 257 - *srcptr;\n      srcptr ++;\n\n      if (srcptr >= srcend)\n      {\n        testError(\"Repeat count %u but no input bytes remaining.\", count);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Repeat count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memset(dstptr, *srcptr, count);\n      dstptr += count;\n      srcptr ++;\n    }\n  }\n\n  return ((size_t)(dstptr - dst));\n}",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 297,
    "end_line": 368,
    "code": "tatic size_t\t\t\t\t// O - Number of uncompressed bytes\nuncompress_packbits(\n    unsigned char       *dst,\t\t// I - Output buffer\n    size_t              dstsize,\t// I - Size of output buffer\n    const unsigned char *src,\t\t// I - Input buffer\n    size_t              srclen)\t\t// I - Length of input buffer\n{\n  const unsigned char\t*srcptr,\t// Pointer into input buffer\n\t\t\t*srcend;\t// End of input buffer\n  unsigned char\t\t*dstptr,\t// Pointer into output buffer\n\t\t\t*dstend;\t// End of output buffer\n  unsigned\t\tcount;\t\t// Literal/repeat count\n\n\n  // Loop through the input buffer and decompress...\n  dstptr = dst;\n  dstend = dst + dstsize;\n  srcptr = src;\n  srcend = src + srclen;\n\n  while (srcptr < srcend)\n  {\n    if (*srcptr < 0x80)\n    {\n      // N literal bytes\n      count = *srcptr + 1;\n      srcptr ++;\n      if ((srcptr + count) > srcend)\n      {\n        testError(\"Literal count %u but only %ld input bytes remaining.\", count, srcend - srcptr);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Literal count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memcpy(dstptr, srcptr, count);\n      dstptr += count;\n      srcptr += count;\n    }\n    else if (*srcptr == 0x80)\n    {\n      testError(\"Undefined pack value 0x80 seen.\");\n    }\n    else\n    {\n      count = 257 - *srcptr;\n      srcptr ++;\n\n      if (srcptr >= srcend)\n      {\n        testError(\"Repeat count %u but no input bytes remaining.\", count);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Repeat count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memset(dstptr, *srcptr, count);\n      dstptr += count;\n      srcptr ++;\n    }\n  }\n\n  return ((size_t)(dstptr - dst));\n}",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 303,
    "end_line": 368,
    "code": "\n  const unsigned char\t*srcptr,\t// Pointer into input buffer\n\t\t\t*srcend;\t// End of input buffer\n  unsigned char\t\t*dstptr,\t// Pointer into output buffer\n\t\t\t*dstend;\t// End of output buffer\n  unsigned\t\tcount;\t\t// Literal/repeat count\n\n\n  // Loop through the input buffer and decompress...\n  dstptr = dst;\n  dstend = dst + dstsize;\n  srcptr = src;\n  srcend = src + srclen;\n\n  while (srcptr < srcend)\n  {\n    if (*srcptr < 0x80)\n    {\n      // N literal bytes\n      count = *srcptr + 1;\n      srcptr ++;\n      if ((srcptr + count) > srcend)\n      {\n        testError(\"Literal count %u but only %ld input bytes remaining.\", count, srcend - srcptr);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Literal count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memcpy(dstptr, srcptr, count);\n      dstptr += count;\n      srcptr += count;\n    }\n    else if (*srcptr == 0x80)\n    {\n      testError(\"Undefined pack value 0x80 seen.\");\n    }\n    else\n    {\n      count = 257 - *srcptr;\n      srcptr ++;\n\n      if (srcptr >= srcend)\n      {\n        testError(\"Repeat count %u but no input bytes remaining.\", count);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Repeat count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memset(dstptr, *srcptr, count);\n      dstptr += count;\n      srcptr ++;\n    }\n  }\n\n  return ((size_t)(dstptr - dst));\n}",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 317,
    "end_line": 365,
    "code": "hile (srcptr < srcend)\n  {\n    if (*srcptr < 0x80)\n    {\n      // N literal bytes\n      count = *srcptr + 1;\n      srcptr ++;\n      if ((srcptr + count) > srcend)\n      {\n        testError(\"Literal count %u but only %ld input bytes remaining.\", count, srcend - srcptr);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Literal count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memcpy(dstptr, srcptr, count);\n      dstptr += count;\n      srcptr += count;\n    }\n    else if (*srcptr == 0x80)\n    {\n      testError(\"Undefined pack value 0x80 seen.\");\n    }\n    else\n    {\n      count = 257 - *srcptr;\n      srcptr ++;\n\n      if (srcptr >= srcend)\n      {\n        testError(\"Repeat count %u but no input bytes remaining.\", count);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Repeat count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memset(dstptr, *srcptr, count);\n      dstptr += count;\n      srcptr ++;\n    }\n  }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 318,
    "end_line": 365,
    "code": "\n    if (*srcptr < 0x80)\n    {\n      // N literal bytes\n      count = *srcptr + 1;\n      srcptr ++;\n      if ((srcptr + count) > srcend)\n      {\n        testError(\"Literal count %u but only %ld input bytes remaining.\", count, srcend - srcptr);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Literal count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memcpy(dstptr, srcptr, count);\n      dstptr += count;\n      srcptr += count;\n    }\n    else if (*srcptr == 0x80)\n    {\n      testError(\"Undefined pack value 0x80 seen.\");\n    }\n    else\n    {\n      count = 257 - *srcptr;\n      srcptr ++;\n\n      if (srcptr >= srcend)\n      {\n        testError(\"Repeat count %u but no input bytes remaining.\", count);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Repeat count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memset(dstptr, *srcptr, count);\n      dstptr += count;\n      srcptr ++;\n    }\n  }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 319,
    "end_line": 364,
    "code": "f (*srcptr < 0x80)\n    {\n      // N literal bytes\n      count = *srcptr + 1;\n      srcptr ++;\n      if ((srcptr + count) > srcend)\n      {\n        testError(\"Literal count %u but only %ld input bytes remaining.\", count, srcend - srcptr);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Literal count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memcpy(dstptr, srcptr, count);\n      dstptr += count;\n      srcptr += count;\n    }\n    else if (*srcptr == 0x80)\n    {\n      testError(\"Undefined pack value 0x80 seen.\");\n    }\n    else\n    {\n      count = 257 - *srcptr;\n      srcptr ++;\n\n      if (srcptr >= srcend)\n      {\n        testError(\"Repeat count %u but no input bytes remaining.\", count);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Repeat count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memset(dstptr, *srcptr, count);\n      dstptr += count;\n      srcptr ++;\n    }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 320,
    "end_line": 339,
    "code": "\n      // N literal bytes\n      count = *srcptr + 1;\n      srcptr ++;\n      if ((srcptr + count) > srcend)\n      {\n        testError(\"Literal count %u but only %ld input bytes remaining.\", count, srcend - srcptr);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Literal count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memcpy(dstptr, srcptr, count);\n      dstptr += count;\n      srcptr += count;\n    }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 324,
    "end_line": 328,
    "code": "f ((srcptr + count) > srcend)\n      {\n        testError(\"Literal count %u but only %ld input bytes remaining.\", count, srcend - srcptr);\n        return (0);\n      }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 330,
    "end_line": 334,
    "code": "f (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Literal count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 340,
    "end_line": 364,
    "code": "lse if (*srcptr == 0x80)\n    {\n      testError(\"Undefined pack value 0x80 seen.\");\n    }\n    else\n    {\n      count = 257 - *srcptr;\n      srcptr ++;\n\n      if (srcptr >= srcend)\n      {\n        testError(\"Repeat count %u but no input bytes remaining.\", count);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Repeat count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memset(dstptr, *srcptr, count);\n      dstptr += count;\n      srcptr ++;\n    }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 340,
    "end_line": 364,
    "code": "f (*srcptr == 0x80)\n    {\n      testError(\"Undefined pack value 0x80 seen.\");\n    }\n    else\n    {\n      count = 257 - *srcptr;\n      srcptr ++;\n\n      if (srcptr >= srcend)\n      {\n        testError(\"Repeat count %u but no input bytes remaining.\", count);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Repeat count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memset(dstptr, *srcptr, count);\n      dstptr += count;\n      srcptr ++;\n    }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 344,
    "end_line": 364,
    "code": "lse\n    {\n      count = 257 - *srcptr;\n      srcptr ++;\n\n      if (srcptr >= srcend)\n      {\n        testError(\"Repeat count %u but no input bytes remaining.\", count);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Repeat count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memset(dstptr, *srcptr, count);\n      dstptr += count;\n      srcptr ++;\n    }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 345,
    "end_line": 364,
    "code": "\n      count = 257 - *srcptr;\n      srcptr ++;\n\n      if (srcptr >= srcend)\n      {\n        testError(\"Repeat count %u but no input bytes remaining.\", count);\n        return (0);\n      }\n\n      if (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Repeat count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n\n      memset(dstptr, *srcptr, count);\n      dstptr += count;\n      srcptr ++;\n    }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "struct_assignment",
    "start_line": 349,
    "end_line": 353,
    "code": "f (srcptr >= srcend)\n      {\n        testError(\"Repeat count %u but no input bytes remaining.\", count);\n        return (0);\n      }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  },
  {
    "type": "anonymous_initializer_block",
    "start_line": 355,
    "end_line": 359,
    "code": "f (count > (unsigned)(dstend - dstptr))\n      {\n        testError(\"Repeat count %u but only %ld output bytes remaining.\", count, dstend - dstptr);\n        return (0);\n      }\n",
    "file": "data/codebase/lprint/testpackbits.c"
  }
]